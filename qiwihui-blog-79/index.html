<!DOCTYPE html><html lang><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 《编写高质量Python代码的59个有效方法》笔记 · QIWIHUI</title><meta name="description" content="《编写高质量Python代码的59个有效方法》笔记 - qiwihui"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/nella.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.12/css/all.css" integrity="sha384-G0fIWCsCzJIMAVNQPfjH08cyYaUtMwjJwqiRKxxE/rx96Uroj1BtIQ6MLJuheaO9" crossorigin="anonymous"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
google_ad_client: "ca-pub-8935595858652656",
enable_page_level_ads: true
});
</script><link rel="search" type="application/opensearchdescription+xml" href="https://qiwihui.com/atom.xml" title="QIWIHUI"><script src="//code.jquery.com/jquery-2.2.4.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/images/avatar.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">HOME</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item"><a href="/links/" target="_self" class="nav-list-link">LINKS</a></li><!--li.nav-list-item--><!--    a.nav-list-link(class="search" href=url_for("search") target="_self") SEARCH--></ul></header><main class="container"></main><div class="post"><article class="post-block"><h1 class="post-title">《编写高质量Python代码的59个有效方法》笔记</h1><div class="post-info">Jan 9, 2020<span class="categories"><i class="fa fa-bookmark" aria-hidden="true"></i></span><span>14 min. read</span></div><div class="post-content"><h3>1. Python版本</h3>
<ul>
<li>Python 3</li>
<li>CPython, PyPy, Jython, IronPython</li>
</ul>
<h3>2. PEP8</h3>
<p>代码风格一致</p>
<h3>3. bytes，str，unicode（只讨论Python 3）</h3>
<p>Python 3中：bytes实例包含原始的8位值，str实例包含Unicode字符。把Unicode字符表示为二进制数据，最常见的编码方式是UTF-8。</p>
<ul>
<li>Unicode 字符 =&gt; 二进制：<code>encode</code></li>
<li>二进制 =&gt; Unicode 字符：<code>decode</code></li>
</ul>
<a id="more"></a>
<p>Python程序中，一定要把编码和解码放在最外围来操作。程序的核心部分应该使用Unicode字符类型，而且不要对字符编码做任何假设。</p>
<p>定义 <code>to_str</code> 和 <code>to_bytes</code> 方法。</p>
<p>Python 3中，<code>open</code>默认以<code>utf-8</code>编码打开，而不是二进制。</p>
<h3>4. 用辅助函数来取代复杂表达式</h3>
<h3>5. 序列切片</h3>
<ol>
<li><code>list</code>，<code>str</code>，<code>bytes</code> 以及实现了 <code>__getitem__</code> 和 <code>__setitem__</code>  的类；</li>
<li>切片时下表可以越界，但访问元素时不能；</li>
<li>当start索引为0或者end索引为列序列长度时，应该将其省略；</li>
<li>对list赋值时，使用切片会把原序列相关范围的值替换成新值，即使长度不一样；</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a = [1,2,3,4,5,6,7]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a[1:6] = [9]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a</span></span><br><span class="line">[1,9,7]</span><br></pre></td></tr></table></figure>
<h3>6. 步进式切割</h3>
<ol>
<li>避免在一个切片操作中同时使用 <code>start</code>，<code>end</code>和<code>stride</code>；</li>
<li>避免使用负数做stride；</li>
</ol>
<h3>7. 用列表推导代替map和filter</h3>
<ol>
<li>list, 字典和集合支持列表推导；</li>
<li>代码清晰；</li>
</ol>
<h3>8. 不要使用含有两个以上表达式的列表推导</h3>
<p>会变得难理解</p>
<h3>9. 用生成器表达式来改写数据量较大的列表推导式</h3>
<ol>
<li>
<p>数据量较大时，列表推导式会占用大量内存</p>
</li>
<li>
<p><code>()</code></p>
</li>
</ol>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a_long_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">value = [len(x) <span class="keyword">for</span> x <span class="keyword">in</span> a_long_list]</span><br><span class="line">print(value)</span><br></pre></td></tr></table></figure>
<p>=&gt;</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">value = (len(x) <span class="keyword">for</span> x <span class="keyword">in</span> a_long_list)</span><br><span class="line">print(next(value))</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>可以组合</li>
</ol>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">roots = ((v, v ** <span class="number">0.5</span>)<span class="keyword">for</span> v <span class="keyword">in</span> value)</span><br><span class="line">print(next(roots))</span><br></pre></td></tr></table></figure>
<h3>10. <code>range</code> =&gt; <code>enumerate</code></h3>
<p><code>enumerate</code> 可以把各种迭代器包装成生成器，以便稍后产生输出值。
<code>enumerate</code> 计数下表默认从 <code>0</code> 开始，可以修改。</p>
<h3>11. 用 <code>zip</code> 同是遍历两个迭代器</h3>
<ol>
<li>迭代器长度相同</li>
<li>不同时使用 <code>itertools.zip_longest</code></li>
</ol>
<h3>12. 不要在 <code>for</code> 和 <code>while</code> 循环后面写 <code>else</code></h3>
<p>与 <code>if/else</code>, <code>try/except/else</code> 的 <code>else</code> 不同，容易误解</p>
<h3>13. <code>try/except/else/finally</code></h3>
<ol>
<li><code>finally</code>块：既要将异常向上传播，又要在异常发生时做清理工作</li>
<li><code>ry/except/else</code>：except使异常传播变得清晰，else便于自己处理代码</li>
</ol>
<h3>14. 尽量用异常来表示特殊情况，而不要返回 <code>None</code></h3>
<p>比如除以0时，抛出异常</p>
<h3>15. 在闭包中使用外围作用域中的变量</h3>
<ol>
<li>Python3 获取闭包中的变量：<code>nonlocal</code>，但是<code>nonlocal</code>不能延伸到模块级别；</li>
<li>Python2 中可以使用可变值来实现，比如包含单个元素的列表。</li>
<li>除非函数简单，尽量不使用 <code>nonlocal</code></li>
</ol>
<h3>16. 考虑用生成器改写直接返回列表的函数</h3>
<p><code>yield</code></p>
<h3><em>17. 在参数上迭代时需要多加小心</em></h3>
<ol>
<li>参数是迭代器时要多加注意；</li>
<li>迭代器协议：容器和迭代器，<code>iter</code>，<code>next</code></li>
<li><code>__iter__</code></li>
<li>判断是否为迭代器：<code>iter(target) == iter(target)</code> 为True，则为迭代器</li>
</ol>
<h3>18. 用数量可变的位置参数减少视觉混乱</h3>
<ol>
<li>星号参数（<code>*args</code>），<code>*</code>操作符</li>
<li>变长参数在传给函数时，总是先转化成元组，如果是生成器，注意内存使用；</li>
<li>添加新参数时，需要修改原来函数使用。可使用关键字形式指定的参数解决这个问题。</li>
</ol>
<h3>19. 用关键字参数表达可选行为</h3>
<ol>
<li>位置参数必必须出现在关键字之前；每个参数只能指定一次；</li>
<li>关键字参数；易读，可提供默认值，扩充参数方便；</li>
</ol>
<h3>20. 用<code>None</code>和文档字符串描述具有动态默认值的参数</h3>
<ol>
<li>参数的默认值，只会在程序加载模块并读到本函数的定义时评估一次，对于<code>{}</code>，<code>[]</code>等动态值会出现奇怪行为。</li>
</ol>
<h3>21. 用只能以关键值形式指定的参数来确保代码明晰</h3>
<p>Python 3 中：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">safe_division_before</span><span class="params">(number, divisor, ignore_overflow=False, ignore_zero_divisor=False)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>==&gt;</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">safe_division_after</span><span class="params">(number, divisor, *, ignore_overflow=False, ignore_zero_divisor=False)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p><code>*</code> 标识着位置参数结束，之后的参数只能以关键字形式指定。</p>
<h3>22. 尽量用辅助类来维护程序状态，而不用字典和元组</h3>
<ol>
<li>不使用包含字典的字典或者过长的元组；</li>
<li>具名元组：<code>collections.namedtuple</code>；</li>
</ol>
<h3>23. 简单的接口应该接受函数，而不是类的实例</h3>
<ol>
<li>Python中的函数是一级对象，函数和方法可以像语言中的其他值那样传递和引用；</li>
<li>举例：
<ul>
<li><code>list</code>类型的<code>sort</code>方法</li>
<li><code>defaultdict</code></li>
</ul>
</li>
<li><code>__call__</code> 使类的实例像普通函数那样调用；</li>
<li>如果要用函数保存状态，就应该定义新的类，并令其实现 <code>__call__</code> 方法，而不要定义带状态的闭包。</li>
</ol>
<h3>24. 以 <code>@classmedtod</code> 形式的多态去通用地构建对象</h3>
<ol>
<li>每个类只能有一个构造器，即 <code>__init__</code>；</li>
<li><code>@@classmedtod</code> 机制可以用一种与构造器相似的方式构造类对象；</li>
</ol>
<h3>25. 用 <code>super</code> 初始化父类</h3>
<ol>
<li>Python采用标准的方法解析解析顺序来解决 <em>超类初始化次序</em> 和 <em>菱形继承问题</em>；</li>
<li><code>super</code> 在Python2和Python3不一致；</li>
</ol>
<p>Python 3 中以下两种方式效果相同</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Explicit</span><span class="params">(MyBaseClass)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        super(__class__, self).__init__(value)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implicit</span><span class="params">(MyBaseClass)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        super().__init__(value)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>总是应该使用内置的 <code>super</code> 函数来初始化父类；</li>
<li>类的 <code>mro</code> 方法可以查看方法解析顺序：<code>MyClass.mro()</code></li>
</ol>
<h3>26. 只在使用 Mix-in 组件制作工具类时进行多重继承</h3>
<ol>
<li>mix-in 是一种小型类，它只定义了其他类可能需要提供的一套附加方法，而不定义自己的实例属性，它也不要求使用者调用自己的 <code>__init__</code> 构造器；</li>
<li>能用 mix-in 组件实现的效果，就不要用多重继承来做；</li>
<li>将各个功能实现为可插拔的 mix-in 组件，然后让相关类继承自己需要的组件，即可定制该类实例所应具备的行为；</li>
<li>简单行为封装到 mix-in 组件中，然后用多个组件组合出复杂功能。</li>
</ol>
<h3>27. 多用 public 属性，少用 private 属性</h3>
<ol>
<li>Python解释器无法严格保证 private 字段的私密性（Python中会将类的 private 属性名称变化为 <code>_{类名称}__{原private属性名称}</code>）；</li>
<li>不要盲目将属性设置为 private，而是一开始就做好规划，并允许子类更多地访问超类内部API；</li>
<li>多用 protected 属性，并在文档中将这些字段的合理用法告诉开发者，而不要试图用 private 属性来限制子类访问；</li>
<li>只有当子类不受自己控制时，才可考虑使用 private 属性避免冲突。</li>
</ol>
<h3>28. 继承 <code>collections.abc</code> 以实现自定义容器类型</h3>
<p>编写自定义容器类型时，从 <code>collections.abc</code> 模块的抽象基类中继承，那些基类可以确保子类具有适当的接口和行为。</p>
<h3>49. 为每个函数、类和模块编写文档字符串</h3>
<ol>
<li>docstring</li>
</ol>
<h3>54. 模块级别代码配置不同的部署环境</h3>
<ol>
<li>环境变量</li>
<li><code>os</code>，<code>sys</code></li>
</ol>
<h3>55. 用 <code>repr</code> 输出调试信息</h3>
<ol>
<li><code>print</code> 易于阅读字符串</li>
<li><code>repr</code> 可供打印字符串，<code>eval</code> 还原为初始值</li>
<li>格式化字符串：<code>%s</code> =&gt; str; <code>%r</code> =&gt; repr</li>
<li><code>__repr__</code> 自定义可供打印字符串；</li>
<li><code>__dict__</code> 任意对象查询实例字典；</li>
</ol>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(5)</span></span><br><span class="line">5</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(<span class="string">'5'</span>)</span></span><br><span class="line">5</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(repr(5))</span></span><br><span class="line">5</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(repr(<span class="string">'5'</span>))</span></span><br><span class="line">'5'</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(<span class="string">'%s'</span> % 5)</span></span><br><span class="line">5</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(<span class="string">'%s'</span> % <span class="string">'5'</span>)</span></span><br><span class="line">5</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(<span class="string">'%r'</span> % 5)</span></span><br><span class="line">5</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(<span class="string">'%r'</span> % <span class="string">'5'</span>)</span></span><br><span class="line">'5'</span><br></pre></td></tr></table></figure>
<h3>56. unittest 测试</h3>
<p>要确保 Python 程序能正常运行，唯一的方法就是编写测试。
Python 语言动态特性，一方面阻碍了静态类型检测，另一方面却有利于开发者进行测试。</p>
<ol>
<li>断言（assertion）：<code>assertEqual</code>，<code>assertTrue</code>，<code>assertRaises</code></li>
<li>mock</li>
<li><code>setUp</code>，<code>tearDown</code></li>
<li>单元测试，集成测试</li>
</ol>
<h3>57. <code>pdb</code> 交互调试</h3>
<p><code>import pdb; pdb.set_trace()</code></p>
<ol>
<li><code>bt</code>，<code>up</code>，<code>down</code></li>
<li><code>step</code>，<code>next</code>，<code>return</code>，<code>continue</code></li>
</ol>
<h3>58. 性能分析</h3>
<ol>
<li>Python 性能分析工具 <code>profile</code>：<code>profile</code>，<code>cProfile</code></li>
<li><code>runcall</code></li>
<li><code>Stats</code></li>
</ol>
<h3>59. <code>tracemalloc</code> 内存使用及泄漏</h3>
<p>CPyhton：引用计数，gc</p>
<ol>
<li><code>gc.get_objects()</code></li>
<li><code>tracemalloc.take_snapshot()</code></li>
</ol>
<blockquote>
<p>GitHub repo: <a href="https://github.com/qiwihui/blog" target="_blank" rel="noopener">qiwihui/blog</a></p>
<p>Follow me: <a href="https://github.com/qiwihui" target="_blank" rel="noopener">@qiwihui</a></p>
<p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p>
</blockquote>
</div><p class="post-tags"><i class="fa fa-tags" aria-hidden="true"></i><a href="/tags/tips/">#tips</a><a href="/tags/Python/">#Python</a></p></article></div><div class="post-copyright"><blockquote><p>版权声明：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 | CC BY-NC-SA 4.0 </a>许可协议。</p></blockquote></div><footer><div class="paginator"><a href="/qiwihui-blog-81/" class="prev">PREV</a><a href="/qiwihui-blog-76/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'blog-qiwihui-com';
var disqus_identifier = 'qiwihui-blog-79/';
var disqus_title = '《编写高质量Python代码的59个有效方法》笔记';
var disqus_url = 'https://qiwihui.com/qiwihui-blog-79/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//blog-qiwihui-com.disqus.com/count.js" async></script><!-- block copyright--></footer></div><script async src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: true,
        processEnvironments: true,
        skipTags: ["script","noscript","style","textarea","code","pre"]
    }
});
</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-46660488-3",'auto');ga('send','pageview');</script><link rel="stylesheet" href="//cdn.datatables.net/1.10.7/css/jquery.dataTables.min.css" media="screen" type="text/css"><script src="//cdn.datatables.net/1.10.7/js/jquery.dataTables.min.js"></script><script>$(function(){$('.datatable').dataTable( {"order": [[ 0, "desc" ]],"iDisplayLength": -1,"lengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]} );});</script></body></html>