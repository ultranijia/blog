<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>QIWIHUI</title>
  
  <subtitle>Don&#39;t be evil or greedy.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://qiwihui.com/"/>
  <updated>2020-05-16T15:36:39.350Z</updated>
  <id>https://qiwihui.com/</id>
  
  <author>
    <name>qiwihui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GitHub Actions 第20天：容器服务</title>
    <link href="https://qiwihui.com/qiwihui-blog-103/"/>
    <id>https://qiwihui.com/qiwihui-blog-103/</id>
    <published>2020-04-12T18:57:48.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>很难低估容器在DevOps实践中的重要性。通常，你会将容器部署到生产环境中──因此很自然地开始使用容器进行本地开发，并管理依赖项。我们研究了如何利用它<a href="https://qiwihui.com/qiwihui-blog-88/">在容器内部</a>进行构建。但是，我们也可以使用<a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idservices" target="_blank" rel="noopener">容器服务</a>，将正在运行的容器用作构建和测试工作流程的一部分。</p><p>你通常需要运行一些与其他服务（通常是数据库）进行通信的集成测试。你可以通过编写 <code>docker run</code> 命令来拉下容器，启动容器并映射必要的端口，从而编写脚本，但这在最佳情况下很烦人。而且，如果你要<a href="https://qiwihui.com/qiwihui-blog-88/">在容器中进行构建</a>，则自己运行docker会变得非常棘手。</p><p>使用容器服务可以使GitHub Actions基础架构为你执行。你只需指定容器和要映射的任何端口，它将在作业开始时启动服务容器，并使该容器可用于作业中的步骤。</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">'redis:latest'</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">6379</span><span class="string">/tcp</span></span><br></pre></td></tr></table></figure><p>这将启动 <code>redis:latest</code> 容器并将容器中的端口6379映射到虚拟机运行程序上的端口。这等同于运行 <code>docker run redis:latest -p 6379/tcp</code>，就像你要运行该命令一样，映射到本地运行程序上的端口不是确定性的。GitHub Actions可在job.services上下文中提供此信息。</p><p>你可以查看 <code>$</code> 以标识本地端口号。（就像运行 <code>docker run</code> 一样，你还可以指定容器端口和本地端口，例如 <code>6379:6379</code>，将容器端口6379映射到本地端口6379。）</p><p>将其放入工作流中，如果我有一个 与Redis对话的 <a href="https://github.com/actions/example-services/tree/master/redis" target="_blank" rel="noopener">Node 脚本</a>，并连接到 <code>REDIS_HOST</code> 环境变量所指定的Redis主机的 `REDIS_PORT 端口，那么我可以创建一个工作流，该工作流启动Redis容器并运行Node脚本。</p><script src="https://gist.github.com/ethomson/466de42a3066a4fa646240f5fa20293b.js"></script><p>你可以使用服务容器来启动服务，例如 Redis， PostgreSQL 或MySQL甚至是Selenium。服务容器的执行使工作流中的这些容器的执行和交互变得更加容易。</p><p>原文链接：<a href="https://www.edwardthomson.com/blog/github_actions_20_container_services.html" target="_blank" rel="noopener">https://www.edwardthomson.com/blog/github_actions_20_container_services.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog" target="_blank" rel="noopener">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui" target="_blank" rel="noopener">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很难低估容器在DevOps实践中的重要性。通常，你会将容器部署到生产环境中──因此很自然地开始使用容器进行本地开发，并管理依赖项。我们研究了如何利用它&lt;a href=&quot;https://qiwihui.com/qiwihui-blog-88/&quot;&gt;在容器内部&lt;/a&gt;进行构建。但
      
    
    </summary>
    
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第19天：下载文件</title>
    <link href="https://qiwihui.com/qiwihui-blog-102/"/>
    <id>https://qiwihui.com/qiwihui-blog-102/</id>
    <published>2020-04-11T00:10:57.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>昨天，我们研究了如何在工作流运行过程中<a href="https://qiwihui.com/qiwihui-blog-101/">上传文件</a>，然后手动下载它们。这在许多情况下都非常有用，但是我认为使用文件的更强大的部分是使用工件在不同步骤之间传输文件。</p><p>例如：你可能有一个项目，该项目在多个平台上创建二进制文件，将这些二进制文件作为文件上载，然后发布到最后运行作业以将这些不同的二进制文件聚合到一个程序包中。</p><p>或者，你可能想散开──拥有一个创建单个文件的作业，然后在不同平台上运行多个作业以测试该文件。</p><a id="more"></a><p>在这里，我有一个测试我的本机代码的工作流程：首先，我构建本机代码测试运行器，该运行器使用 <a href="https://github.com/clar-test/clar" target="_blank" rel="noopener">clar</a> 单元测试框架，以便它编译一个以 <code>testapp</code> 命名的包含我所有单元测试的二进制文件。该二进制文件作为名为的文件上传 <code>tests</code>。然后，我将创建一个依赖于第一个<code>build</code> 作业的矩阵作业。它将使用最新版本的Ubuntu，Debian，CentOS和Alpine建立一个在容器内执行的矩阵。每个作业将下载 <code>tests</code> 构建作业中生成的文件，然后将设置 testapp 为可执行文件（因为文件不保留Unix权限），最后运行测试应用程序。</p><script src="https://gist.github.com/ethomson/9add864c916083aaf0c0d3b0bd092351.js"></script><p>当我运行它时，构建将产生一个文件，并且当该构建完成时，我的测试作业将全部开始，下载该文件，然后运行它。</p><p><img src="https://user-images.githubusercontent.com/3297411/79038436-d64bd580-7c0b-11ea-8984-e28ba788f465.png" alt="image"></p><p>你可以看到，上传文件对于生成构建输出非常有用，你可以在后续构建步骤中下载和使用这些输出。</p><p>原文链接：<a href="https://www.edwardthomson.com/blog/github_actions_19_downloading_artifacts.html" target="_blank" rel="noopener">https://www.edwardthomson.com/blog/github_actions_19_downloading_artifacts.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog" target="_blank" rel="noopener">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui" target="_blank" rel="noopener">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天，我们研究了如何在工作流运行过程中&lt;a href=&quot;https://qiwihui.com/qiwihui-blog-101/&quot;&gt;上传文件&lt;/a&gt;，然后手动下载它们。这在许多情况下都非常有用，但是我认为使用文件的更强大的部分是使用工件在不同步骤之间传输文件。&lt;/p&gt;
&lt;p&gt;例如：你可能有一个项目，该项目在多个平台上创建二进制文件，将这些二进制文件作为文件上载，然后发布到最后运行作业以将这些不同的二进制文件聚合到一个程序包中。&lt;/p&gt;
&lt;p&gt;或者，你可能想散开──拥有一个创建单个文件的作业，然后在不同平台上运行多个作业以测试该文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第18天：文件</title>
    <link href="https://qiwihui.com/qiwihui-blog-101/"/>
    <id>https://qiwihui.com/qiwihui-blog-101/</id>
    <published>2020-04-10T23:34:08.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>当你构建执行pull request验证或持续集成构建的工作流时，你通常希望获取该构建输出并保存它，以便以后使用。有时创建一个软件包并将其发布到<a href="https://qiwihui.com/qiwihui-blog-92/">GitHub packages</a>之类的软件包仓库中是有意义的 。但是有时你只想将其存储为构建输出的一部分，以后可以下载。GitHub Actions允许你将文件上传为工作流的一部分，以供日后下载。</p><p>要将文件作为构建的一部分进行上传，可以使用 <a href="https://github.com/actions/upload-artifact" target="_blank" rel="noopener"><code>upload-artifact</code></a> 操作。你可以指定为其创建文件的路径–你可以指定单个文件或文件夹，以及文件的名称。你指定的路径将以你指定的工件名称存档到一个zip文件中。</p><a id="more"></a><p>例如，我可以构建和测试我的项目，然后创建一个nuget包，最后将该nuget包作为文件上传。</p><script src="https://gist.github.com/ethomson/5101813150c57362ee072ee696d60be7.js"></script><p>现在，当我的工作流程运行时，我将在该运行的右上角获得一个选项，向我展示我的文件并让我下载它们。</p><p><img src="https://user-images.githubusercontent.com/3297411/79037750-64bd5880-7c06-11ea-8267-76a83bafe0ea.png" alt="image"></p><p>将构建输出作为文件上载可以与包仓库一起使用：我喜欢将CI构建包上载到GitHub packages，并从pull request中创建工件。这使我可以选择在本地运行和测试PR验证构建──我可以将它们作为文件下载──而不会影响我的GitHub Packages帐户。如果你希望选择在本地运行，那很好，即使你很少这样做。</p><p>原文连接：<a href="https://www.edwardthomson.com/blog/github_actions_18_artifacts.html" target="_blank" rel="noopener">https://www.edwardthomson.com/blog/github_actions_18_artifacts.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog" target="_blank" rel="noopener">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui" target="_blank" rel="noopener">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你构建执行pull request验证或持续集成构建的工作流时，你通常希望获取该构建输出并保存它，以便以后使用。有时创建一个软件包并将其发布到&lt;a href=&quot;https://qiwihui.com/qiwihui-blog-92/&quot;&gt;GitHub packages&lt;/a&gt;之类的软件包仓库中是有意义的 。但是有时你只想将其存储为构建输出的一部分，以后可以下载。GitHub Actions允许你将文件上传为工作流的一部分，以供日后下载。&lt;/p&gt;
&lt;p&gt;要将文件作为构建的一部分进行上传，可以使用 &lt;a href=&quot;https://github.com/actions/upload-artifact&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;upload-artifact&lt;/code&gt;&lt;/a&gt; 操作。你可以指定为其创建文件的路径–你可以指定单个文件或文件夹，以及文件的名称。你指定的路径将以你指定的工件名称存档到一个zip文件中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第17天：依赖作业</title>
    <link href="https://qiwihui.com/qiwihui-blog-100/"/>
    <id>https://qiwihui.com/qiwihui-blog-100/</id>
    <published>2020-04-10T23:02:59.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>如果你设置了包含多个作业的工作流程（无论是<a href="https://qiwihui.com/qiwihui-blog-85/">基于矩阵的工作流程</a>还是只是单独定义了作业），这些作业将彼此独立地并行运行。通常，这是理想的。只要有可用的计算机即可执行你的作业。</p><p>但是有时你希望能够设置依赖于其他作业的作业。例如，你可能有一些要测试的服务。但是为了节省成本，你只想在实际运行测试时运行那些服务。因此，你可能想要一个启动服务的作业，一个运行测试的工作业，然后是一个停止服务的作业。</p><p>要指定作业之间的依赖关系，可以使用 <code>needs</code> 关键字指示哪些作业依赖于其他作业的完成。</p><a id="more"></a><script src="https://gist.github.com/ethomson/1b52ca3b472b10a16972414f96c474fb.js"></script><p>现在，这似乎不是一个很好的例子–我们可能不使用单独的作业，而可能只在一个作业中完成了这三个步骤。但是使用作业可以使我们“成长”：实际上，我们可以在一个作业中设置测试基础结构，然后并行运行多个作业以对其进行测试，然后最后运行清理作业。</p><p><img src="https://user-images.githubusercontent.com/3297411/79037364-c380d300-7c02-11ea-9bcb-682b6f1bd2b1.png" alt="image"></p><p>这样一来，我们就可以在多个平台上并行运行测试作业，并通过设置将这些作业预定下来，然后停止作业。我们可以通过定义我们的安装作业，然后定义依赖于它的许多作业，然后依赖于这些作业的最终的工作。这通常称为“扇出”和“扇入”。</p><script src="https://gist.github.com/ethomson/11febc97d2b41187f5cbb8ddaf9bfdce.js"></script><p>通过此工作流程，我们的设置作业将运行，然后将使用矩阵在Windows，macOS和Linux上运行构建和测试作业，最后，我们将关闭启动的那些测试资源。</p><p><img src="https://user-images.githubusercontent.com/3297411/79037374-e3b09200-7c02-11ea-8618-5026cfdd9b63.png" alt="image"></p><p>你可以通过相互指定作业来轻松地构建高级工作流， <code>needs</code> 以指定工作流的依赖关系图。</p><p>原文连接：<a href="https://www.edwardthomson.com/blog/github_actions_17_dependent_jobs.html" target="_blank" rel="noopener">https://www.edwardthomson.com/blog/github_actions_17_dependent_jobs.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog" target="_blank" rel="noopener">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui" target="_blank" rel="noopener">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你设置了包含多个作业的工作流程（无论是&lt;a href=&quot;https://qiwihui.com/qiwihui-blog-85/&quot;&gt;基于矩阵的工作流程&lt;/a&gt;还是只是单独定义了作业），这些作业将彼此独立地并行运行。通常，这是理想的。只要有可用的计算机即可执行你的作业。&lt;/p&gt;
&lt;p&gt;但是有时你希望能够设置依赖于其他作业的作业。例如，你可能有一些要测试的服务。但是为了节省成本，你只想在实际运行测试时运行那些服务。因此，你可能想要一个启动服务的作业，一个运行测试的工作业，然后是一个停止服务的作业。&lt;/p&gt;
&lt;p&gt;要指定作业之间的依赖关系，可以使用 &lt;code&gt;needs&lt;/code&gt; 关键字指示哪些作业依赖于其他作业的完成。&lt;/p&gt;
    
    </summary>
    
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第16天：共享数据的条件</title>
    <link href="https://qiwihui.com/qiwihui-blog-99/"/>
    <id>https://qiwihui.com/qiwihui-blog-99/</id>
    <published>2020-03-29T07:00:31.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>昨天，我们研究了如何在工作流步骤之一中<a href="https://qiwihui.com/qiwihui-blog-98/">设置自定义数据</a>，以便在后续步骤中使用。我们通过向<a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/contexts-and-expression-syntax-for-github-actions#contexts" target="_blank" rel="noopener">env上下文</a>添加数据来做到这一点，它是一个你可以读写的属性包。</p><p>但是你不必将自己局限于仅在你的步骤中使用 <code>env</code> 上下文。你还可以在工作流本身中使用 <code>env</code> 上下文，并根据在先前步骤中设置的数据来<a href="https://qiwihui.com/qiwihui-blog-96/">设置条件</a>。</p><p>例如，你可能有一个每天要运行的工作流，并且你希望对该工作流在星期一的运行方式进行较小的修改。你可以使用 <a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#onschedule" target="_blank" rel="noopener"><code>schedule</code> 触发器</a>每天运行工作流程。你可以复制该工作流程，并添加只希望在星期一运行的特殊更改。但是，呵呵，维持两个相似但只有一点点不同的工作流程是一个严重的难题。</p><a id="more"></a><p>取而代之的是，你可以查看星期几并在此基础上设置一个环境变量──在这里，我将使用bash语法运行 <code>date</code> 命令以打印缩写的星期几，并将其放入我的 <code>echo</code> 语句中，将 <code>DAY_OF_WEEK</code> 在我们的 <code>env</code> 上下文中设置变量 。然后，我将其 <code>env.DAY_OF_WEEK</code> 作为后续步骤的条件。</p><script src="https://gist.github.com/ethomson/c241fcd622172139ccaae0ab8088c75c.js"></script><p>使用此配置，我将每天在世界标准时间05:00运行工作流。与今天一样，在星期一，将运行仅星期一的步骤。</p><p><img src="https://user-images.githubusercontent.com/3297411/77852191-d8776280-720f-11ea-99f0-a50f64ceabd6.png" alt="image"></p><p>但是在本周的剩余时间里，该步骤将被跳过。</p><p><img src="https://user-images.githubusercontent.com/3297411/77852197-dca38000-720f-11ea-8aa0-9ccfab150f3a.png" alt="image"></p><p>这是另一个很好的例子，说明GitHub Actions如何为你提供简单的原语，你可以将它们组合在一起以创建功能强大的工作流。</p><p>原文链接：<a href="https://www.edwardthomson.com/blog/github_actions_16_conditionals_with_shared_data.html" target="_blank" rel="noopener">https://www.edwardthomson.com/blog/github_actions_16_conditionals_with_shared_data.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog" target="_blank" rel="noopener">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui" target="_blank" rel="noopener">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天，我们研究了如何在工作流步骤之一中&lt;a href=&quot;https://qiwihui.com/qiwihui-blog-98/&quot;&gt;设置自定义数据&lt;/a&gt;，以便在后续步骤中使用。我们通过向&lt;a href=&quot;https://help.github.com/en/actions/automating-your-workflow-with-github-actions/contexts-and-expression-syntax-for-github-actions#contexts&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;env上下文&lt;/a&gt;添加数据来做到这一点，它是一个你可以读写的属性包。&lt;/p&gt;
&lt;p&gt;但是你不必将自己局限于仅在你的步骤中使用 &lt;code&gt;env&lt;/code&gt; 上下文。你还可以在工作流本身中使用 &lt;code&gt;env&lt;/code&gt; 上下文，并根据在先前步骤中设置的数据来&lt;a href=&quot;https://qiwihui.com/qiwihui-blog-96/&quot;&gt;设置条件&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;例如，你可能有一个每天要运行的工作流，并且你希望对该工作流在星期一的运行方式进行较小的修改。你可以使用 &lt;a href=&quot;https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#onschedule&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;schedule&lt;/code&gt; 触发器&lt;/a&gt;每天运行工作流程。你可以复制该工作流程，并添加只希望在星期一运行的特殊更改。但是，呵呵，维持两个相似但只有一点点不同的工作流程是一个严重的难题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第15天：在步骤之间共享数据</title>
    <link href="https://qiwihui.com/qiwihui-blog-98/"/>
    <id>https://qiwihui.com/qiwihui-blog-98/</id>
    <published>2020-03-29T06:50:28.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>在 GitHub Actions 的任务中，你可以有多个步骤 ，一个接一个地运行。每个步骤可能是调用一个操作（例如，<a href="https://github.com/actions/checkout" target="_blank" rel="noopener">检出存储库中的代码</a>或<a href="https://github.com/actions/setup-node" target="_blank" rel="noopener">安装特定版本的Node.js</a>），也可能是一个 <code>run</code>，仅运行你提供的脚本的步骤。</p><p>但是通常你希望与之前执行的步骤进行交互，例如，你可能希望运行一个步骤来更新软件的版本号，以使其准备好发布。然后，你可能需要在实际的发布步骤中使用该版本号。</p><a id="more"></a><p>但是，如何来回获取这些数据？GitHub Actions在其自己的流程中运行你的每个步骤。这意味着你不能只在一个步骤中设置环境变量，然后在另一步骤中引用它。换句话说，这将无法正常工作：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line">  <span class="comment"># 这将 **无效**。这两个 `run` 步骤被编写为</span></span><br><span class="line">  <span class="comment"># 作为不同的脚本并由不同的shell运行，因此</span></span><br><span class="line">  <span class="comment"># `FOO` 变量将不会在它们之间持久存在。</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">export</span> <span class="string">FOO=bar</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">echo</span> <span class="string">$FOO</span></span><br></pre></td></tr></table></figure><p>但是，GitHub Actions 确实为你提供了将数据持久保存在执行环境中的工具。你可以通过写入标准输出（即，仅使用echo）来向GitHub Actions编写命令──包括指示 GitHub Actions 在后续运行步骤中<a href="https://github.com/actions/setup-node" target="_blank" rel="noopener">设置环境变量的命令</a>。</p><p>在当前shell中设置环境变量之后，可以对GitHub Actions 使用命令 <code>set-env</code> ，这将是环境变量被注入到以后的步骤中：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line">  <span class="comment"># 这将会在第一个 `run` 脚本中设置 `FOO` 环境变量。</span></span><br><span class="line">  <span class="comment"># 然后指示 GitHub Actions 在随后的运行步骤中使其可用。</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">      <span class="string">export</span> <span class="string">FOO=bar</span></span><br><span class="line">      <span class="string">echo</span> <span class="string">"::set-env name=FOO::$FOO"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">echo</span> <span class="string">$FOO</span></span><br></pre></td></tr></table></figure><p>现在，实际上可以在后续步骤中获取环境变量 <code>FOO</code> 中的数据。</p><p><img src="https://user-images.githubusercontent.com/3297411/77851728-322a5d80-720d-11ea-8a61-43a2b1c99549.png" alt="image"></p><p>GitHub Actions将这些步骤作为单独的脚本运行──这意味着在单独的Shell调用中运行并每次都获得原始环境。但是，使用GitHub Actions平台内的开发工具，你可以在调用之间共享数据。</p><p>原文链接：<a href="https://www.edwardthomson.com/blog/github_actions_15_sharing_data_between_steps.html" target="_blank" rel="noopener">https://www.edwardthomson.com/blog/github_actions_15_sharing_data_between_steps.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog" target="_blank" rel="noopener">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui" target="_blank" rel="noopener">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 GitHub Actions 的任务中，你可以有多个步骤 ，一个接一个地运行。每个步骤可能是调用一个操作（例如，&lt;a href=&quot;https://github.com/actions/checkout&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;检出存储库中的代码&lt;/a&gt;或&lt;a href=&quot;https://github.com/actions/setup-node&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;安装特定版本的Node.js&lt;/a&gt;），也可能是一个 &lt;code&gt;run&lt;/code&gt;，仅运行你提供的脚本的步骤。&lt;/p&gt;
&lt;p&gt;但是通常你希望与之前执行的步骤进行交互，例如，你可能希望运行一个步骤来更新软件的版本号，以使其准备好发布。然后，你可能需要在实际的发布步骤中使用该版本号。&lt;/p&gt;
    
    </summary>
    
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第14天：矩阵条件</title>
    <link href="https://qiwihui.com/qiwihui-blog-97/"/>
    <id>https://qiwihui.com/qiwihui-blog-97/</id>
    <published>2020-03-27T07:50:47.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>GitHub Actions 具有许多强大的组件，但是当你开始一起使用它们时，事情就开始变得真正强大。例如：矩阵工作流使你可以轻松地将简单的工作流扩展到多个不同的作业。通过条件执行，你可以限制作业中步骤的执行。</p><p>这两个功能很自然地结合在一起──当你跨不同的操作系统，平台或语言版本构建矩阵时，可能只需要在该矩阵的一个子集上运行一些步骤。例如：在Linux上运行时，可能需要安装其他编译器，或者对于不同的操作系统，可能需要安装稍有不同的依赖项。</p><p>我可以结合一些以前的概念来为我的一个项目（C语言中的系统库）构建工作流。它将使用<a href="https://qiwihui.com/qiwihui-blog-86/">跨平台</a>和<a href="https://qiwihui.com/qiwihui-blog-87/">工具安装</a>的<a href="https://qiwihui.com/qiwihui-blog-85/">矩阵工作流</a>来执行CI的构建和测试步骤。</p><a id="more"></a><p>目标是安装Ninja构建系统，然后使用CMake创建构建脚本以利用这一优势──CMake和Ninja可以很好地协同工作，以生成快速，跨平台的本机构建。最后，我们将使用 <code>cmake</code> 进行构建，并使用 <code>ctest</code> 进行测试。</p><script src="https://gist.github.com/ethomson/79c787cecee5c23f2c791500d6644583.js"></script><p>运行此命令时，条件将确保仅对特定平台运行适当的“安装依赖项”步骤。其他平台的其他步骤将被跳过。</p><p><img src="https://user-images.githubusercontent.com/3297411/77774001-58bd8c80-7085-11ea-8a82-90115b7ba69f.png" alt="image"></p><p>现在，我们开始了解如何将GitHub Actions的简单片段组合到更复杂，功能更强大的工作流程中。</p><p>原文链接：<a href="https://www.edwardthomson.com/blog/github_actions_14_conditionals_with_a_matrix.html" target="_blank" rel="noopener">https://www.edwardthomson.com/blog/github_actions_14_conditionals_with_a_matrix.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog" target="_blank" rel="noopener">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui" target="_blank" rel="noopener">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GitHub Actions 具有许多强大的组件，但是当你开始一起使用它们时，事情就开始变得真正强大。例如：矩阵工作流使你可以轻松地将简单的工作流扩展到多个不同的作业。通过条件执行，你可以限制作业中步骤的执行。&lt;/p&gt;
&lt;p&gt;这两个功能很自然地结合在一起──当你跨不同的操作系统，平台或语言版本构建矩阵时，可能只需要在该矩阵的一个子集上运行一些步骤。例如：在Linux上运行时，可能需要安装其他编译器，或者对于不同的操作系统，可能需要安装稍有不同的依赖项。&lt;/p&gt;
&lt;p&gt;我可以结合一些以前的概念来为我的一个项目（C语言中的系统库）构建工作流。它将使用&lt;a href=&quot;https://qiwihui.com/qiwihui-blog-86/&quot;&gt;跨平台&lt;/a&gt;和&lt;a href=&quot;https://qiwihui.com/qiwihui-blog-87/&quot;&gt;工具安装&lt;/a&gt;的&lt;a href=&quot;https://qiwihui.com/qiwihui-blog-85/&quot;&gt;矩阵工作流&lt;/a&gt;来执行CI的构建和测试步骤。&lt;/p&gt;
    
    </summary>
    
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第13天：条件</title>
    <link href="https://qiwihui.com/qiwihui-blog-96/"/>
    <id>https://qiwihui.com/qiwihui-blog-96/</id>
    <published>2020-03-27T06:57:34.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>昨天我们看到，当你运行工作流程时，有许多可用数据。你可以在run步骤中使用这些数据，并将其与构建脚本，部署步骤或存储库自动化一起使用。但是你也可以在工作流本身中使用它。</p><p>利用这些数据的一种有用方法是<a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idif" target="_blank" rel="noopener">有条件地使用它来运行工作流步骤</a>。</p><p>例如，你可能想在执行步骤之前检查工作流在其中运行的存储库的名称。如果你正在开发一个开源项目，这将很有帮助──因为fork你的存储库的人拥有<a href="https://qiwihui.com/qiwihui-blog-94/">具有不同权限的令牌</a>，因此你可以跳过fork的发布步骤。</p><a id="more"></a><p>这使fork的存储库仍可以执行连续的集成构建，并确保在运行构建和测试通过时工作流成功，并且不会由于发布步骤上的权限问题而失败。</p><p>你可以设置一个条件，以确保你位于正确的存储库上并在CI构建中运行（来自push事件）。</p><script src="https://gist.github.com/ethomson/9befd0258967e0a3006295b149792c84.js"></script><p>现在，当此工作流在fork中运行时，将跳过“发布文档”步骤。</p><p><img src="https://user-images.githubusercontent.com/3297411/77768483-81418880-707d-11ea-8e35-d932d5d032cf.png" alt="image"></p><p>使用条件语句使你可以构建可在分支或分支之间共享的高级工作流，但其中某些步骤是针对特定触发器或环境量身定制的。</p><p>原文链接：<a href="https://www.edwardthomson.com/blog/github_actions_13_conditionals.html" target="_blank" rel="noopener">https://www.edwardthomson.com/blog/github_actions_13_conditionals.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog" target="_blank" rel="noopener">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui" target="_blank" rel="noopener">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天我们看到，当你运行工作流程时，有许多可用数据。你可以在run步骤中使用这些数据，并将其与构建脚本，部署步骤或存储库自动化一起使用。但是你也可以在工作流本身中使用它。&lt;/p&gt;
&lt;p&gt;利用这些数据的一种有用方法是&lt;a href=&quot;https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idif&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;有条件地使用它来运行工作流步骤&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;例如，你可能想在执行步骤之前检查工作流在其中运行的存储库的名称。如果你正在开发一个开源项目，这将很有帮助──因为fork你的存储库的人拥有&lt;a href=&quot;https://qiwihui.com/qiwihui-blog-94/&quot;&gt;具有不同权限的令牌&lt;/a&gt;，因此你可以跳过fork的发布步骤。&lt;/p&gt;
    
    </summary>
    
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第12天：有关工作流程的信息</title>
    <link href="https://qiwihui.com/qiwihui-blog-95/"/>
    <id>https://qiwihui.com/qiwihui-blog-95/</id>
    <published>2020-03-27T00:30:15.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>昨天我们看到GitHub为GitHub Actions工作流运行提供了一些信息，即 <code>GITHUB_TOKEN</code>。但这还不是全部。GitHub Actions还为你提供什么其他信息？</p><p>其实很多！</p><p>GitHub Actions <a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/contexts-and-expression-syntax-for-github-actions#github-context" target="_blank" rel="noopener">设置了许多信息“上下文”</a>，其中包含有关你的工作流程运行的数据。例如，github 上下文包含信息，例如你的工作流在其中运行的存储库的名称 <code>github.repository</code>，启动工作流的用户 <code>github.actor</code>。你可以使用与 <a href="https://qiwihui.com/qiwihui-blog-85/">处理矩阵</a> 和 <a href="https://qiwihui.com/qiwihui-blog-94/">密码</a> 相同的双弯括号扩展语法来引用它们。</p><a id="more"></a><script src="https://gist.github.com/ethomson/ef9e54a1dbef5dfa240833b9b6cc6e7e.js"></script><p><img src="https://user-images.githubusercontent.com/3297411/77735916-58ea6780-7046-11ea-851f-1d015a832fce.png" alt="image"></p><p>如果你想在上下文中查看GitHub Actions提供的所有信息，则可以实际使用方便的 <code>toJson</code> 函数来输出整个对象：</p><script src="https://gist.github.com/ethomson/fd59328c86a28792a13c553784ce54fb.js"></script><p><img src="https://user-images.githubusercontent.com/3297411/77735932-6142a280-7046-11ea-80c6-2f1e979b2888.png" alt="image"></p><p>如果这样做，你会注意到GitHub上下文中有很多信息。特别是，<code>github.event</code> 对象本身就是一块巨大的json数据。它基本上包含与触发器相对应的 <a href="https://developer.github.com/v3/activity/events/types/#pushevent" target="_blank" rel="noopener">Webhook 信息</a>。</p><p>相同的事件信息已保存到磁盘上的 <code>github.event_path</code>。因此，你可以通过检查json blob来获取工作流程中的所有信息。幸运的是，非常方便的 <a href="https://stedolan.github.io/jq/" target="_blank" rel="noopener">jq</a> 工具已安装在 runner 上。你可以使用它在命令行上分解json数据。</p><p>例如，如果我想获取存储库中的星标数量和fork数量，则可以 <code>jq</code> 用来解压缩保存在的json数据 <code>github.event_path</code>。</p><script src="https://gist.github.com/ethomson/d1756c60ada050a30f86da44bf1e5f29.js"></script><p><img src="https://user-images.githubusercontent.com/3297411/77735957-6c95ce00-7046-11ea-9c5d-eeafe7628594.png" alt="image"></p><p>GitHub Actions提供了大量有关存储库，触发运行的操作以及环境的数据，所有这些使你能够创建工作流以构建应用程序，部署应用程序或自动执行存储库中的某些任务。</p><p>原文链接：<a href="https://www.edwardthomson.com/blog/github_actions_12_information_about_your_workflow.html" target="_blank" rel="noopener">https://www.edwardthomson.com/blog/github_actions_12_information_about_your_workflow.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog" target="_blank" rel="noopener">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui" target="_blank" rel="noopener">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天我们看到GitHub为GitHub Actions工作流运行提供了一些信息，即 &lt;code&gt;GITHUB_TOKEN&lt;/code&gt;。但这还不是全部。GitHub Actions还为你提供什么其他信息？&lt;/p&gt;
&lt;p&gt;其实很多！&lt;/p&gt;
&lt;p&gt;GitHub Actions &lt;a href=&quot;https://help.github.com/en/actions/automating-your-workflow-with-github-actions/contexts-and-expression-syntax-for-github-actions#github-context&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;设置了许多信息“上下文”&lt;/a&gt;，其中包含有关你的工作流程运行的数据。例如，github 上下文包含信息，例如你的工作流在其中运行的存储库的名称 &lt;code&gt;github.repository&lt;/code&gt;，启动工作流的用户 &lt;code&gt;github.actor&lt;/code&gt;。你可以使用与 &lt;a href=&quot;https://qiwihui.com/qiwihui-blog-85/&quot;&gt;处理矩阵&lt;/a&gt; 和 &lt;a href=&quot;https://qiwihui.com/qiwihui-blog-94/&quot;&gt;密码&lt;/a&gt; 相同的双弯括号扩展语法来引用它们。&lt;/p&gt;
    
    </summary>
    
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第11天：密码（Secrets）</title>
    <link href="https://qiwihui.com/qiwihui-blog-94/"/>
    <id>https://qiwihui.com/qiwihui-blog-94/</id>
    <published>2020-03-27T00:13:17.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>昨天我们建立了一个基于<a href="https://qiwihui.com/qiwihui-blog-93/">改变路径</a>触发的工作流; 它的目标是发布文档。如果仔细看，在工作流程的底部，我们引用了一个变量。看起来有点像我们<a href="https://qiwihui.com/qiwihui-blog-85/">引用矩阵变量</a>的方式 ，而这里引用了一个密码。</p><p>在部署场景中，你通常会需要令牌或密码之类的东西──GitHub Actions支持将这些作为密码保存在存储库中。</p><p>要设置密码，请转到“存储库设置”页面，然后选择“密码”。你的密码名称将在你的工作流中用于引用数据，你可以将密码本身放入值中。</p><a id="more"></a><p><img src="https://user-images.githubusercontent.com/3297411/77734745-39523f80-7044-11ea-8aed-91f6dde277e0.png" alt="image"></p><p>要使用该密码，你可以在工作流中使用上下文 <code>secrets</code> 来引用它。如果你有一个密码的名字 <code>SECRET_KEY</code>，你可以将其称为 <code>$</code>。</p><script src="https://gist.github.com/ethomson/eb722482cfd7f955f17c3231efe8804a.js"></script><h2><code>GITHUB_TOKEN</code></h2><p>GitHub Actions会为每次运行的工作流自动在存储库中设置一个密码 <code>GITHUB_TOKEN</code>。该令牌使你可以与存储库进行交互，而无需自己创建新令牌或设置密码。</p><p>该令牌为你提供了对存储库本身，issue和<a href="https://www.edwardthomson.com/blog/github_actions_9_deploy_to_github_packages.html" target="_blank" rel="noopener">GitHub Packages</a>进行读写的有限访问权限。但是它不能完全访问所有内容──你无法与组织中的其他存储库一起使用，也无法发布到GitHub Pages──因此，对于某些工作流，你可能仍需要设置令牌。</p><h2>密码安全</h2><p>GitHub试图防止你的密码被窥视。在输出日志中，你定义的所有密码都会被清除，并在输出日志之前用星号替换。</p><p><img src="https://user-images.githubusercontent.com/3297411/77734893-7ddddb00-7044-11ea-93af-18ab47df2ffd.png" alt="image"></p><p>这有助于保护你的密码，防止他人窥视，尤其是利用那些导出值的工具。但这当然不是完美的，你应该谨慎保护密码。</p><h2>Forks</h2><p>如果你的项目使用fork来接受来自贡献者的pull request（例如，如果你正在开发一个开源项目），则可能对在工作流程中使用密码有所警惕。</p><p>GitHub明确 <strong>禁用</strong> 了对来自fork的工作流提供密码的功能。这意味着，当用户从fork打开对你的项目的pull request时，不会向此工作流提供任何密码。</p><p><img src="https://user-images.githubusercontent.com/3297411/77734903-86361600-7044-11ea-8475-410b7380eb83.png" alt="image"></p><p>这有助于防止用户修改工作流程本身──或工作流程调用的任何脚本──试图获取你的密码副本。这些密码根本无法获得。</p><p>（<code>GITHUB_TOKEN</code>仍然为fork提供了特殊功能，以便它们可以克隆你的存储库（以便构建它），但已将其降级为只读令牌，以防止fork工作流在你的存储库中进行更改。）</p><p>原文链接：<a href="https://www.edwardthomson.com/blog/github_actions_11_secrets.html" target="_blank" rel="noopener">https://www.edwardthomson.com/blog/github_actions_11_secrets.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog" target="_blank" rel="noopener">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui" target="_blank" rel="noopener">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天我们建立了一个基于&lt;a href=&quot;https://qiwihui.com/qiwihui-blog-93/&quot;&gt;改变路径&lt;/a&gt;触发的工作流; 它的目标是发布文档。如果仔细看，在工作流程的底部，我们引用了一个变量。看起来有点像我们&lt;a href=&quot;https://qiwihui.com/qiwihui-blog-85/&quot;&gt;引用矩阵变量&lt;/a&gt;的方式 ，而这里引用了一个密码。&lt;/p&gt;
&lt;p&gt;在部署场景中，你通常会需要令牌或密码之类的东西──GitHub Actions支持将这些作为密码保存在存储库中。&lt;/p&gt;
&lt;p&gt;要设置密码，请转到“存储库设置”页面，然后选择“密码”。你的密码名称将在你的工作流中用于引用数据，你可以将密码本身放入值中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第10天：路径触发器</title>
    <link href="https://qiwihui.com/qiwihui-blog-93/"/>
    <id>https://qiwihui.com/qiwihui-blog-93/</id>
    <published>2020-03-25T08:03:46.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们看到可以限制<a href="https://qiwihui.com/qiwihui-blog-84/">基于分支过滤器的</a>工作流运行。对于由 <code>push</code> 或 <code>pull_request</code> 触发的工作流，你可以对其进行限制，以使其仅在推送到特定分支或针对特定分支打开 pull request 时才触发。</p><p>你还可以限制这些工作流，以便仅在<a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#onpushpull_requestpaths" target="_blank" rel="noopener">推送特定路径</a>时才触发它们。</p><a id="more"></a><p>如果你在提交某些东西时会运行一些自动化功能，这将非常有用。例如：在我的一个开源项目中，每次将提交合并到master分支中时，我们都会将文档发布到我们的网站上。但是，我们只想在文档实际更改时运行该工作流程。</p><p>在这种情况下，我们希望docs在master分支中目录中的任何内容更改时运行。我们可以使用<a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#filter-pattern-cheat-sheet" target="_blank" rel="noopener">通配符</a>作为路径过滤器的一部分：</p><script src="https://gist.github.com/ethomson/5244d867cb44c3d855f05094562d6dc2.js"></script><p>现在，我们有了一个工作流程，只要我们对文件docs夹中的文件进行新更改并将其合并到master分支中，就可以运行脚本 <code>publish_docs.sh</code>。</p><p>原文链接：<a href="https://www.edwardthomson.com/blog/github_actions_10_path_triggers.html" target="_blank" rel="noopener">https://www.edwardthomson.com/blog/github_actions_10_path_triggers.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog" target="_blank" rel="noopener">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui" target="_blank" rel="noopener">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面我们看到可以限制&lt;a href=&quot;https://qiwihui.com/qiwihui-blog-84/&quot;&gt;基于分支过滤器的&lt;/a&gt;工作流运行。对于由 &lt;code&gt;push&lt;/code&gt; 或 &lt;code&gt;pull_request&lt;/code&gt; 触发的工作流，你可以对其进行限制，以使其仅在推送到特定分支或针对特定分支打开 pull request 时才触发。&lt;/p&gt;
&lt;p&gt;你还可以限制这些工作流，以便仅在&lt;a href=&quot;https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#onpushpull_requestpaths&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;推送特定路径&lt;/a&gt;时才触发它们。&lt;/p&gt;
    
    </summary>
    
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第9天：部署到GitHub Packages</title>
    <link href="https://qiwihui.com/qiwihui-blog-92/"/>
    <id>https://qiwihui.com/qiwihui-blog-92/</id>
    <published>2020-03-25T07:46:23.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>本月到目前为止，我们已经研究了许多执行构建并运行一些测试的方案。这些都是很棒的工作流程──它们确保进入你的项目的pull request是高质量的，并且你的主分支是健康的。</p><p>但是，你通常想采取下一步并部署自己构建的内容。例如，你可能想构建一个容器，并在每次新的主分支合入新功能时将其上传到<a href="https://github.com/features/packages" target="_blank" rel="noopener">GitHub Packages</a>。这将确保你有一个可以运行并验证每个更改的容器。</p><p>为此，我们要触发向master的推送。（无论是从 <code>git push</code> 还是从合并pull request，只要<a href="https://www.edwardthomson.com/blog/github_actions_1_cicd_triggers.html" target="_blank" rel="noopener">集成到master</a>中，<code>push</code> 触发器都将运行。）</p><p>然后，我们将从docker登录到GitHub Packages。我们可以简单地使用GitHub Actions提供给我们的 <code>GITHUB_TOKEN</code>──令牌对我们存储库中的软件包具有发布权限。</p><a id="more"></a><p>然后，我们将构建容器，并使用包注册的名称对其进行标记（在本例中是 <code>docker.pkg.github.com</code> 其后为容器的名称 <code>ethomson/myrepo/app</code>），并为其指定版本号，即Unix时间。</p><p>最后，我们<a href="https://gist.github.com/ethomson/60e664ef09051cea66dada5d53c62e6d" target="_blank" rel="noopener">将容器推送到GitHub Packages</a>。</p><script src="https://gist.github.com/ethomson/60e664ef09051cea66dada5d53c62e6d.js"></script><p>现在，我有一个简单的连续部署系统，该系统将始终使用包含来自master分支的最新版本的容器来更新GitHub Packages。</p><p>原文链接：<a href="https://www.edwardthomson.com/blog/github_actions_9_deploy_to_github_packages.html" target="_blank" rel="noopener">https://www.edwardthomson.com/blog/github_actions_9_deploy_to_github_packages.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog" target="_blank" rel="noopener">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui" target="_blank" rel="noopener">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本月到目前为止，我们已经研究了许多执行构建并运行一些测试的方案。这些都是很棒的工作流程──它们确保进入你的项目的pull request是高质量的，并且你的主分支是健康的。&lt;/p&gt;
&lt;p&gt;但是，你通常想采取下一步并部署自己构建的内容。例如，你可能想构建一个容器，并在每次新的主分支合入新功能时将其上传到&lt;a href=&quot;https://github.com/features/packages&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub Packages&lt;/a&gt;。这将确保你有一个可以运行并验证每个更改的容器。&lt;/p&gt;
&lt;p&gt;为此，我们要触发向master的推送。（无论是从 &lt;code&gt;git push&lt;/code&gt; 还是从合并pull request，只要&lt;a href=&quot;https://www.edwardthomson.com/blog/github_actions_1_cicd_triggers.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;集成到master&lt;/a&gt;中，&lt;code&gt;push&lt;/code&gt; 触发器都将运行。）&lt;/p&gt;
&lt;p&gt;然后，我们将从docker登录到GitHub Packages。我们可以简单地使用GitHub Actions提供给我们的 &lt;code&gt;GITHUB_TOKEN&lt;/code&gt;──令牌对我们存储库中的软件包具有发布权限。&lt;/p&gt;
    
    </summary>
    
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第8天：处理过时的 issue</title>
    <link href="https://qiwihui.com/qiwihui-blog-91/"/>
    <id>https://qiwihui.com/qiwihui-blog-91/</id>
    <published>2020-03-22T21:36:00.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>存储库中存在过时的issue可能是一个很大的危害。如果你有数年不打算解决的issue，那么就很难找到要关注的重要问题。你永远不会合并的pull request使你看起来好像在忽略该项目。项目中的所有这些杂项都增加了无形的认知负担。</p><a id="more"></a><p>在服务行业工作的任何人都会理解此问题。这就像一个厨师的 <em>场面调度连接</em> 的地方──在他们与他们的配料厨房的设置。</p><blockquote><p>如果让你的现场发生故障，变脏和混乱，你会很快发现自己旋转到位并需要备份。我和一位厨师一起工作，他曾经在匆忙中走到排队的肮脏厨师的工作台旁，解释为什么违规的厨师落后了。他将手掌压在切菜板上，切菜板上撒满了胡椒粒，飞溅的酱汁，一些香菜，面包屑以及通常会漂浮在工作台上的漂浮物和抛弃物，如果不时常用潮湿的侧毛巾将其擦掉。“你看到了吗？” 他打了个招呼，抬起他的手掌，这样厨师就可以看到灰尘和碎屑粘在厨师的手掌上。“那就是你现在的脑袋。”</p><p>Anthony Bourdain，厨房机密</p></blockquote><p>当GitHub着手创建Actions平台时，他们希望构建一些对CI/CD工作流程非常有用的东西──构建项目，运行测试并部署它──但这也可以帮助你自动化项目中的常见任务。在这种情况下，请保持存储库的美观和整洁。</p><p><a href="https://qiwihui.com/qiwihui-blog-90/">启动程序工作流程</a>的底部是关闭陈旧issue和 pull request 的工作流程。</p><p><img src="https://user-images.githubusercontent.com/3297411/77284675-3258c380-6d0a-11ea-9be3-0b06abf407f8.png" alt="image"></p><p>它会按计划触发运行，因此在每天UTC午夜：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">schedule:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">cron:</span> <span class="string">"0 0 * * *"</span></span><br></pre></td></tr></table></figure><p>当它运行时，它将运行<a href="https://github.com/actions/stale" target="_blank" rel="noopener">过时的操作</a>，该操作将查看存储库中的issue和pull request，并找到几个月没有执行任何操作的请求。然后它将在问题中发布一条消息，并添加一个标签，指示该问题是过时的。如果该问题再保持一周的陈旧状态，则将其关闭。</p><p><img src="https://user-images.githubusercontent.com/3297411/77284876-b6ab4680-6d0a-11ea-99cf-dd4aa447a612.png" alt="image"></p><p>这样可以确保识别出每一个过时的issue，但同时也给人们足够的时间告诉过时的操作以使issue或pull request保持打开状态──许多这些旧issue和PR毕竟具有价值！</p><p>最终，处理过时issue的的工作流程是减少存储库中某些干扰并允许你“工作干净”的简便方法。</p><p>原文链接：<a href="https://www.edwardthomson.com/blog/github_actions_8_stale_issues_and_pull_requests.html" target="_blank" rel="noopener">https://www.edwardthomson.com/blog/github_actions_8_stale_issues_and_pull_requests.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog" target="_blank" rel="noopener">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui" target="_blank" rel="noopener">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;存储库中存在过时的issue可能是一个很大的危害。如果你有数年不打算解决的issue，那么就很难找到要关注的重要问题。你永远不会合并的pull request使你看起来好像在忽略该项目。项目中的所有这些杂项都增加了无形的认知负担。&lt;/p&gt;
    
    </summary>
    
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第7天：入门工作流程</title>
    <link href="https://qiwihui.com/qiwihui-blog-90/"/>
    <id>https://qiwihui.com/qiwihui-blog-90/</id>
    <published>2020-03-21T18:20:42.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>如果你仅创建了一个或两个GitHub Actions工作流，则可能对如何起步不太关注，但是GitHub Actions团队关注如何起步，他们努力工作，以使你能尽可能轻松地开始使用Actions。</p><p>在创建新工作流程时，GitHub首先要考虑的是存储库中的代码类型。GitHub Actions使用成熟的<a href="https://github.com/github/linguist" target="_blank" rel="noopener">语言工具</a>来了解你的存储库包含哪种代码。这是为GitHub许多其他部分提供支持的工具，其中包括存储库主页上的语言统计栏。</p><a id="more"></a><p><img src="https://user-images.githubusercontent.com/3297411/77240850-d0269280-6c25-11ea-8b6b-759de7111087.png" alt="image"></p><p>对于这个拥有大量JavaScript的存储库，GitHub Actions将选择两个可能的工作流程──运行 <code>npm run build</code> 和 <code>npm test</code> 的Node.js CI/CD工作流程（这对应用程序有用），以及执行相同构建和测试运行的打包工作流程，然后将程序包发布到GitHub Packages中。</p><p><img src="https://user-images.githubusercontent.com/3297411/77240893-3ad7ce00-6c26-11ea-8335-ce18b0802ca4.png" alt="image"></p><p>GitHub Actions不仅具有构建和测试项目的能力，还有工作流可以帮助你开始将应用程序部署到云中，无论是AWS，Azure还是Google Cloud。</p><p><img src="https://user-images.githubusercontent.com/3297411/77240898-504cf800-6c26-11ea-82b1-20faf590faf6.png" alt="image"></p><p>而且，当然，尽管和语言学家一样好，它也不是完美的。许多人在同一存储库中混合了不同的项目，因此你还可以扩展整个启动程序工作流列表。</p><p><img src="https://user-images.githubusercontent.com/3297411/77240908-75da0180-6c26-11ea-9612-42b3c634aeb6.png" alt="image"></p><p>如果你想帮助改善入门工作流程──无论是对现有工作流程进行更改，还是添加全新的语言，都可以在<a href="https://github.com/actions/starter-workflows" target="_blank" rel="noopener">GitHub上</a>进行提交。</p><p>原文链接：<a href="https://www.edwardthomson.com/blog/github_actions_7_starter_workflows.html" target="_blank" rel="noopener">https://www.edwardthomson.com/blog/github_actions_7_starter_workflows.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog" target="_blank" rel="noopener">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui" target="_blank" rel="noopener">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你仅创建了一个或两个GitHub Actions工作流，则可能对如何起步不太关注，但是GitHub Actions团队关注如何起步，他们努力工作，以使你能尽可能轻松地开始使用Actions。&lt;/p&gt;
&lt;p&gt;在创建新工作流程时，GitHub首先要考虑的是存储库中的代码类型。GitHub Actions使用成熟的&lt;a href=&quot;https://github.com/github/linguist&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;语言工具&lt;/a&gt;来了解你的存储库包含哪种代码。这是为GitHub许多其他部分提供支持的工具，其中包括存储库主页上的语言统计栏。&lt;/p&gt;
    
    </summary>
    
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第6天：快速失败的矩阵工作流</title>
    <link href="https://qiwihui.com/qiwihui-blog-89/"/>
    <id>https://qiwihui.com/qiwihui-blog-89/</id>
    <published>2020-03-20T18:34:16.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>因此，关于 GitHub Actions 的这些帖子甚至还不到一周，我已经写了很多有关 <a href="https://qiwihui.com/qiwihui-blog-85/">矩阵工作流</a> 的文章。如你还没猜到，我是忠实粉丝。 😍</p><p>但是，如果你开始设置第一个矩阵工作流程，那么你需要注意：默认情况下，矩阵工作流程会<a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idstrategyfail-fast" target="_blank" rel="noopener">快速失败</a>。这就是说：如果矩阵扩展中的一个作业失败，则其余作业将被取消。</p><p>这种行为通常非常有益：如果你正在运行 pull request 验证构建，而矩阵中的构建之一失败，则你可能根本不在乎其余的构建是否成功。任何失败都足以表明存在使你无法合并 PR 的问题。</p><a id="more"></a><p>但是，当你从头开始创建工作流时，可能需要迭代一下才能使其第一次正常工作。当作业失败是由于工作流设置中存在问题而不是代码本身存在问题时，关闭快速故障行为作为调试工具会很有帮助。</p><p>假设你有一个在 Linux 上运行良好的工作流程，并且希望使用矩阵将其扩展到可以在 macOS 和 Windows 上运行。对于简单的工作流程，这可能会正常工作。但是对于更复杂的事情，你可能需要先设置一些依赖项或安装一些工具，然后才能起作用。因此，很可能你的Linux上运行的工作流如果不做一些修改就无法在 macOS 或 Windows 上运行。</p><p>那么，当你第一次运行此新矩阵工作流时会发生什么？你的 Linux，macOS 和 Windows 作业将全部启动，并且 macOS 作业或 Windows 作业将失败，其余工作流程将被取消。</p><p>想象一下，首先失败的是 Windows 作业。你会看到的：</p><p><img src="https://user-images.githubusercontent.com/3297411/77217607-b9693880-6b5e-11ea-91df-11d70a9388f1.png" alt="image"></p><p>好的，因此你决定需要修复 Windows 工作流程。 因此，你可以查看出了什么问题，更新工作流程，然后推送更改以将新构建放入队列。 但是，由于排队和调度不是很确定，因此也许这次 macOS 构建首先完成──失败。 现在，你的 Windows 运行被取消，甚至无法找出它是否有效：</p><p><img src="https://user-images.githubusercontent.com/3297411/77217652-0220f180-6b5f-11ea-99bb-0bcf357f6db1.png" alt="image"></p><p>现在，在调试工作流时，可以通过设置 <code>fail-fast: false</code> 来关闭此行为：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">strategy:</span></span><br><span class="line">  <span class="attr">matrix:</span></span><br><span class="line">    <span class="attr">os:</span> <span class="string">[ubuntu-latest,</span> <span class="string">macos-latest,</span> <span class="string">windows-latest]</span></span><br><span class="line">  <span class="attr">fail-fast:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>现在，工作流不会在第一个失败的作业时被取消。它将允许 Windows 和 macOS 作业运行完成。</p><p><img src="https://user-images.githubusercontent.com/3297411/77217688-48765080-6b5f-11ea-9fad-063aecf682f5.png" alt="image"></p><p>关闭 <code>fail-fast</code> 将帮助你更轻松地迭代工作流程。准备好在生产中运行时，请务必将其重新打开！这将帮助你节省CI运行时间（和金钱）。</p><p>原文链接：<a href="https://www.edwardthomson.com/blog/github_actions_6_fail_fast_matrix_workflows.html" target="_blank" rel="noopener">https://www.edwardthomson.com/blog/github_actions_6_fail_fast_matrix_workflows.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog" target="_blank" rel="noopener">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui" target="_blank" rel="noopener">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因此，关于 GitHub Actions 的这些帖子甚至还不到一周，我已经写了很多有关 &lt;a href=&quot;https://qiwihui.com/qiwihui-blog-85/&quot;&gt;矩阵工作流&lt;/a&gt; 的文章。如你还没猜到，我是忠实粉丝。 😍&lt;/p&gt;
&lt;p&gt;但是，如果你开始设置第一个矩阵工作流程，那么你需要注意：默认情况下，矩阵工作流程会&lt;a href=&quot;https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idstrategyfail-fast&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;快速失败&lt;/a&gt;。这就是说：如果矩阵扩展中的一个作业失败，则其余作业将被取消。&lt;/p&gt;
&lt;p&gt;这种行为通常非常有益：如果你正在运行 pull request 验证构建，而矩阵中的构建之一失败，则你可能根本不在乎其余的构建是否成功。任何失败都足以表明存在使你无法合并 PR 的问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第5天：在容器中构建</title>
    <link href="https://qiwihui.com/qiwihui-blog-88/"/>
    <id>https://qiwihui.com/qiwihui-blog-88/</id>
    <published>2020-03-20T18:16:30.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>昨天我讨论了如何 <a href="https://qiwihui.com/qiwihui-blog-87/">在GitHub Actions虚拟环境上安装工具和依赖项</a>。 但是，如果你需要更多控制权怎么办？ 或者，如果你根本不想在 Ubuntu 上运行，该怎么办？ 这是容器发光的地方。</p><p>通过创建一个包含所有需要的开发工具以及项目依赖项的容器，你不必操心在工作流运行开始时就对那些设置和安装步骤进行管理。</p><p>此外，你还将获得基于容器的开发的优势：你可以在用于CI构建的同一个容器中进行本地构建，因此你可以高度自信地确保 GitHub Actions 中的构建与构建时所看到的与本地匹配。</p><p>语法非常简单明了──我不需要自己运行任何 <code>docker pull</code> 或 <code>docker run</code> 命令。 GitHub Actions 为我解决了这个问题。要获取源代码并在 <code>node：current</code> 容器中运行测试，请执行以下操作：</p><a id="more"></a><script src="https://gist.github.com/ethomson/d56f1804295ee1a4779a0d013ec4572b.js"></script><p>当我运行此工作流时，GitHub Actions 将从 DockerHub 下载我指定的容器，启动它，然后直接在该容器中执行我指定的运行步骤。</p><blockquote><p>请注意，在容器内运行时，仍然需要指定运行对象。这是因为 Linux 和 Windows 都支持容器──因此，如果你要运行基于 Linux 的容器，则需要 <code>runs-on: ubuntu-latest</code>。 如果要使用基于Windows的容器，请确保设置 <code>runs-on: windows-latest</code>。</p></blockquote><p>容器还可以帮助扩展构建矩阵：如果要跨多个 Linux 发行版构建和测试工具，则甚至可以在矩阵中设置容器作业。（因为 <a href="https://www.edwardthomson.com/blog/github_actions_2_matrixes.html" target="_blank" rel="noopener">矩阵工作流实际上只是可变的替代</a>。）</p><p>例如，要在 Debian，Ubuntu 和 CentOS 的旧版和最新版本上构建：</p><script src="https://gist.github.com/ethomson/46a2db40d5c1d320fcc79886320f375e.js"></script><p>因此，无论你是要直接在我们提供的虚拟环境中还是在你指定的容器中构建，你都可以灵活地选择工作流的运行位置。</p><p>原文链接：<a href="https://www.edwardthomson.com/blog/github_actions_5_building_in_containers.html" target="_blank" rel="noopener">https://www.edwardthomson.com/blog/github_actions_5_building_in_containers.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog" target="_blank" rel="noopener">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui" target="_blank" rel="noopener">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天我讨论了如何 &lt;a href=&quot;https://qiwihui.com/qiwihui-blog-87/&quot;&gt;在GitHub Actions虚拟环境上安装工具和依赖项&lt;/a&gt;。 但是，如果你需要更多控制权怎么办？ 或者，如果你根本不想在 Ubuntu 上运行，该怎么办？ 这是容器发光的地方。&lt;/p&gt;
&lt;p&gt;通过创建一个包含所有需要的开发工具以及项目依赖项的容器，你不必操心在工作流运行开始时就对那些设置和安装步骤进行管理。&lt;/p&gt;
&lt;p&gt;此外，你还将获得基于容器的开发的优势：你可以在用于CI构建的同一个容器中进行本地构建，因此你可以高度自信地确保 GitHub Actions 中的构建与构建时所看到的与本地匹配。&lt;/p&gt;
&lt;p&gt;语法非常简单明了──我不需要自己运行任何 &lt;code&gt;docker pull&lt;/code&gt; 或 &lt;code&gt;docker run&lt;/code&gt; 命令。 GitHub Actions 为我解决了这个问题。要获取源代码并在 &lt;code&gt;node：current&lt;/code&gt; 容器中运行测试，请执行以下操作：&lt;/p&gt;
    
    </summary>
    
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第4天：安装工具</title>
    <link href="https://qiwihui.com/qiwihui-blog-87/"/>
    <id>https://qiwihui.com/qiwihui-blog-87/</id>
    <published>2020-03-20T07:01:05.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>昨天我提到 GitHub Actions 提供了 <a href="https://qiwihui.com/qiwihui-blog-86/">Linux，Windows 和 macOS 虚拟环境</a>，你可以在其中运行工作流。</p><p>但是这些环境上实际安装了什么？ 原来有<a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/software-installed-on-github-hosted-runners" target="_blank" rel="noopener">很多安装</a>。</p><p>团队试图通过许多不同的平台使我们的运行器（runners）保持最新状态。 因此，你会发现许多不同版本的Python，Ruby，.NET Core等。 但是──仅仅依靠这些各种各样的开发工具──他们不可能绝对安装所有东西。</p><p>有时你需要自己安装。而且由于你拥有一台完整的虚拟机，因此对于每项作业执行，你都可以在其上安装任何所需的软件。</p><a id="more"></a><p>例如，你可能要安装非常好的“<a href="https://ninja-build.org/" target="_blank" rel="noopener">ninja</a>”构建工具。</p><h3>Linux</h3><p>Linux虚拟环境运行Ubuntu，因此你可以使用 <a href="https://en.wikipedia.org/wiki/APT_(Package_Manager)" target="_blank" rel="noopener">apt</a> 安装可能需要的任何其他工具。 默认情况下，你以非 root 用户身份运行，但是可以使用无密码 sudo。这样你就可以：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">run:</span> <span class="string">sudo</span> <span class="string">apt-get</span> <span class="string">install</span> <span class="string">ninja-build</span></span><br></pre></td></tr></table></figure><h3>Windows</h3><p><a href="https://chocolatey.org/" target="_blank" rel="noopener">Chocolatey</a> 是 Windows 的首选软件包管理器，它已安装并可以在 GitHub Actions 虚拟环境中使用。</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">run:</span> <span class="string">choco</span> <span class="string">install</span> <span class="string">ninja</span></span><br></pre></td></tr></table></figure><h3>macOS</h3><p>在 macOS 上，<a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a> 是推荐的软件包管理器，可在 GitHub Actions 虚拟环境中使用。无需以 root 用户身份运行 Homebrew ──实际上，这是不合时宜的，因此您可以执行 <code>brew install</code>：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">run:</span> <span class="string">brew</span> <span class="string">install</span> <span class="string">ninja</span></span><br></pre></td></tr></table></figure><h3>合在一起</h3><p>综上所述，如果你想在所有三个平台上安装 ninja，你的工作流程将<a href="https://gist.github.com/ethomson/68a7e60b9b5fbe081c8edd65237a2f22" target="_blank" rel="noopener">如下所示</a>：</p><script src="https://gist.github.com/ethomson/68a7e60b9b5fbe081c8edd65237a2f22.js"></script><p>原文链接：<a href="https://www.edwardthomson.com/blog/github_actions_4_installing_tools.html" target="_blank" rel="noopener">https://www.edwardthomson.com/blog/github_actions_4_installing_tools.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog" target="_blank" rel="noopener">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui" target="_blank" rel="noopener">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天我提到 GitHub Actions 提供了 &lt;a href=&quot;https://qiwihui.com/qiwihui-blog-86/&quot;&gt;Linux，Windows 和 macOS 虚拟环境&lt;/a&gt;，你可以在其中运行工作流。&lt;/p&gt;
&lt;p&gt;但是这些环境上实际安装了什么？ 原来有&lt;a href=&quot;https://help.github.com/en/actions/automating-your-workflow-with-github-actions/software-installed-on-github-hosted-runners&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;很多安装&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;团队试图通过许多不同的平台使我们的运行器（runners）保持最新状态。 因此，你会发现许多不同版本的Python，Ruby，.NET Core等。 但是──仅仅依靠这些各种各样的开发工具──他们不可能绝对安装所有东西。&lt;/p&gt;
&lt;p&gt;有时你需要自己安装。而且由于你拥有一台完整的虚拟机，因此对于每项作业执行，你都可以在其上安装任何所需的软件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第3天：跨平台构建</title>
    <link href="https://qiwihui.com/qiwihui-blog-86/"/>
    <id>https://qiwihui.com/qiwihui-blog-86/</id>
    <published>2020-03-20T06:07:21.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>GitHub Actions 的优点之一是它不仅支持在 Linux 主机上或在容器中运行构建。GitHub 当然提供了Linux虚拟机，但是它们也提供了<a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/virtual-environments-for-github-hosted-runners" target="_blank" rel="noopener">运行 Windows 和 macOS</a> 的虚拟机。</p><p>macOS 虚拟环境尤其重要，因为即使作为开发人员，也不能在虚拟机上运行 macOS，除非你在 Apple 硬件上运行它。因此，如果你要构建跨平台应用程序，则可能会限制你在本地构建和测试自己的应用程序的方式。</p><a id="more"></a><p>要指定主机类型，请使用作业的 <code>runs-on</code> 参数进行指示。 例如，<code>runs-on: macos-latest</code> 将在 macOS 上运行，<code>runs-on: windows-latest</code> 将毫不奇怪在 Windows 上运行。 因此，如果要通过在 Linux，macOS 和 Windows 三个平台上运行 <code>make</code> 来构建应用程序：，则可以将每个平台指定为一个单独的作业。 这是一个<a href="https://gist.github.com/ethomson/54e3832bcb391edb752169b370716854" target="_blank" rel="noopener">例子</a>：</p><script src="https://gist.github.com/ethomson/54e3832bcb391edb752169b370716854.js"></script><p>但这重复了很多……如果你阅读了昨天有关 <a href="https://qiwihui.com/qiwihui-blog-85/">矩阵工作流</a> 的文章，你可能还记得我说过矩阵扩展实际上只是简单的变量替换。好吧，即使在运行参数中也是如此。</p><p>这意味着你可以使用矩阵来建立跨平台构建，其中只需几行<a href="https://gist.github.com/ethomson/ee209ef3bad14996d43d0ccf22563bd1" target="_blank" rel="noopener">工作流定义</a>即可：</p><script src="https://gist.github.com/ethomson/ee209ef3bad14996d43d0ccf22563bd1.js"></script><p>因此，你可以选择：可以使用要在其上运行的虚拟环境指定每个单独的作业，或者，如果有共同的步骤，则可以使用矩阵来运行。</p><p>原文链接：<a href="https://www.edwardthomson.com/blog/github_actions_3_crossplatform_builds.html" target="_blank" rel="noopener">https://www.edwardthomson.com/blog/github_actions_3_crossplatform_builds.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog" target="_blank" rel="noopener">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui" target="_blank" rel="noopener">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GitHub Actions 的优点之一是它不仅支持在 Linux 主机上或在容器中运行构建。GitHub 当然提供了Linux虚拟机，但是它们也提供了&lt;a href=&quot;https://help.github.com/en/actions/automating-your-workflow-with-github-actions/virtual-environments-for-github-hosted-runners&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;运行 Windows 和 macOS&lt;/a&gt; 的虚拟机。&lt;/p&gt;
&lt;p&gt;macOS 虚拟环境尤其重要，因为即使作为开发人员，也不能在虚拟机上运行 macOS，除非你在 Apple 硬件上运行它。因此，如果你要构建跨平台应用程序，则可能会限制你在本地构建和测试自己的应用程序的方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第2天：矩阵工作流</title>
    <link href="https://qiwihui.com/qiwihui-blog-85/"/>
    <id>https://qiwihui.com/qiwihui-blog-85/</id>
    <published>2020-03-20T05:47:32.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>拥有 CI/CD 系统的最大优势之一是，它使你可以高效地构建和测试多种配置。在推送之前，你在机器上进行构建和测试当然是必要的，但这几乎是不够的。毕竟，你可能只安装了一个版本的节点。但是，在各种平台上构建将使你充满信心和洞察力，使你的更改可以在你支持的整个生态系统中发挥作用。</p><a id="more"></a><p><a href="https://www.jwz.org/blog/2011/08/weaponized-tinderbox/" target="_blank" rel="noopener">Mozilla Tinderbox</a> 是最早引入跨多个配置构建概念的 CI 系统之一。这是革命性的──当我使用 <a href="https://www.abisource.com/" target="_blank" rel="noopener">AbiWord</a> 时，我负责了 Tinderbox 的设置。我们有一个充满机器的实验室，以便我们可以测试 Motif 构建和 GTK 构建，并可以针对不同的依赖项进行测试（这是在从可怕的 libc5 到 libc6 迁移的时候），甚至是不同的 C ++ 编译器。</p><p>那时，我的工作很大一部分是维护这个装有昂贵计算机的实验室。因此，我最喜欢的 GitHub Actions 特性之一就是矩阵工作流功能也就不足为奇了，它使我能够快速运行多个构建以支持各种配置。</p><p>我仍然在编写代码，因此仍然需要使用不同的编译器和不同的依赖项进行构建。但是现在我不需要一个充满机器的实验室，我只需要在 GitHub Actions 中使用矩阵工作流设置即可。</p><p>矩阵工作流一开始可能看起来有些让人不知所措，但这实际上只是简单的变量替换。您定义了一组变量，以及应分配给每个变量的一组值。然后，GitHub Actions 将使用这些变量的所有不同扩展来执行工作流。</p><p>假设你要测试三个不同的变量，这很快变得非常强大。就我而言，我想用两个不同的 C 编译器（gcc和clang），三个不同的 SSL 后端（OpenSSL，GnuTLS和NSS）以及两个不同的 Kerberos 后端（MIT和Heimdal）进行测试。要测试所有这些不同的组合，那就是2 * 3 * 2 = 12种不同的配置。</p><p>但是，我不必定义十二个不同的工作（或更糟的是，必须像在糟糕的过去那样在实验室中设置十二个不同的机器），我只需指定一个包含三个变量的矩阵即可。如果在作业中指定矩阵，则实际上将获得十二个以不同排列运行的作业：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">matrix:</span></span><br><span class="line">  <span class="attr">cc:</span> <span class="string">[gcc,</span> <span class="string">clang]</span></span><br><span class="line">  <span class="attr">curl:</span> <span class="string">[openssl,</span> <span class="string">gnutls,</span> <span class="string">nss]</span></span><br><span class="line">  <span class="attr">kerberos:</span> <span class="string">[libkrb5,</span> <span class="string">heimdal]</span></span><br></pre></td></tr></table></figure><p>现在在我的工作中，我可以使用<a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/contexts-and-expression-syntax-for-github-actions" target="_blank" rel="noopener">矩阵上下文</a>引用这些变量中的每一个。例如，<code>$</code> 将扩展为 cc 变量的当前值。</p><p>以下是一个示例工作流，该工作流安装每个依赖项，并运行我的 autoconf 设置，然后运行 make：</p><script src="https://gist.github.com/ethomson/5570201b04670fb90c1b0450db19e01a.js"></script><p>当你运行此工作流程时，你可以快速查看它如何扩展到12个不同的作业。在工作流运行的左侧，你可以看到它们中的每一个。 这样，简单的工作流程就可以迅速扩展。</p><p>在其中一个运行中打开步骤时，你可以看到确实我们能够安装依赖项。 如果打开 <code>build (clang, openssl, libkrb5)</code> 任务，实际上正在运行 <code>clang</code>（由 <code>${CC} --version</code> 显示），libcurl的OpenSSL版本（由 <code>curl-config</code> 显示）和 MIT krb5（由 <code>krb5-config</code> 显示）。</p><p><img src="https://user-images.githubusercontent.com/3297411/77169169-07952200-6af4-11ea-8770-f381ddfaa7eb.png" alt="image"></p><p>因此，你可以看到，你只需使用工作流中的几行矩阵定义就可以构建具有多种配置的强大工作流。</p><p>原文链接：<a href="https://www.edwardthomson.com/blog/github_actions_2_matrixes.html" target="_blank" rel="noopener">https://www.edwardthomson.com/blog/github_actions_2_matrixes.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog" target="_blank" rel="noopener">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui" target="_blank" rel="noopener">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;拥有 CI/CD 系统的最大优势之一是，它使你可以高效地构建和测试多种配置。在推送之前，你在机器上进行构建和测试当然是必要的，但这几乎是不够的。毕竟，你可能只安装了一个版本的节点。但是，在各种平台上构建将使你充满信心和洞察力，使你的更改可以在你支持的整个生态系统中发挥作用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第1天：CI/CD 触发器</title>
    <link href="https://qiwihui.com/qiwihui-blog-84/"/>
    <id>https://qiwihui.com/qiwihui-blog-84/</id>
    <published>2020-03-20T02:52:25.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>GitHub Actions是一个独立的系统：它提供了 CI/CD 构建功能──能够构建和测试 Pull Request 并合并到你的master分支中──但它不只限于构建系统。 它已经集成到GitHub中，并且 <a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows" target="_blank" rel="noopener">只要你的项目库中发生任何事件</a>（例如正在创建发行版或正在评论问题），都可以触发并运行工作流。</p><p>我将在这个月更多地讨论那些项目库自动化方案，但是你要知道，这种灵活性将有助于理解如何进行 CI/CD 构建设置。 GitHub Actions 允许你定义一个 <em>触发器</em> 来控制工作流程的运行时间。每当你的项目库中发生与该触发器匹配的操作时，工作流运行都会进入排队队列中准备。</p><a id="more"></a><p>对于 CI/CD 工作流，我喜欢使用 <a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows#push-event-push" target="_blank" rel="noopener">push</a> 和 <a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows#pull-request-event-pull_request" target="_blank" rel="noopener">pull_request</a> 触发器，并将其范围限定在我感兴趣的分支上。例如：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>这个触发器将在对master分支进行任何更改时运行你的工作流──（即使它的名字是 <code>push</code> 触发器，也将在你运行 <code>git push</code> 或将 pull request 合并到 master 分支时运行）。对于针对master分支打开的任何 pull request，工作流也将运行，并且将在 pull request 中向你显示验证。</p><p><img src="https://user-images.githubusercontent.com/3297411/77157504-749cbd80-6adc-11ea-8fd5-17d745208029.png" alt="image"></p><p>如果你熟悉YAML语法，就可能会注意到分支采用数组。 因此，你可以轻松地设置工作流在多个分支中运行，这在你维护单独的发布轨道追踪时非常有用。 例如：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">'releases/**'</span></span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">'releases/**'</span></span><br></pre></td></tr></table></figure><p>每当对 <code>master</code> 分支或名称 <a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#onpushpull_requestbranchestags" target="_blank" rel="noopener">以 <code>releases/</code> 开头的分支</a> 打开 pull request 时，将运行你的工作流。</p><p>通过 <code>push</code> 和 <code>pull_request</code> 触发器，可以轻松设置 CI/CD 样式的工作流程来验证 pull request，并使用 GitHub Actions 合并到你的 master 分支中。</p><p>原文链接：<a href="https://www.edwardthomson.com/blog/github_actions_1_cicd_triggers.html" target="_blank" rel="noopener">https://www.edwardthomson.com/blog/github_actions_1_cicd_triggers.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog" target="_blank" rel="noopener">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui" target="_blank" rel="noopener">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GitHub Actions是一个独立的系统：它提供了 CI/CD 构建功能──能够构建和测试 Pull Request 并合并到你的master分支中──但它不只限于构建系统。 它已经集成到GitHub中，并且 &lt;a href=&quot;https://help.github.com/en/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;只要你的项目库中发生任何事件&lt;/a&gt;（例如正在创建发行版或正在评论问题），都可以触发并运行工作流。&lt;/p&gt;
&lt;p&gt;我将在这个月更多地讨论那些项目库自动化方案，但是你要知道，这种灵活性将有助于理解如何进行 CI/CD 构建设置。 GitHub Actions 允许你定义一个 &lt;em&gt;触发器&lt;/em&gt; 来控制工作流程的运行时间。每当你的项目库中发生与该触发器匹配的操作时，工作流运行都会进入排队队列中准备。&lt;/p&gt;
    
    </summary>
    
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions Advent Calendar 系列文章 - Index</title>
    <link href="https://qiwihui.com/qiwihui-blog-83/"/>
    <id>https://qiwihui.com/qiwihui-blog-83/</id>
    <published>2020-03-20T02:42:05.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>最近我在做项目 <a href="https://codedays.app" target="_blank" rel="noopener">codedays.app</a> 过程中，发现 Github 推出的 Github Actions 可以很方便地用来做CI/CD之类的工作，所以决定将 <a href="https://www.edwardthomson.com/blog/github_actions_advent_calendar.html" target="_blank" rel="noopener">GitHub Actions Advent Calendar</a> 这个系列的文章做个简单的翻译和整理。这篇文章是所有文章的索引。</p><p>每天一个tips：</p><ul><li>[x] 第1天: CI/CD Triggers</li><li>[x] 第2天: Matrix Workflows</li><li>[x] 第3天: Cross-Platform Builds</li><li>[ ] 第4天: Installing Tools</li><li>[ ] 第5天: Building in Containers</li><li>[ ] 第6天: Fail-Fast Matrix Workflows</li><li>[ ] 第7天: Starter Workflows</li><li>[ ] 第8天: Dealing with Stale Issues</li><li>[ ] 第9天: Deploy to GitHub Packages</li><li>[ ] 第10天: Path Triggers</li><li>[ ] 第11天: Secrets</li><li>[ ] 第12天: Information about your Workflow</li><li>[ ] 第13天: Conditionals</li><li>[ ] 第14天: Conditionals with a Matrix</li><li>[ ] 第15天: Sharing Data Between Steps</li><li>[ ] 第16天: Conditionals with Shared Data</li><li>[ ] 第17天: Dependent Jobs</li><li>[ ] 第18天: Artifacts</li><li>[ ] 第19天: Downloading Artifacts</li><li>[ ] 第20天: Container Services</li><li>[ ] 第21天: GitHub Script</li><li>[ ] 第22天: Automerge Security Updates</li><li>[ ] 第23天: Upload Release Builds</li><li>[ ] 第24天: Caching Dependencies</li><li>[ ] 第25天: Sparkle a Christmas Tree</li><li>[ ] 第26天: Self-Hosted Runners</li><li>[ ] 第27天: Deploy to Cloud</li><li>[ ] 第28天: Repository Automation</li><li>[ ] 第29天: Creating an Action</li><li>[ ] 第30天: Integrating Other APIs in an Action</li><li>[ ] 第31天: Adding an Action to the Marketplace</li></ul><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog" target="_blank" rel="noopener">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui" target="_blank" rel="noopener">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近我在做项目 &lt;a href=&quot;https://codedays.app&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;codedays.app&lt;/a&gt; 过程中，发现 Github 推出的 Github Actions 可以很方便地用来做CI/CD之类的
      
    
    </summary>
    
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>学习Django──我犯的初学者错误以及如何避免</title>
    <link href="https://qiwihui.com/qiwihui-blog-81/"/>
    <id>https://qiwihui.com/qiwihui-blog-81/</id>
    <published>2020-01-19T23:04:20.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章是 reddit 上用户 <a href="https://www.reddit.com/user/unknownguy0518/" target="_blank" rel="noopener">unknownguy0518</a> 发表的他在学习Django是所犯的初学者错误，以及他的一些建议。更多具体的内容可以前往对应的 <a href="https://www.reddit.com/r/django/comments/eld87j/learning_django_beginner_mistakes_i_made_that_you/" target="_blank" rel="noopener">话题</a> 查看。</p></blockquote><p>我是 Django Web 框架的新手。我也不是专业的程序员。我没有任何人的帮助，我学到的一切都是通过反复试验而得出的。我犯了无数的错误，当我回首时，我现在笑了。在艰难学习了很多基础知识之后，我成功地创建了一个简单的网站来添加/更新/删除联系人。它已部署在 Heroku（免费服务器）中。我在这里写的内容纯属我个人观点。如果你是初学者，并且热衷于探索 Django 的世界，则应该阅读这篇文章。它可能会帮助你解决问题。</p><p>那些想浏览我的网站的人（仍然需要一些工作），它是：<a href="https://djangophonebook.herokuapp.com" target="_blank" rel="noopener">https://djangophonebook.herokuapp.com</a></p><a id="more"></a><p>以下是我在创建自己的网站的过程中面临的主要挑战：</p><h3>官方文档与教程</h3><p>很多具有 Django 经验或其他编码经验的人都会告诉你阅读官方文档，以了解有关这个出色 Web 框架的更多信息。实际是，并非所有人都喜欢这么高的技术细节。乍一看，任何指定这样的框架内部工作的文档都会吓到新手。毫无疑问，Django 文档是非常详细并且组织得很好，但是我建议你观看一些出色的视频教程，使我们对所有可用功能以及如何在实际项目中实现这些功能有所了解。我亲自浏览了 YouTube上 “<a href="https://www.youtube.com/user/schafer5" target="_blank" rel="noopener">Corey Schafer</a>” 的 Django 教程。这是我在互联网上找到的最好的教程之一。还有很多其他人，但我总是回头去看他的视频。我还发现 YouTube 上 “<a href="https://www.youtube.com/user/CodingEntrepreneurs" target="_blank" rel="noopener">CodingEntrepreneurs</a>” 的“<a href="https://www.youtube.com/playlist?list=PLEsfXFp6DpzTD1BD1aWNxS2Ep06vIkaeW" target="_blank" rel="noopener">尝试 Django</a>” 系列也是一个很好的教程。一旦有了方向感，官方文档就会变得更加有意义。</p><h3>Django 版本</h3><p>现在有很多针对 Django 1.x 版本的教程。尽管我们的项目很想使用相同的版本，但我强烈建议你使用 Django 的最新稳定版本（译者注：翻译时是2020年1月，最新版本为是 2.2.9）。它不仅消除了重写代码，而且还使我们能够使用旧版本可能没有的新功能。</p><h3>使用 Git 和 GitHub</h3><p>刚开始处理项目时，我忽略了使用 Git 维护版本控制。有一天，当我清除计算机中的一些旧文件夹时，我不小心删除了整个项目文件夹。这时我才意识到使用 Git 跟踪我在项目中所做的更改的重要性时。对于像我这样的新手来说，花了一段时间才弄清楚如何使用它（有时我仍在为它而苦苦挣扎），但它为我省去了很多麻烦。我还使用 GitHub 将所有代码转储为一个开源项目。你应该考虑使用 Git。如果你搞砸了并想恢复到项目的旧版本，它将对你有很大帮助。相信我，重新编写代码真的很令人沮丧。</p><h3>使用 <code>.gitignore</code> 文件</h3><p>如果使用的是 Git，请确保还使用 gitignore 文件。添加你不希望 Git 跟踪的所有文件或文件夹。有一个 GitHub 链接（<a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a>），我参考的是 Python.gitignore 文件，并将所有内容从该文件复制粘贴到我的 gitignore 文件中。尽管某些细节不一定特定于 Django，但我将一切保持不变。它涵盖了我的用例的所有内容。我强烈建议你以此为起点。之后，你可以根据需要修改文件。</p><h3>提升你的前端技能</h3><p>是的，你将需要它。你将需要至少了解 HTML 的基础，才能在 Django 中创建模板。了解一点 CSS 和 JavaScript 会更好。它可以帮助进一步自定义网站的外观。对于前端，我是一个完全的菜鸟。我知道只有足够的 HTML 可以创建一个准系统模板，而对 CSS 的了解则很少，甚至不考虑自定义我的网站。幸运的是，对于像我这样的人，Bootstrap 可以为我们提供现成的小组件，可以在我的网站上使用。它简化了我的许多前端要求。我的项目完全基于 HTML 和 Bootstrap 构建。</p><h3>使用虚拟环境</h3><p>为你的项目创建一个单独的虚拟环境是一个好习惯。当你准备部署项目时，这也将派上用场。我艰难地了解了它的重要性。现在，我会首先创建一个虚拟环境，安装所有必需的软件包，然后在我的项目上工作。</p><h3>使用单独的 <code>settings.py</code> 文件进行开发和生产</h3><p>我没有碰到太多的教程来解释为什么在开发和生产过程中使用单独的 <code>settings.py</code> 文件是个好主意。单独的文件可减少混乱，并使代码测试效率更高。当你要进行大型项目时，请记住这一点。尽管我从未实现过它，但许多专家推荐它。</p><h3>创建自定义用户模型</h3><p>大多数教程使用内置的用户模型来存储和处理与用户相关的数据。如果你想将电子邮件ID或手机号码用作登录ID，该怎么办？如果你希望在注册时从用户那里收集自己的某些字段，例如城市，省份，性别等，该怎么办？你可以通过创建自己的自定义用户模型来做到这一点。那时你应该考虑遍历 <code>AbstractUser</code> 和 <code>AbstractBaseUser</code> 类。我通常参考两个网站── <a href="https://simpleisbetterthancomplex.com/" target="_blank" rel="noopener">https://simpleisbetterthancomplex.com/</a> 和 <a href="https://wsvincent.com/" target="_blank" rel="noopener">https://wsvincent.com/</a> 来实现此目的。 YouTube 上的 CodingEntrepreneurs（<a href="https://www.youtube.com/watch?v=HshbjK1vDtY" target="_blank" rel="noopener">https://www.youtube.com/watch?v=HshbjK1vDtY</a>）在其视频之一中还介绍了创建自定义用户模型。我强烈建议你观看它，以了解其真正工作原理，而不仅仅是复制粘贴代码。</p><h3>使用社交登录</h3><p>当今大多数网站都提供了使用多种社交登录之一（例如，使用 Google 登录，使用 Facebook 登录等）登录或注册的选项。以我的个人经验，浏览我网站的大多数用户都使用了社交登录我提供的登录选项，而不是标准的注册过程。在将其付诸实践之前，在你的项目中实现它非常有意义。 “Django-Allauth” 库是一个非常好的开始，我曾经用它来实现 Google 登录。</p><h3>设计模型</h3><p>在部署项目之前，考虑一下要存储在数据库中的数据类型始终是一个好主意。哪些字段应该是必填字段，哪些字段可以是可选字段，在用户注册时要捕获的信息，所有这些都必须事先进行仔细考虑。网站上线后，对模型进行任何更改都会证明是一件非常昂贵的事情，因为我犯了这个错误。</p><h3>基于函数的视图（FBV）与基于类的视图（CBV）</h3><p>对于像我们这样的初学者来说，这始终是一个难题。根据我的经验，我发现基于通用类的视图非常容易编写，所用的代码行数少得多，并且使事情看起来更加整洁。这是我们真正可以看到所有魔术发生的地方，因为 Django 在后端为我们完成了所有繁重的工作。但是，我还发现，使用 CBV 实现任何自定义逻辑不是非常用户友好。我在互联网上也找不到太多有关如何使用和覆盖现有 CBV 方法的资料。这正是基于函数的视图蓬勃发展的地方。它们需要编写更多的代码行，解释起来可能会更复杂，但是当我们必须实现任何自定义逻辑时，它们就可能会显得很强大。了解 CBV 和 FBV 的工作原理确实有帮助。但是对于大多数用例来说，CBV 可以轻松完成工作。这是我创建视图时的首选路径。</p><h3>路由和 URL</h3><p>除了设计模型之外，在创建项目时规划所有路由也很有意义。清楚了解各种 URL 还可简化编写其相应视图的过程。很重要的一点是我们要确保各个应用程序之间的 URL 保持一致并准备进行 CRUD 操作。当编写 REST API 入口时，它也使事情变得更容易。</p><h3>在生产环境中处理静态文件和媒体文件</h3><p>很少有教程可以告诉你在尝试部署项目时将面临的一些挑战。我试图在 Heroku 上部署我的应用。当你设置 <code>DEBUG = False</code> 时，默认情况下 Django 不支持提供静态文件和媒体文件。对于静态文件，WhiteNoise 库为我完成了这项工作。它的文档也很简单。 Heroku 不存储媒体文件。我们必须使用其他服务，例如 Amazon 的 S3，并使用所有必需的参数相应地更新 <code>settings.py</code> 文件。 S3也可以用于提供静态文件，但主要缺点是它不是免费的。结果，我的网站当前无法加载用户选择的任何个人资料图片。我尚未找到替代方法。预先规划好你要如何提供媒体文件，并考虑到所涉及的成本。</p><h3>处理不同用户的权限</h3><p>这是要考虑的重要点。我面临的挑战之一是弄清楚如何为不同的用户授予或限制对特定 URL 的访问。例如，基于某些条件，用户 A 可能具有对 URL 的只读访问权限，而用户 B 可能具有对同一 URL 的写访问权限。你不希望一个用户访问另一个用户配置文件并对其进行更新。那是你需要确保为访问的 URL 授予适当权限的地方。<a href="https://www.youtube.com/user/schafer5" target="_blank" rel="noopener">Corey Schafer</a> 的教程对此进行了很好的介绍。</p><h3>创建自定义中间件</h3><p>涉及该主题的教程并不多。我还没有弄清楚如何创建自己的中间件。当我有更多信息时，我将更新此部分。</p><h3>改善网站的安全性</h3><p>我还没有看到太多的教程来解释 <code>python manage.py check -–deploy</code>，以及为什么它对确保我们在网站上线之前具有必要的安全性很重要。在启用网站之前，你应该探索一些东西。网站的安全性和用户数据的安全性必须受到重视。</p><h3>保护你的管理界面</h3><p>我喜欢 Django 的原因之一是因为它内置了许多安全功能。其中之一就是功能齐全的管理界面。用户访问管理页面后，他/她实际上就可以滥用数据。创建超级用户时，请确保不要使用诸如 <code>admin</code> 或 <code>manager</code> 之类的通用名称作为登录ID。另外，请确保使用很难猜到的非常强的密码。另外，将管理页面的路径更改为完全不同且难以确定的名称。避免使用默认的 <code>admin/</code> 路径。我还遇到了一个名为 <code>django-admin-honeypot</code> 的第三方库，该库通过创建类似管理员的页面来欺骗未经授权的用户，但没有执行其他任何操作。此外，它还在表中捕获了这些用户的详细信息，例如其 IP 地址和其他参数，这些表可以在实际的 Admin 界面中访问。然后，你可以决定是否要阻止他们访问你的网站或采取必要的措施。</p><h3>保护秘密密钥和其他关键数据</h3><p>使你的项目成为开放源代码的挑战之一就是要保护 <code>SECRET KEY</code> 和其他个人价值，例如你不希望世界其他地方看到的电子邮件ID和密码。我遵循 <a href="https://www.youtube.com/user/schafer5" target="_blank" rel="noopener">Corey Schafer</a> 在他的 YouTube 视频中提供的建议，并将所有这些重要值保存为环境变量。万一你有意或无意间发现你的秘密密钥，必须立即进行更改。你可以使用 python 自带的 <code>secrets</code> 模块（需要 Python 3.6+）来生成强密钥。同样，<a href="https://www.youtube.com/user/schafer5" target="_blank" rel="noopener">Corey Schafer</a> 的教程也涵盖了这一部分。</p><h3>打造响应式网站</h3><p>很少有教程着重介绍使桌面和移动设备友好的网站。最初创建网站时，它在PC上可以正常显示，但是当我尝试在移动设备上访问它时，我意识到必须重做一些模板。在创建模板时立即考虑到这一点，以后可以节省大量的工作量。我主要使用B ootstrap 作为前端，它着重于创建移动优先项目。</p><h3>编写测试</h3><p>每个应用程序都会创建一个 <code>tests.py</code> 文件。我仍然不知道如何编写测试。我观察到，GitHub上 可用于 Python 或 Django 的许多软件包或库确实进行了大量测试。同样，很少有教程解释如何编写测试。这是我仍在尝试解决的问题。当我有更多信息时，我将更新此部分。</p><h3>使用 REST API</h3><p>尽管 REST API 本身并不是一个单独的话题，但像我们这样的初学者应该知道，为什么对其进行计划很重要，如何创建 API 以及如何将其与 Angular 或 React 等其他前端集成。以我的经验，在设计视图时同时编写 REST API 确实可以使事情更高效，并且省去了尝试弄清楚权限和其他方面的麻烦。“ Django Rest Framework” 是 REST API 的首选库。我通常会创建一个单独的名为 “api” 的应用，并在此处编写所有其他应用的序列化器和视图。它将所有内容都放在一个地方。尽管我的项目有 API 入口，但我仍然必须创建一些 API。</p><h3>在部署之前设置 <code>DEBUG = False</code></h3><p>在部署期间保留 <code>DEBUG = True</code> 是常见错误，我也犯了。在启用网站之前，请不要忘记在 <code>settings.py</code> 文件中将 <code>DEBUG</code> 值设置为 <code>False</code>。你不希望最终用户在URL引发错误时看到所有异常和其他与编码有关的信息。 <a href="https://www.youtube.com/user/schafer5" target="_blank" rel="noopener">Corey Schafer</a> 很好地解释了如何在他的教程中进行处理。</p><h3>部署项目</h3><p>对于像我这样的初学者来说，这是另一个真正的麻烦。我应该在哪里部署我的项目（Heroku，PythonAnywhere，DigitalOcean，AWS等）？我应该做什么准备工作？我在生产中使用哪个数据库？我需要什么所有文件来开始部署（例如 requirements.txt，procfile 等）？我应该去免费服务器还是付费服务器？很多事情要考虑。我浏览了 <a href="https://www.youtube.com/user/schafer5" target="_blank" rel="noopener">Corey Schafer</a> 在 YouTube 上的视频，最终将其部署在免费的 Heroku 服务器上。</p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog" target="_blank" rel="noopener">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui" target="_blank" rel="noopener">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这篇文章是 reddit 上用户 &lt;a href=&quot;https://www.reddit.com/user/unknownguy0518/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;unknownguy0518&lt;/a&gt; 发表的他在学习Django是所犯的初学者错误，以及他的一些建议。更多具体的内容可以前往对应的 &lt;a href=&quot;https://www.reddit.com/r/django/comments/eld87j/learning_django_beginner_mistakes_i_made_that_you/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;话题&lt;/a&gt; 查看。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我是 Django Web 框架的新手。我也不是专业的程序员。我没有任何人的帮助，我学到的一切都是通过反复试验而得出的。我犯了无数的错误，当我回首时，我现在笑了。在艰难学习了很多基础知识之后，我成功地创建了一个简单的网站来添加/更新/删除联系人。它已部署在 Heroku（免费服务器）中。我在这里写的内容纯属我个人观点。如果你是初学者，并且热衷于探索 Django 的世界，则应该阅读这篇文章。它可能会帮助你解决问题。&lt;/p&gt;
&lt;p&gt;那些想浏览我的网站的人（仍然需要一些工作），它是：&lt;a href=&quot;https://djangophonebook.herokuapp.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://djangophonebook.herokuapp.com&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Python" scheme="https://qiwihui.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>《编写高质量Python代码的59个有效方法》笔记</title>
    <link href="https://qiwihui.com/qiwihui-blog-79/"/>
    <id>https://qiwihui.com/qiwihui-blog-79/</id>
    <published>2020-01-08T19:42:26.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<h3>1. Python版本</h3><ul><li>Python 3</li><li>CPython, PyPy, Jython, IronPython</li></ul><h3>2. PEP8</h3><p>代码风格一致</p><h3>3. bytes，str，unicode（只讨论Python 3）</h3><p>Python 3中：bytes实例包含原始的8位值，str实例包含Unicode字符。把Unicode字符表示为二进制数据，最常见的编码方式是UTF-8。</p><ul><li>Unicode 字符 =&gt; 二进制：<code>encode</code></li><li>二进制 =&gt; Unicode 字符：<code>decode</code></li></ul><a id="more"></a><p>Python程序中，一定要把编码和解码放在最外围来操作。程序的核心部分应该使用Unicode字符类型，而且不要对字符编码做任何假设。</p><p>定义 <code>to_str</code> 和 <code>to_bytes</code> 方法。</p><p>Python 3中，<code>open</code>默认以<code>utf-8</code>编码打开，而不是二进制。</p><h3>4. 用辅助函数来取代复杂表达式</h3><h3>5. 序列切片</h3><ol><li><code>list</code>，<code>str</code>，<code>bytes</code> 以及实现了 <code>__getitem__</code> 和 <code>__setitem__</code>  的类；</li><li>切片时下表可以越界，但访问元素时不能；</li><li>当start索引为0或者end索引为列序列长度时，应该将其省略；</li><li>对list赋值时，使用切片会把原序列相关范围的值替换成新值，即使长度不一样；</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a = [1,2,3,4,5,6,7]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a[1:6] = [9]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a</span></span><br><span class="line">[1,9,7]</span><br></pre></td></tr></table></figure><h3>6. 步进式切割</h3><ol><li>避免在一个切片操作中同时使用 <code>start</code>，<code>end</code>和<code>stride</code>；</li><li>避免使用负数做stride；</li></ol><h3>7. 用列表推导代替map和filter</h3><ol><li>list, 字典和集合支持列表推导；</li><li>代码清晰；</li></ol><h3>8. 不要使用含有两个以上表达式的列表推导</h3><p>会变得难理解</p><h3>9. 用生成器表达式来改写数据量较大的列表推导式</h3><ol><li><p>数据量较大时，列表推导式会占用大量内存</p></li><li><p><code>()</code></p></li></ol><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a_long_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">value = [len(x) <span class="keyword">for</span> x <span class="keyword">in</span> a_long_list]</span><br><span class="line">print(value)</span><br></pre></td></tr></table></figure><p>=&gt;</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">value = (len(x) <span class="keyword">for</span> x <span class="keyword">in</span> a_long_list)</span><br><span class="line">print(next(value))</span><br></pre></td></tr></table></figure><ol start="3"><li>可以组合</li></ol><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">roots = ((v, v ** <span class="number">0.5</span>)<span class="keyword">for</span> v <span class="keyword">in</span> value)</span><br><span class="line">print(next(roots))</span><br></pre></td></tr></table></figure><h3>10. <code>range</code> =&gt; <code>enumerate</code></h3><p><code>enumerate</code> 可以把各种迭代器包装成生成器，以便稍后产生输出值。<code>enumerate</code> 计数下表默认从 <code>0</code> 开始，可以修改。</p><h3>11. 用 <code>zip</code> 同是遍历两个迭代器</h3><ol><li>迭代器长度相同</li><li>不同时使用 <code>itertools.zip_longest</code></li></ol><h3>12. 不要在 <code>for</code> 和 <code>while</code> 循环后面写 <code>else</code></h3><p>与 <code>if/else</code>, <code>try/except/else</code> 的 <code>else</code> 不同，容易误解</p><h3>13. <code>try/except/else/finally</code></h3><ol><li><code>finally</code>块：既要将异常向上传播，又要在异常发生时做清理工作</li><li><code>ry/except/else</code>：except使异常传播变得清晰，else便于自己处理代码</li></ol><h3>14. 尽量用异常来表示特殊情况，而不要返回 <code>None</code></h3><p>比如除以0时，抛出异常</p><h3>15. 在闭包中使用外围作用域中的变量</h3><ol><li>Python3 获取闭包中的变量：<code>nonlocal</code>，但是<code>nonlocal</code>不能延伸到模块级别；</li><li>Python2 中可以使用可变值来实现，比如包含单个元素的列表。</li><li>除非函数简单，尽量不使用 <code>nonlocal</code></li></ol><h3>16. 考虑用生成器改写直接返回列表的函数</h3><p><code>yield</code></p><h3><em>17. 在参数上迭代时需要多加小心</em></h3><ol><li>参数是迭代器时要多加注意；</li><li>迭代器协议：容器和迭代器，<code>iter</code>，<code>next</code></li><li><code>__iter__</code></li><li>判断是否为迭代器：<code>iter(target) == iter(target)</code> 为True，则为迭代器</li></ol><h3>18. 用数量可变的位置参数减少视觉混乱</h3><ol><li>星号参数（<code>*args</code>），<code>*</code>操作符</li><li>变长参数在传给函数时，总是先转化成元组，如果是生成器，注意内存使用；</li><li>添加新参数时，需要修改原来函数使用。可使用关键字形式指定的参数解决这个问题。</li></ol><h3>19. 用关键字参数表达可选行为</h3><ol><li>位置参数必必须出现在关键字之前；每个参数只能指定一次；</li><li>关键字参数；易读，可提供默认值，扩充参数方便；</li></ol><h3>20. 用<code>None</code>和文档字符串描述具有动态默认值的参数</h3><ol><li>参数的默认值，只会在程序加载模块并读到本函数的定义时评估一次，对于<code>{}</code>，<code>[]</code>等动态值会出现奇怪行为。</li></ol><h3>21. 用只能以关键值形式指定的参数来确保代码明晰</h3><p>Python 3 中：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">safe_division_before</span><span class="params">(number, divisor, ignore_overflow=False, ignore_zero_divisor=False)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>==&gt;</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">safe_division_after</span><span class="params">(number, divisor, *, ignore_overflow=False, ignore_zero_divisor=False)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><code>*</code> 标识着位置参数结束，之后的参数只能以关键字形式指定。</p><h3>22. 尽量用辅助类来维护程序状态，而不用字典和元组</h3><ol><li>不使用包含字典的字典或者过长的元组；</li><li>具名元组：<code>collections.namedtuple</code>；</li></ol><h3>23. 简单的接口应该接受函数，而不是类的实例</h3><ol><li>Python中的函数是一级对象，函数和方法可以像语言中的其他值那样传递和引用；</li><li>举例：<ul><li><code>list</code>类型的<code>sort</code>方法</li><li><code>defaultdict</code></li></ul></li><li><code>__call__</code> 使类的实例像普通函数那样调用；</li><li>如果要用函数保存状态，就应该定义新的类，并令其实现 <code>__call__</code> 方法，而不要定义带状态的闭包。</li></ol><h3>24. 以 <code>@classmedtod</code> 形式的多态去通用地构建对象</h3><ol><li>每个类只能有一个构造器，即 <code>__init__</code>；</li><li><code>@@classmedtod</code> 机制可以用一种与构造器相似的方式构造类对象；</li></ol><h3>25. 用 <code>super</code> 初始化父类</h3><ol><li>Python采用标准的方法解析解析顺序来解决 <em>超类初始化次序</em> 和 <em>菱形继承问题</em>；</li><li><code>super</code> 在Python2和Python3不一致；</li></ol><p>Python 3 中以下两种方式效果相同</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Explicit</span><span class="params">(MyBaseClass)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        super(__class__, self).__init__(value)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implicit</span><span class="params">(MyBaseClass)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        super().__init__(value)</span><br></pre></td></tr></table></figure><ol start="3"><li>总是应该使用内置的 <code>super</code> 函数来初始化父类；</li><li>类的 <code>mro</code> 方法可以查看方法解析顺序：<code>MyClass.mro()</code></li></ol><h3>26. 只在使用 Mix-in 组件制作工具类时进行多重继承</h3><ol><li>mix-in 是一种小型类，它只定义了其他类可能需要提供的一套附加方法，而不定义自己的实例属性，它也不要求使用者调用自己的 <code>__init__</code> 构造器；</li><li>能用 mix-in 组件实现的效果，就不要用多重继承来做；</li><li>将各个功能实现为可插拔的 mix-in 组件，然后让相关类继承自己需要的组件，即可定制该类实例所应具备的行为；</li><li>简单行为封装到 mix-in 组件中，然后用多个组件组合出复杂功能。</li></ol><h3>27. 多用 public 属性，少用 private 属性</h3><ol><li>Python解释器无法严格保证 private 字段的私密性（Python中会将类的 private 属性名称变化为 <code>_{类名称}__{原private属性名称}</code>）；</li><li>不要盲目将属性设置为 private，而是一开始就做好规划，并允许子类更多地访问超类内部API；</li><li>多用 protected 属性，并在文档中将这些字段的合理用法告诉开发者，而不要试图用 private 属性来限制子类访问；</li><li>只有当子类不受自己控制时，才可考虑使用 private 属性避免冲突。</li></ol><h3>28. 继承 <code>collections.abc</code> 以实现自定义容器类型</h3><p>编写自定义容器类型时，从 <code>collections.abc</code> 模块的抽象基类中继承，那些基类可以确保子类具有适当的接口和行为。</p><h3>49. 为每个函数、类和模块编写文档字符串</h3><ol><li>docstring</li></ol><h3>54. 模块级别代码配置不同的部署环境</h3><ol><li>环境变量</li><li><code>os</code>，<code>sys</code></li></ol><h3>55. 用 <code>repr</code> 输出调试信息</h3><ol><li><code>print</code> 易于阅读字符串</li><li><code>repr</code> 可供打印字符串，<code>eval</code> 还原为初始值</li><li>格式化字符串：<code>%s</code> =&gt; str; <code>%r</code> =&gt; repr</li><li><code>__repr__</code> 自定义可供打印字符串；</li><li><code>__dict__</code> 任意对象查询实例字典；</li></ol><p>示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(5)</span></span><br><span class="line">5</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(<span class="string">'5'</span>)</span></span><br><span class="line">5</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(repr(5))</span></span><br><span class="line">5</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(repr(<span class="string">'5'</span>))</span></span><br><span class="line">'5'</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(<span class="string">'%s'</span> % 5)</span></span><br><span class="line">5</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(<span class="string">'%s'</span> % <span class="string">'5'</span>)</span></span><br><span class="line">5</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(<span class="string">'%r'</span> % 5)</span></span><br><span class="line">5</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span>(<span class="string">'%r'</span> % <span class="string">'5'</span>)</span></span><br><span class="line">'5'</span><br></pre></td></tr></table></figure><h3>56. unittest 测试</h3><p>要确保 Python 程序能正常运行，唯一的方法就是编写测试。Python 语言动态特性，一方面阻碍了静态类型检测，另一方面却有利于开发者进行测试。</p><ol><li>断言（assertion）：<code>assertEqual</code>，<code>assertTrue</code>，<code>assertRaises</code></li><li>mock</li><li><code>setUp</code>，<code>tearDown</code></li><li>单元测试，集成测试</li></ol><h3>57. <code>pdb</code> 交互调试</h3><p><code>import pdb; pdb.set_trace()</code></p><ol><li><code>bt</code>，<code>up</code>，<code>down</code></li><li><code>step</code>，<code>next</code>，<code>return</code>，<code>continue</code></li></ol><h3>58. 性能分析</h3><ol><li>Python 性能分析工具 <code>profile</code>：<code>profile</code>，<code>cProfile</code></li><li><code>runcall</code></li><li><code>Stats</code></li></ol><h3>59. <code>tracemalloc</code> 内存使用及泄漏</h3><p>CPyhton：引用计数，gc</p><ol><li><code>gc.get_objects()</code></li><li><code>tracemalloc.take_snapshot()</code></li></ol><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog" target="_blank" rel="noopener">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui" target="_blank" rel="noopener">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3&gt;1. Python版本&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Python 3&lt;/li&gt;
&lt;li&gt;CPython, PyPy, Jython, IronPython&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2. PEP8&lt;/h3&gt;
&lt;p&gt;代码风格一致&lt;/p&gt;
&lt;h3&gt;3. bytes，str，unicode（只讨论Python 3）&lt;/h3&gt;
&lt;p&gt;Python 3中：bytes实例包含原始的8位值，str实例包含Unicode字符。把Unicode字符表示为二进制数据，最常见的编码方式是UTF-8。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Unicode 字符 =&amp;gt; 二进制：&lt;code&gt;encode&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;二进制 =&amp;gt; Unicode 字符：&lt;code&gt;decode&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="Python" scheme="https://qiwihui.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>在 Github 上“连续”提交187天</title>
    <link href="https://qiwihui.com/qiwihui-blog-76/"/>
    <id>https://qiwihui.com/qiwihui-blog-76/</id>
    <published>2019-06-25T06:14:56.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>这也是我关于自己在Github上连续提交173天的过程。准确说这并不是我连续173天在Github提交代码，在整个过程中总共中断了两次，第一次是在农历大年三十，和家人吃完年夜饭聊天完已经过了提交时间点了，第二次是在3月2号，家里的猫因为生病照顾了一个晚上。总得来讲这是一次非常有挑战但是却收获很大的过程。</p><h2>开始</h2><p>故事起因于自我懈怠的感知，我在去年年底有很长一段时间不知道自己改做什么，处在十分疲惫的状态，以至于在12月的时候连着一周没有任何提交，知道我觉得自己应该做些什么改变。我想起了很早之前的一遍博客：《<a href="https://linux.cn/article-1984-1.html" target="_blank" rel="noopener">我泡在GitHub上的177天</a>》，于是，我决定试着实践一次在 Github 上进行连续提交，以改变自己的状态。</p><a id="more"></a><p>我试着按照博客中的约定给自己定下了几条提交的要求：</p><ol><li>提交必需要有意义，不能是简单的编辑格式或者修改错字；</li><li>不能自动化提交过程，不能作弊。</li></ol><h2>前半段</h2><p>不可否认，在这个计划刚开始的时候热情十足，有过40个提交的一天，以及好些个十几个提交的日子，虽然40个提交只是整理博客带来的，但也是让我很是激动。即使我在前半端的时间里有过两次终端也没有对降低我的热情。</p><h2>后半段</h2><p>在第60天之后，这个挑战的难度就开始显现了，一是我开始出现的疲惫，另一个是因为我开始出现提交枯竭。我在这次挑战中的提交大概有以下几类：</p><ol><li>博客已经相应带来的修改；</li><li>自己的项目想法的提交，比如 <a href="https://github.com/qiwihui/SMSFilters" target="_blank" rel="noopener">SMSFilters</a>；</li><li>《强化学习导论（第二版）》的学习笔记；</li><li>对开源项目的贡献，包括issue和PR；</li><li>日常阅读文章的记录。</li></ol><p>博客刚开始写得勤，一周一到两篇，后来能两三周一篇就已经算很多了；项目的想法不可能一直有；学习笔记越到后边越困难，渐渐一章一节的时间就加长了；对开源的项目的提交并不能都得到合并；阅读的文章也不能总是读到很优秀的文章。所以后来，每天的提交频率基本处于保底。</p><h2>结束和总结</h2><p>今天决定这是这次挑战的最后一个提交，写成一遍简短的博客做为结束。终于如释重负，放下了心头的重担。</p><p>正如那篇博客提及的一样，如果一个好习惯被刻意过度遵循的话也会变成坏事；每天完成的一个目标连起来形成一条链时，它会激励你去继续完成目标，保持这条链不断裂。</p><p>最后，我觉得对于 Github 的提交统计计算也有一些小的提示和想法：</p><ol><li>fork别人的项目也是算提交的，即使你没给别人提交PR，可能Github觉得这也算是为开源的传播贡献了一份力量吧；</li><li>提交时间上，在北京时间大约一点之前的提交都还算是头一天的提交，当然我觉得在这个点提交也是要冒没赶上的风险的；</li><li>commit 之后就算时间了，不一定要马上推送到远程；</li><li>好的想法也算是提交，对一篇文章的想法也可以包含在内。</li></ol><p>我最后的建议是进行一次这样的挑战，可以给自己带来一个好的习惯。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这也是我关于自己在Github上连续提交173天的过程。准确说这并不是我连续173天在Github提交代码，在整个过程中总共中断了两次，第一次是在农历大年三十，和家人吃完年夜饭聊天完已经过了提交时间点了，第二次是在3月2号，家里的猫因为生病照顾了一个晚上。总得来讲这是一次非常有挑战但是却收获很大的过程。&lt;/p&gt;
&lt;h2&gt;开始&lt;/h2&gt;
&lt;p&gt;故事起因于自我懈怠的感知，我在去年年底有很长一段时间不知道自己改做什么，处在十分疲惫的状态，以至于在12月的时候连着一周没有任何提交，知道我觉得自己应该做些什么改变。我想起了很早之前的一遍博客：《&lt;a href=&quot;https://linux.cn/article-1984-1.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我泡在GitHub上的177天&lt;/a&gt;》，于是，我决定试着实践一次在 Github 上进行连续提交，以改变自己的状态。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="总结" scheme="https://qiwihui.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>HMM理解思路</title>
    <link href="https://qiwihui.com/qiwihui-blog-74/"/>
    <id>https://qiwihui.com/qiwihui-blog-74/</id>
    <published>2019-06-03T01:39:05.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<h1>HMM</h1><p>本文整理简单整理一下HMM的理解思路。</p><a id="more"></a><h2>模型</h2><h3>马尔科夫性与马尔科夫链</h3><p>性质：- 有限历史假设- 时间不变性</p><h3>隐马尔科夫模型</h3><ol><li><p>模型定义：1、初始状态概率向量 $\pi=(\pi_i)$，其中 $\pi_{i}=P(i_{1}=q_{i}), \quad i=1,2, \cdots, N$2、状态转移概率矩阵 $A=\left[a_{i j}\right]<em>{N \times N}$，其中 $a</em>{i j}=P\left(i_{t+1}=q_{j} | i_{t}=q_{i}\right), \quad i=1,2, \cdots, N ; j=1,2, \cdots, N$3、观测概率矩阵 $B=\left[b_{j}(k)\right]<em>{N \times M}$，其中 $b</em>{j}(k)=P\left(o_{t}=v_{k} | i_{t}=q_{j}\right), \quad k=1,2, \cdots, M ; j=1,2, \cdots, N$4、观测序列 $O=(o_{1}, o_{2}, \cdots, o_{T})$，状态序列 $I=(i_{1}, i_{2}, \cdots, i_{T})$5、状态集合 $Q=\left{q_{1}, q_{2}, \cdots, q_{N}\right}$，观测集合 $V=\left{v_{1}, v_{2}, \cdots, v_{M}\right}$</p></li><li><p>模型三元组 $\lambda=(A, B, \pi)$</p><p>状态转移概率矩阵A与初始状态概率向量确定了隐藏的马尔科夫链，生成不可观测的序列。观测概率矩阵B确定了如何从状态生成规则，与状态序列综合确定了如何产生观测序列。</p></li><li><p>模型基本假设：</p><ul><li>齐次马尔科夫性假设：设隐马尔科夫链在任意时刻t的状态只依赖于其前一时刻的状态，与其他时刻的状态及观测无关，也与时刻t无关。</li><li>观测独立性假设：假设任意时刻的观测只依赖于该时刻的马尔科夫链的状态，与其他观测和状态无关。</li></ul></li><li><p>例子：</p><ul><li><a href="https://en.wikipedia.org/wiki/Viterbi_algorithm#Example" target="_blank" rel="noopener">感冒预测</a>，<a href="https://applenob.github.io/hmm.html#%E4%B8%80%E4%B8%AA%E5%85%B3%E4%BA%8E%E6%84%9F%E5%86%92%E7%9A%84%E5%AE%9E%E4%BE%8B" target="_blank" rel="noopener">中文</a></li><li><a href="https://www.zhihu.com/question/20962240/answer/33438846" target="_blank" rel="noopener">掷骰子</a></li><li><a href="https://www.zhihu.com/question/20962240/answer/64187492" target="_blank" rel="noopener">天气模型</a></li><li><a href="https://www.zhihu.com/question/20962240/answer/33561657" target="_blank" rel="noopener">偷换骰子大法</a></li></ul></li></ol><h2>三个问题</h2><h3>概率计算问题（评估）</h3><p>给定模型 $\lambda=(A, B, \pi)$ 和观测序列 $O=o_{1}, o_{2}, \ldots, o_{T}$，计算在模型 $\pi$ 下观测序列 $O$ 出现的概率 $P(O | \lambda)$。- 穷举搜索，<code>O(TN^T)</code>- 前向算法，<code>O(N^2T)</code>- 后向算法</p><h3>预测问题（解码）</h3><p>已知观测序列 $O=o_{1}, o_{2}, \ldots, o_{T}$ 和模型 $\lambda=(A, B, \pi)$，求给定观测序列条件概率 $P(I|O)$ 最大的状态序列 $I=\left(i_{1}, i_{2}, \ldots, i_{T}\right)$，即给定观测序列，求最有可能的对应的状态序列。- 穷举搜索- 近似计算- 维特比（Viterbi）算法：动态规划</p><h3>学习问题</h3><p>已知观测序列 $O=o_{1}, o_{2}, \ldots, o_{T}$，估计模型 $\lambda=(A, B, \pi)$，使 $P(O | \lambda)$ 最大。- 监督算法：利用极大似然估计- 非监督算法：Baum-Welch算法（EM算法在HMM中的具体实现）</p><h2>应用</h2><p>语音识别，中文分词，手写识别</p><h2>参考</h2><ol><li>《统计学习方法》，李航</li><li><a href="https://applenob.github.io/hmm.html" target="_blank" rel="noopener">隐马尔科夫模型（HMM）及其Python实现</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;HMM&lt;/h1&gt;
&lt;p&gt;本文整理简单整理一下HMM的理解思路。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="https://qiwihui.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>姜汁撞奶小记</title>
    <link href="https://qiwihui.com/qiwihui-blog-72/"/>
    <id>https://qiwihui.com/qiwihui-blog-72/</id>
    <published>2019-05-19T08:29:23.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>上周陪着看《向往的生活》，黄磊在节目中给大家做了一次姜汁撞奶，看着大家都吃得都开了花似的，于是决定我也要做一次。</p><h2>1.0版本</h2><p>在超市买菜的时候随手买了生姜和牛奶，回到家放进冰箱也就忘了。昨天想起来开始做时已经过了五天了，开始第一次尝试。首先把生姜切成小块，放碗里用擀面杖捣碎了，因为生姜有点干了，加了点水挤出来小半碗姜汁，然后把牛奶加入白糖煮开了，倒入装姜汁的碗中，然后将碗中的撞奶放到锅上蒸了五分钟。但是，结果并没有像电视上那样好，牛奶还是牛奶，加了姜汁和糖的牛奶。为什么会失败呢？</p><p>认真分析了一下原因，我想大概是是这样的：姜汁撞奶的过程就是蛋白质变性的过程，牛奶中的蛋白质和姜汁中的某些物质混合导致蛋白质变性，和做豆腐脑的过程差不多，但是因为原料的品质没有达到变性的要求：</p><ol><li>生姜放着已经变干了，没有什么汁水，我又加了水，导致姜汁的浓度不够；</li><li>牛奶的保质期是8天，加上放置的几天，基本也就是变质前一天才用，这是蛋白质已经发生了一些变化，从我之后买的新鲜的牛奶的对比可以看出这时的牛奶已经有些变浑了，而且可能牛奶不是全脂的，蛋白质浓度不高；</li><li>姜汁和牛奶混合之后放锅上蒸其实是为了保温，但是加热沸腾会使最后变性的过程被破坏，没法凝成豆腐脑那样。</li></ol><p>基于以上的分析，我决定再试一次。</p><a id="more"></a><h2>2.0版本</h2><p>首先选材，生姜选老一些的，这样是蛋白质变性的物质含量高，牛奶选全脂的，蛋白质含量高。其次，做法上，生姜用板子磨成末挤姜汁水，牛奶煮的时候煮到快开再关火等10秒，这样大概就是80度，然后与姜汁混合。混合的时候把姜汁分成了两个碗，每个碗倒入原来一般的牛奶，这样就比之前更好控制。混合之后不搅动，并用盘子盖住保持温度，等10分钟左右。</p><p>经过这些改进，我终于得到了形似豆腐脑的姜汁装奶！虽然没有把握好糖的量使得牛奶有些淡，但2.0版本味道确实不错。</p><img width="367" alt="ginger_milk" src="https://user-images.githubusercontent.com/3297411/57985140-3ab2f300-7a96-11e9-887a-a5ffed954da9.png"><h2>总结</h2><p>做一件事要了解原理，掌握每一步的技术细节和对结果的影响，这样才能做好一件事！这就是两次姜汁撞奶的总结。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周陪着看《向往的生活》，黄磊在节目中给大家做了一次姜汁撞奶，看着大家都吃得都开了花似的，于是决定我也要做一次。&lt;/p&gt;
&lt;h2&gt;1.0版本&lt;/h2&gt;
&lt;p&gt;在超市买菜的时候随手买了生姜和牛奶，回到家放进冰箱也就忘了。昨天想起来开始做时已经过了五天了，开始第一次尝试。首先把生姜切成小块，放碗里用擀面杖捣碎了，因为生姜有点干了，加了点水挤出来小半碗姜汁，然后把牛奶加入白糖煮开了，倒入装姜汁的碗中，然后将碗中的撞奶放到锅上蒸了五分钟。但是，结果并没有像电视上那样好，牛奶还是牛奶，加了姜汁和糖的牛奶。为什么会失败呢？&lt;/p&gt;
&lt;p&gt;认真分析了一下原因，我想大概是是这样的：姜汁撞奶的过程就是蛋白质变性的过程，牛奶中的蛋白质和姜汁中的某些物质混合导致蛋白质变性，和做豆腐脑的过程差不多，但是因为原料的品质没有达到变性的要求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;生姜放着已经变干了，没有什么汁水，我又加了水，导致姜汁的浓度不够；&lt;/li&gt;
&lt;li&gt;牛奶的保质期是8天，加上放置的几天，基本也就是变质前一天才用，这是蛋白质已经发生了一些变化，从我之后买的新鲜的牛奶的对比可以看出这时的牛奶已经有些变浑了，而且可能牛奶不是全脂的，蛋白质浓度不高；&lt;/li&gt;
&lt;li&gt;姜汁和牛奶混合之后放锅上蒸其实是为了保温，但是加热沸腾会使最后变性的过程被破坏，没法凝成豆腐脑那样。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;基于以上的分析，我决定再试一次。&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="https://qiwihui.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>网络故障透露中国互联网接入现状</title>
    <link href="https://qiwihui.com/qiwihui-blog-71/"/>
    <id>https://qiwihui.com/qiwihui-blog-71/</id>
    <published>2019-05-18T04:08:57.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://blog.thousandeyes.com/internet-outage-reveals-reach-of-chinas-connectivity/" target="_blank" rel="noopener">Internet Outage Reveals Reach of China’s Connectivity</a></p><p>太平洋标准时间5月13日中午12点30分（北京时间5月14日凌晨3:30），中国电信经历了持续近5个小时的重大故障，后续效应持续了几个小时。正如在美国对贸易政策的紧张局势加剧之时所做的那样，可能很容易让人联想到对潜在地缘政治动机的猜测。然而，这种猜测忽略了许多人都不知道的关于中国和互联网的一些重要的基本现实。这次中断是深入了解中国互联网连接状况的绝佳机会。</p><a id="more"></a><iframe width="560" height="315" src="https://www.youtube.com/embed/cBylzjskZho" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><h2>我们所见的</h2><p>昨天，从下午早些时候开始，我们的全球优势点开始检测到中国电信骨干网上进出中国的互联网流量出现大量数据包丢失。数据包丢失持续数小时，主要影响中国大陆的网络基础设施，但也影响中国电信在新加坡的网络和美国的多个接入点，包括洛杉矶。</p><p>在长时间中断的过程中，通过受影响的基础设施的任何流量都被丢弃，这意味着中国境内外的一些互联网用户将遇到连接到各种网站和应用程序的服务中断。中国境内的用户试图访问中国以外的网站会受到影响，同时中国以外的用户尝试连接到中国境内的网站也是如此。</p><p>这些不仅仅影响西方网站和服务，许多美国主要网站，如Apple，Amazon，Microsoft，Slack，Workday，SAP等在中断期间都受到了影响。下图显示了中断的附带损害的部分范围。</p><p><img src="https://user-images.githubusercontent.com/3297411/57969235-a5393580-79a7-11e9-873f-62a2c42aa573.png" alt="Figure-1-China-Telecom-outage"></p><p>图1：受中国电信中断影响的基于云的服务。</p><p>在最高峰时，我们检测到因中国电信全球骨干网络状况而中断的100多项服务。我们还检测到中断对地理影响的变化，如下面的两个热图所示，在中断期间的不同点捕获。</p><p><img src="https://user-images.githubusercontent.com/3297411/57969242-af5b3400-79a7-11e9-95ee-10ea7a8158f8.png" alt="Figure-2-Geographic-scope-China-Telecom-outage"></p><p>图2：中国电信中断的地理范围在中断期间有所不同。</p><p>最严重的中断期是在太平洋标准时间12:30开始后的前三个小时内发生的，但许多服务在数小时后继续受到影响。一项特定服务的中断的扩展性质可以在下面的图3中看到。Amazon Web Services的数据包丢失从太平洋标准时间12:30开始飙升，持续约5个小时。下面的路径可视化显示了在17:30-17:45（太平洋标准时间）之间的网络状况，此时前往AWS的流量继续被中国电信路由器丢弃。</p><p><img src="https://user-images.githubusercontent.com/3297411/57969353-bb93c100-79a8-11e9-9636-e0afabbcb50f.png" alt="Figure-3-AWS-services-impacted"></p><p>图3：中国电信用户在12:30-17:45（太平洋标准时间）之间受影响的AWS服务。</p><p>受中断影响的另一家美国服务是Cloudflare的托管DNS服务。例如，WeWork的域名由Cloudflare托管，在下面的路径可视化中，您可以看到尝试访问Cloudflare的DNS服务器的流量（由最右边的绿色节点表示，IP地址为173.245.58.135，这是地理位置位于美国的路由前缀173.245.58.0/24的一部分。）被中国境内的中国电信路由器丢弃。结果是来自中国境内的许多用户无法访问WeWork网站。</p><p><img src="https://user-images.githubusercontent.com/3297411/57969270-efbab200-79a7-11e9-9013-05196425426d.png" alt="Figure-4-Cloudflare-DNS-resolution"></p><p>图4：Cloudflare的托管DNS服务受到影响，阻止了WeWork域的DNS解析。</p><h2>中国是深度互联的</h2><p>中断现已解决，但在ThousandEyes，我们相信每次互联网停运都是一次学习机会，这也不例外。这里有两个要点可能一般不太清楚。</p><p>首先，大多数人认为“<a href="https://blog.thousandeyes.com/deconstructing-great-firewall-china/" target="_blank" rel="noopener">长城防火墙</a>”是一套统一管理的规则，使中国用户与全球其他地方隔离。他们想象一方面是中国庞大的用户和为他们提供服务的网络基础设施，另一方面，互联网的其余部分。但现实情况是，中国与外部网站和服务的联系非常紧密──至少是那些服务于商业利益的网站和服务。</p><p>中国互联网服务提供商（ISP）的标准操作程序允许访问大多数西方基于云的业务服务。通过允许国内和外国公司更有效地开展业务，从中国境内进入这些类型的网站符合中国的利益。通俗地说，您可以从中国境内访问许多美国服务。</p><p>其次，大多数人也可能没有意识到中国的互联网服务提供商将拥有全球性的存在。但是，如上图2所示，中国电信控制和管理的基础设施范围远远超出了中国的地理边界。该提供商还维护全球互联，与全球许多地方的服务提供商保持联系。</p><p>那些回忆起<a href="https://blog.thousandeyes.com/internet-vulnerability-takes-down-google/" target="_blank" rel="noopener">去年影响谷歌服务的BGP路由泄漏</a>的读者，可能还记得中国电信在那一集中的客串。中国电信与负责尼日利亚工厂路线泄漏的ISP（MainOne）保持联系。中国电信未能过滤通往谷歌的广告路线（而是将其传播给其他同行），导致一些用户试图访问谷歌的服务中断。</p><h2>互联网无处不在</h2><p>无论互联网在哪里，无论是在一个自由的民主国家，还是在高度国家控制的环境中，它都是根本无法预测的。这是由于它被构建为自愿互连但单独管理的网络，基础技术的自动化性质（例如BGP路由）以及完全缺乏集中式运营管理的的集合。</p><p>当互联网的某个部分出现糟糕的事情时，尤其是在像中国这样的后续国家，互联网的其他部分会产生连锁反应。在这种情况下，超过一百种商业服务受到影响，毫无疑问，因此产生了生产力和收入损失。</p><p>当你考虑互联网是多么不可预测的时候，今天的企业依赖互联网的程度相当惊人。这是最终的不受控制的环境。这就引出了一个问题，如果你无法直接控制它，你是否拥有尽可能最好地管理它的可见性？</p><h2>现在关于那个猜测</h2><p>因为ThousandEyes本质上是（不断变化的）互联网的实时地图，我们能够跟踪互联网中断及其全球影响，无论是在中国，<a href="https://blog.thousandeyes.com/yandex-packet-loss-ddos-or-russian-firewall/" target="_blank" rel="noopener">俄罗斯</a>还是其他地方，但我们不能也不会推测这种网络事件的地缘政治和可能的动机（如果有的话）。</p><p>然而，值得注意的是，中国的互联网服务提供商非常精通对进出网络的流量实施细粒度控制。如果有意展示禁用美国应用程序和服务的能力，那么从技术角度来看，它肯定没有得到很明确的体现。毕竟，被破坏的网站和服务是不分青红皂白的，影响到中国境内外的人。</p><h2>立即获得可见性</h2><p>主要的互联网中断是企业团队关注企业所依赖的大量外部依赖关系的警钟。如果你无法深入了解四面墙以外的应用和网络层条件，那么当你的云和互联网生态系统发生不可预测的事情时，您将陷入困境。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文：&lt;a href=&quot;https://blog.thousandeyes.com/internet-outage-reveals-reach-of-chinas-connectivity/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Internet Outage Reveals Reach of China’s Connectivity&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;太平洋标准时间5月13日中午12点30分（北京时间5月14日凌晨3:30），中国电信经历了持续近5个小时的重大故障，后续效应持续了几个小时。正如在美国对贸易政策的紧张局势加剧之时所做的那样，可能很容易让人联想到对潜在地缘政治动机的猜测。然而，这种猜测忽略了许多人都不知道的关于中国和互联网的一些重要的基本现实。这次中断是深入了解中国互联网连接状况的绝佳机会。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="GFW" scheme="https://qiwihui.com/tags/GFW/"/>
    
  </entry>
  
  <entry>
    <title>Git合并提交</title>
    <link href="https://qiwihui.com/qiwihui-blog-70/"/>
    <id>https://qiwihui.com/qiwihui-blog-70/</id>
    <published>2019-05-08T22:40:55.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>在日常开发中，我们的Git提交原则经常是小功能多次提交，但是有时需要在完成功能之后将多个连续的提交合并成一个，或者进行分支合并时，只保留一个提交，以保证分支简介，这时就需要进行squash操作，两种分别称为 Rebase Squash 和 Merge Squash。这篇tip主要记录如何处理这两种操作以及之间的区别，</p><a id="more"></a><h2>Rebase Squash</h2><p>用来将多个连续的提交合并为一个，以下面的提交记录为例，<code>master</code>是主分支，分支 <code>featureY</code> 提交了一系列的修改：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git lg</span></span><br><span class="line">* 392dc11 - (HEAD -&gt; featureY) Y5 (5 minutes ago) &lt;qiwihui&gt;</span><br><span class="line">* 740e7d2 - Y4 (5 minutes ago) &lt;qiwihui&gt;</span><br><span class="line">* b54cd87 - Y3 (5 minutes ago) &lt;qiwihui&gt;</span><br><span class="line">* fb3a5cf - Y2 (6 minutes ago) &lt;qiwihui&gt;</span><br><span class="line">* 61b5ff9 - Y1 (6 minutes ago) &lt;qiwihui&gt;</span><br><span class="line">* 220e45c - (master) feature X (7 minutes ago) &lt;qiwihui&gt;</span><br></pre></td></tr></table></figure><p>其中，<code>lg</code> 是如下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[alias]</span><br><span class="line">        lg = log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit --</span><br></pre></td></tr></table></figure><p>这里我们需要合并 <code>featureY</code> 功能分支上的 <code>Y1</code> 到 <code>Y5</code> 这五个提交为一个。git提供了如下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rebase --interactive HEAD~[N]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">git rebase -i HEAD~[N]</span><br></pre></td></tr></table></figure><p>其中 <code>[N]</code> 表示需要合并的数量，从最近一个提交开始数，这里为<code>5</code>。在命令行输入 <code>git rebase --interactive HEAD~5</code> 进入编辑器进行选择。注意，这里的提交顺序是 <strong>反</strong> 的，从最早的 <code>Y1</code> 开始：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pick 61b5ff9 Y1</span><br><span class="line">pick fb3a5cf Y2</span><br><span class="line">pick b54cd87 Y3</span><br><span class="line">pick 740e7d2 Y4</span><br><span class="line">pick 392dc11 Y5</span><br></pre></td></tr></table></figure><p>对应需要合并的提交，将<code>pick</code>改成<code>squash</code>（或者简化为<code>s</code>），修改之后为：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pick 61b5ff9 Y1</span><br><span class="line">s fb3a5cf Y2</span><br><span class="line">s b54cd87 Y3</span><br><span class="line">s 740e7d2 Y4</span><br><span class="line">s 392dc11 Y5</span><br></pre></td></tr></table></figure><p>保存并关闭编辑器，这是编辑器会自动跳出并需要你提交一个新的提交：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> This is a combination of 5 commits.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This is the 1st commit message:</span></span><br><span class="line"></span><br><span class="line">Y1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> This is the commit message <span class="comment">#2:</span></span></span><br><span class="line"></span><br><span class="line">Y2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> This is the commit message <span class="comment">#3:</span></span></span><br><span class="line"></span><br><span class="line">Y3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> This is the commit message <span class="comment">#4:</span></span></span><br><span class="line"></span><br><span class="line">Y4</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> This is the commit message <span class="comment">#5:</span></span></span><br><span class="line"></span><br><span class="line">Y5</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Please enter the commit message <span class="keyword">for</span> your changes. Lines starting</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> with <span class="string">'#'</span> will be ignored, and an empty message aborts the commit.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Date:      Thu May 9 13:45:03 2019 +0800</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> interactive rebase <span class="keyword">in</span> progress; onto 220e45c</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Last commands <span class="keyword">done</span> (5 commands <span class="keyword">done</span>):</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    squash 740e7d2 Y4</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    squash 392dc11 Y5</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> No commands remaining.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> You are currently rebasing branch <span class="string">'featureY'</span> on <span class="string">'220e45c'</span>.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    new file:   featY</span></span><br><span class="line"><span class="meta">#</span></span><br></pre></td></tr></table></figure><p>可以看到，Git提供了详细的信息指导提交，只需要修改成你需要的信息即可，比如 <code>featureY</code>，然后保存。这时就完成了修改，修改之后的提交信息如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git lg</span></span><br><span class="line">* 1b07941 - (HEAD -&gt; featureY) featureY (3 minutes ago) &lt;qiwihui&gt;</span><br><span class="line">* 220e45c - (master) feature X (36 minutes ago) &lt;qiwihui&gt;</span><br></pre></td></tr></table></figure><h2>Merge Squash</h2><p>用于在合并分支时，最后只在合并后的分支上保留一个提交。同样以上面的代码提交为例子。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git lg</span></span><br><span class="line">* 392dc11 - (HEAD -&gt; featureY) Y5 (5 minutes ago) &lt;qiwihui&gt;</span><br><span class="line">* 740e7d2 - Y4 (5 minutes ago) &lt;qiwihui&gt;</span><br><span class="line">* b54cd87 - Y3 (5 minutes ago) &lt;qiwihui&gt;</span><br><span class="line">* fb3a5cf - Y2 (6 minutes ago) &lt;qiwihui&gt;</span><br><span class="line">* 61b5ff9 - Y1 (6 minutes ago) &lt;qiwihui&gt;</span><br><span class="line">* 220e45c - (master) feature X (7 minutes ago) &lt;qiwihui&gt;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --squash featureY  </span></span><br><span class="line">Updating 220e45c..392dc11</span><br><span class="line">Fast-forward</span><br><span class="line">Squash commit -- not updating HEAD</span><br><span class="line"> featY | 5 +++++</span><br><span class="line"> 1 file changed, 5 insertions(+)</span><br><span class="line"> create mode 100644 featY</span><br></pre></td></tr></table></figure><p>此时，分支<code>featureY</code>保持不变，同时在<code>master</code>上多了一个未被提交的更改：</p><p><img src="https://user-images.githubusercontent.com/3297411/57431740-503e4680-7266-11e9-88d3-a9a0cb3fb7a5.png" alt="git-merge-squash"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use "git reset HEAD &lt;file&gt;..." to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   featY</span><br></pre></td></tr></table></figure><p>这些更改是分支<code>featureY</code>中所有提交的合并，现在只需要提交这些更改就可以了：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m "featureY"</span><br></pre></td></tr></table></figure><h2>区别</h2><p>从以上的擦坐过程可以看出两者之间的差别：Rebase Squash会合并之前的提交，之前的记录会消失，而Merge Squash只会在合并的分支上新生成提交，原来的那些提交熬还会保留。</p><h2>多说一点</h2><p>如果需要合并的提交数量很多，数数容易出错，可以使用提交哈希来识别：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rebase --interactive [commit-hash]</span><br></pre></td></tr></table></figure><p>这个<code>[commit-hash]</code>是<em>需要合并的提交之前的一个提交</em>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git lg</span></span><br><span class="line">* 392dc11 - (HEAD -&gt; featureY) Y5 (5 minutes ago) &lt;qiwihui&gt;</span><br><span class="line">* 740e7d2 - Y4 (5 minutes ago) &lt;qiwihui&gt;</span><br><span class="line">* b54cd87 - Y3 (5 minutes ago) &lt;qiwihui&gt;</span><br><span class="line">* fb3a5cf - Y2 (6 minutes ago) &lt;qiwihui&gt;</span><br><span class="line">* 61b5ff9 - Y1 (6 minutes ago) &lt;qiwihui&gt;</span><br><span class="line">* 220e45c - (master) feature X (7 minutes ago) &lt;qiwihui&gt;</span><br></pre></td></tr></table></figure><p>这里，需要使用 <code>220e45c</code> 而不是 <code>61b5ff9</code>。</p><h2>参考</h2><ul><li><a href="https://www.internalpointers.com/post/squash-commits-into-one-git" target="_blank" rel="noopener">Squash commits into one with Git</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在日常开发中，我们的Git提交原则经常是小功能多次提交，但是有时需要在完成功能之后将多个连续的提交合并成一个，或者进行分支合并时，只保留一个提交，以保证分支简介，这时就需要进行squash操作，两种分别称为 Rebase Squash 和 Merge Squash。这篇tip主要记录如何处理这两种操作以及之间的区别，&lt;/p&gt;
    
    </summary>
    
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>在 “Deploy to Heroku” 之后手动更新Heroku应用</title>
    <link href="https://qiwihui.com/qiwihui-blog-69/"/>
    <id>https://qiwihui.com/qiwihui-blog-69/</id>
    <published>2019-05-04T21:19:42.000Z</published>
    <updated>2020-05-16T15:36:39.346Z</updated>
    
    <content type="html"><![CDATA[<p>这个tips以RSSHub为例子。我在Heroku上部署了RSSHub用以日常RSS需求，这个已经部署很久了（2018年11月），准备更新一版，记录如下。</p><a id="more"></a><ol><li>登录Heroku，按照提示进行认证并登录。</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> heroku login</span></span><br></pre></td></tr></table></figure><ol start="2"><li>获取最新代码，这里我在RSSHub项目目录中进行了拉取（pull）：</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> RSSHub</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull origin master</span></span><br></pre></td></tr></table></figure><ol start="3"><li>添加Heroku中项目url，可在 <code>Settings</code> 中 <code>Heroku Git URL</code> 找到：</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> heroku git:remote -a rss-qiwihui                       </span></span><br><span class="line">set git remote heroku to https://git.heroku.com/rss-qiwihui.git</span><br></pre></td></tr></table></figure><ol start="4"><li>向Heroku推送，这时Heroku会自动进行部署，结果如下：</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push heroku master</span></span><br><span class="line">Enumerating objects: 12288, done.</span><br><span class="line">Counting objects: 100% (12288/12288), done.</span><br><span class="line">Delta compression using up to 4 threads</span><br><span class="line">Compressing objects: 100% (3324/3324), done.</span><br><span class="line">Writing objects: 100% (12288/12288), 6.32 MiB | 40.44 MiB/s, done.</span><br><span class="line">Total 12288 (delta 8027), reused 12287 (delta 8026)</span><br><span class="line">remote: Compressing source files... done.</span><br><span class="line">remote: Building source:</span><br><span class="line">remote: </span><br><span class="line">remote: -----&gt; Node.js app detected</span><br><span class="line">remote:        </span><br><span class="line">remote: -----&gt; Creating runtime environment</span><br><span class="line">remote:        </span><br><span class="line">remote:        NPM_CONFIG_LOGLEVEL=error</span><br><span class="line">remote:        NODE_ENV=production</span><br><span class="line">remote:        NODE_MODULES_CACHE=true</span><br><span class="line">remote:        NODE_VERBOSE=false</span><br><span class="line">remote:        </span><br><span class="line">remote: -----&gt; Installing binaries</span><br><span class="line">remote:        engines.node (package.json):  &gt;=8.0.0</span><br><span class="line">remote:        engines.npm (package.json):   unspecified (use default)</span><br><span class="line">remote:        engines.yarn (package.json):  unspecified (use default)</span><br><span class="line">remote:        </span><br><span class="line">remote:        Resolving node version &gt;=8.0.0...</span><br><span class="line">remote:        Downloading and installing node 12.1.0...</span><br><span class="line">remote:        Using default npm version: 6.9.0</span><br><span class="line">remote:        Resolving yarn version 1.x...</span><br><span class="line">remote:        Downloading and installing yarn (1.16.0)...</span><br><span class="line">remote:        Installed yarn 1.16.0</span><br><span class="line">remote:        </span><br><span class="line">remote: -----&gt; Restoring cache</span><br><span class="line">remote:        Cached directories were not restored due to a change in version of node, npm, yarn or stack</span><br><span class="line">remote:        Module installation may take longer for this build</span><br><span class="line">remote:        </span><br><span class="line">remote: -----&gt; Installing dependencies</span><br><span class="line">remote:        Installing node modules (yarn.lock)</span><br><span class="line">remote:        yarn install v1.16.0</span><br><span class="line">remote:        [1/4] Resolving packages...</span><br><span class="line">remote:        [2/4] Fetching packages...</span><br><span class="line">remote:        info fsevents@1.2.8: The platform "linux" is incompatible with this module.</span><br><span class="line">remote:        info "fsevents@1.2.8" is an optional dependency and failed compatibility check. Excluding it from installation.</span><br><span class="line">remote:        [3/4] Linking dependencies...</span><br><span class="line">remote:        [4/4] Building fresh packages...</span><br><span class="line">remote:        Done in 55.40s.</span><br><span class="line">remote:        </span><br><span class="line">remote: -----&gt; Build</span><br><span class="line">remote:        </span><br><span class="line">remote: -----&gt; Caching build</span><br><span class="line">remote:        - node_modules</span><br><span class="line">remote:        </span><br><span class="line">remote: -----&gt; Pruning devDependencies</span><br><span class="line">remote:        yarn install v1.16.0</span><br><span class="line">remote:        [1/4] Resolving packages...</span><br><span class="line">remote:        [2/4] Fetching packages...</span><br><span class="line">remote:        info fsevents@1.2.8: The platform "linux" is incompatible with this module.</span><br><span class="line">remote:        info "fsevents@1.2.8" is an optional dependency and failed compatibility check. Excluding it from installation.</span><br><span class="line">remote:        [3/4] Linking dependencies...</span><br><span class="line">remote:        [4/4] Building fresh packages...</span><br><span class="line">remote:        warning Ignored scripts due to flag.</span><br><span class="line">remote:        Done in 8.07s.</span><br><span class="line">remote:        </span><br><span class="line">remote: -----&gt; Build succeeded!</span><br><span class="line">remote: -----&gt; Discovering process types</span><br><span class="line">remote:        Procfile declares types -&gt; web</span><br><span class="line">remote: </span><br><span class="line">remote: -----&gt; Compressing...</span><br><span class="line">remote:        Done: 143.8M</span><br><span class="line">remote: -----&gt; Launching...</span><br><span class="line">remote:        Released v5</span><br><span class="line">remote:        https://rss-qiwihui.herokuapp.com/ deployed to Heroku</span><br><span class="line">remote: </span><br><span class="line">remote: Verifying deploy... done.</span><br><span class="line">To https://git.heroku.com/rss-qiwihui.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br></pre></td></tr></table></figure><ol start="5"><li>设置环境变量 <code>HEROKU_SLUG_COMMIT</code>:</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> heroku config:<span class="built_in">set</span> HEROKU_SLUG_COMMIT=$(git rev-parse --short HEAD)</span></span><br><span class="line">Setting HEROKU_SLUG_COMMIT and restarting ⬢ rss-qiwihui... done, v8</span><br><span class="line"> ▸    Warning: The "HEROKU_" namespace is protected and shouldn't be used.</span><br><span class="line">HEROKU_SLUG_COMMIT: a8066bd</span><br></pre></td></tr></table></figure><ol start="6"><li>验证：</li></ol><p>前往相应的页面验证，可以看到在Debug中的 githash值已经是当前最新的hash值了。</p><p><img src="https://user-images.githubusercontent.com/3297411/57205060-5b873d00-6fee-11e9-893f-14b2978d3b92.png" alt="githash"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个tips以RSSHub为例子。我在Heroku上部署了RSSHub用以日常RSS需求，这个已经部署很久了（2018年11月），准备更新一版，记录如下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Rust如何解决依赖地狱</title>
    <link href="https://qiwihui.com/qiwihui-blog-68/"/>
    <id>https://qiwihui.com/qiwihui-blog-68/</id>
    <published>2019-04-30T02:02:43.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://stephencoakley.com/2019/04/24/how-rust-solved-dependency-hell" target="_blank" rel="noopener">How Rust Solved Dependency Hell</a></p><p>每隔一段时间我就会参与一个关于依赖管理和版本的对话，通常是在工作中，其中会出现“依赖地狱”的主题。如果你对这个术语不熟悉，那么我建议你查一下。简要总结可能是：“处理应用程序依赖版本和依赖冲突所带来的挫败感”。带着这个，让我们先获得关于依赖解析的一些技术。</p><h2>问题</h2><p>在讨论包应该具有哪种依赖关系以及哪些依赖关系可能导致问题时，本主题通常会进入讨论。作为一个真实的例子，在 <a href="https://www.widen.com/" target="_blank" rel="noopener">Widen Enterprises</a>，我们有一个内部的，可重用的Java框架，它由几个软件包组成，为我们提供了创建许多内部服务的基础（如果你愿意的话，微服务）。这很好，但是如果你想创建一个依赖于框架中某些东西的可重用共享代码库呢？如果你尝试在应用程序中使用这样的库，最终可能会得到如下依赖关系图：</p><a id="more"></a><p><img src="https://user-images.githubusercontent.com/3297411/56954726-11c3d000-6b72-11e9-92e6-ee00b3551bfd.png" alt="first"></p><p>就像在这个例子中一样，每当你试图在服务中使用库时，你的服务和库很可能依赖于不同版本的框架，这就是“依赖地狱”的开始。</p><p>现在，在这一点上，一个好的开发平台将为你提供以下两种选择的组合：</p><ul><li>使构建失败并警告我们<code>framework</code>版本<code>21.1.1</code>和<code>21.2.0</code>相互冲突。</li><li>使用<a href="https://semver.org/" target="_blank" rel="noopener">语义版本控制</a>允许包定义与其兼容的 <em>一系列</em> 版本。如果幸运的话，两个软件包都兼容的版本集是非空的，你最终可以在应用程序中自动使用其中一个版本。</li></ul><p>这两个看起来都合理，对吧？如果两个软件包确实彼此不兼容，那么我们根本无法在不修改其中一个的情况下将它们一起使用。这是一个艰难的情况，但替代方案往往更糟糕。事实上，Java是<em>不该</em>学习的一个很好的例子：</p><ul><li>默认行为是允许将依赖项的多个版本添加到类路径（Java的定位类的方式）。当应用程序需要库中的类时，实际使用哪个版本？在实践中，类的加载顺序因环境而异，甚至以非确定的方式运行，因此你实际上不知道将使用哪一个。哎呀！</li><li>我们在Widen使用的另一个选择是<em>强制版本对齐</em>。这类似于之前的第二个合理选择，在Java中，依赖关系无法表达兼容性范围，因此我们只选择较新的可能依赖项并祈祷它仍然有效。在前面显示的依赖关系图示例中，我们将强制<code>app</code>升级到<code>framework 21.2.0</code>。</li></ul><p>这看起来像是一个双输的情况，所以你可以想象，这对添加依赖项非常不利，并且使之成为一个事实上的策略，除了实际的应用程序之外什么都不允许依赖我们的核心框架。</p><h2>Rust的解决方案</h2><p>在进行这些讨论时，我会经常提到这是一个不适用于所有语言的问题，作为一个例子，Rust“解决”了这个问题。我常常拿Rust如何解决世界上所有的问题开玩笑，但在那里通常有一个真实的核心。因此，当我说Rust“解决”了这个问题以及它是如何工作的时候，让我们深入了解一下我的意思。</p><p>Rust的解决方案涉及相当多的动人的部分，但它基本上归结为挑战我们在此之前做出的核心假设：</p><blockquote><p>最终应用程序中只应存在任何给定包的一个版本。</p></blockquote><p>Rust挑战了这一点，以便重构问题，看看是否有一个在依赖地狱之外更好的解决方案。Rust平台主要有两个功能可以协同工作，为解决这些依赖问题提供基础，现在我们将分别研究并看看最终结果是怎样的。</p><h2>Cargo和Crates</h2><p>难题的第一部分当然是Cargo，Rust官方依赖管理器。Cargo类似于NPM或Maven之类的工具，并且有一些有趣的功能使它成为一个真正高质量的依赖管理器（这里我最喜欢的是<a href="https://getcomposer.org/" target="_blank" rel="noopener">Composer</a>，一个非常精心设计的PHP依赖管理器）。Cargo负责下载项目依赖的Rust库，称为<em>crates</em>，并协调调用Rust编译器以获得最终结果。</p><p><em>请注意，crates是编译器中的第一类构造。这在以后很重要。</em></p><p>与NPM和Composer一样，Cargo允许你根据<a href="https://semver.org/" target="_blank" rel="noopener">语义版本控制</a>的兼容性规则指定项目兼容的一系列依赖项版本。这允许你描述与你的代码兼容（或可能）兼容的一个或多个版本。例如，我可能会添加</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">log = <span class="string">"0.4.*"</span></span><br></pre></td></tr></table></figure><p>到<code>Cargo.toml</code>文件，表明我的代码适用于<code>0.4</code>系列中<code>log</code>包的任何补丁版本。也许在最终的应用程序中，我们得到了这个依赖树</p><p><img src="https://user-images.githubusercontent.com/3297411/56954708-07a1d180-6b72-11e9-84f5-4b33c8d71a57.png" alt="second"></p><p>因为在<code>my-project</code>中我声明了与<code>log</code>版本<code>0.4.*</code>的兼容性，我们可以安全地为<code>log</code>选择版本<code>0.4.4</code>，因为它满足所有要求。（如果<code>log</code>包遵循语义版本控制的原则，这个原则对于已发布的库而言并不总是如此，那么我们可以确信这个发布不包括任何会破坏我们代码的重大更改。）你可以在<a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html" target="_blank" rel="noopener">Cargo文档</a>中找到一个更好地解释版本范围以及它们如何应用于Cargo。</p><p>太棒了，所以我们可以选择满足<em>每个</em>项目版本要求的最新版本，而不是选择避开遇到版本冲突或只是选择更新的版本并祈祷。但是，如果我们遇到无法解决的问题，例如：</p><p><img src="https://user-images.githubusercontent.com/3297411/56954694-feb10000-6b71-11e9-977f-c938f7eadce1.png" alt="third"></p><p>没有可以选择满足所有要求的<code>log</code>版本！我们接下来做什么？</p><h2>名字修饰</h2><p>为了回答这个问题，我们需要讨论<em>名字修饰</em>。一般来说，名字修饰是一些编译器用于各种语言的过程，它将符号名称作为输入，并生成一个更简单的字符串作为输出，可用于在链接时消除类似命名符号的歧义。例如，Rust允许你在不同模块之间重用标识符：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> en &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">greet</span></span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> es &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">greet</span></span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Hola"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们有两个不同的函数，名为<code>greet()</code>，但当然这很好，因为它们在不同的模块中。这很方便，但通常应用程序二进制格式没有模块的概念；相反，所有符号都存在于单个全局命名空间中，非常类似于C中的名称。由于<code>greet()</code>在最终二进制文件中不能显示两次，因此编译器可能使用比源代码更明确的名称。例如：</p><ul><li><code>en::greet()</code>成为<code>en__greet</code></li><li><code>es::greet()</code>成为<code>es__greet</code></li></ul><p>问题解决了！只要我们确保这个名字修饰方案是确定性的并且在编译期间到处使用，代码就会知道如何获得正确的函数。</p><p>现在这不是一个完全完整的名字修饰方案，因为我们还没有考虑很多其他的东西，比如泛型类型参数，重载等等。此功能也不是Rust独有的，并且确实在C++和Fortran等语言中使用了很长时间。</p><p>名字修饰如何帮助Rust解决依赖地狱？这一切都在Rust的名字管理体系中，这似乎在我所研究的语言中相当独特。那么让我们来看看？</p><p>在Rust编译器中查找名字修饰的代码很简单；它位于一个名为<a href="https://github.com/rust-lang/rust/blob/0550766699a6602a51e361e8cb2825b540b7cce8/src/librustc_codegen_utils/symbol_names.rs" target="_blank" rel="noopener"><code>symbol_names.rs</code></a>的文件中。如果你想学习更多内容，我建议你阅读这个文件中的注释，但我会包括重点。似乎有四个基本组件包含在一个修饰符号名称中：</p><ul><li>符号的完全限定名称。</li><li>通用类型参数。</li><li>包含符号的crate的名称。（还记得crates在编译器中是一流的吗？）</li><li>可以通过命令行传入的任意“歧义消除器（disambiguator）”字符串。</li></ul><p>使用Cargo时，Cargo本身会将“歧义消除器”提供给编译器，所以让我们看一下<code>compilation_files.rs</code>包含的内容：</p><ul><li>包名字</li><li>包源</li><li>包版本</li><li>启用编译时功能</li><li><em>一堆</em>其他的东西</li></ul><p>这个复杂系统的最终结果是，即使是不同版本的crate中的相同功能也具有不同的修饰符号名称，因此只要每个组件知道要调用的函数版本，就可以在单个应用程序中共存。</p><h2>合在一起</h2><p>现在回到我们之前的“无法解决的”依赖图：</p><p><img src="https://user-images.githubusercontent.com/3297411/56954658-e7721280-6b71-11e9-8df8-aa5e6efa01f7.png" alt="forth"></p><p>借助依赖范围的强大功能，以及Cargo和Rust编译器协同工作，我们现在可以通过在我们的应用程序中包含<code>log 0.5.0</code>和<code>log 0.4.4</code>来实际解决此依赖关系图。<code>app</code>内部使用<code>log</code>的任何代码都将被编译以达到从<code>0.5.0</code>版生成的符号，而<code>my-project</code>中的代码将使用为<code>0.4.4</code>版生成的符号。</p><p>现在我们看到了大局，这实际上看起来非常直观，并解决了一大堆依赖问题，这些问题会困扰其他语言的用户。这个解决方案并不完美：</p><ul><li>由于不同版本生成不同的唯一标识符，因此我们无法在库的不同版本之间传递对象。例如，我们无法创建一个<code>log 0.5.0</code>的<code>LogLevel</code>并将其传递给<code>my-project</code>使用，因为它期望<code>LogLevel</code>来自<code>log 0.4.4</code>，并且它们必须被视为单独的类型。</li><li>对于库的每个实例，任何静态变量或全局状态都将被复制，如果没有一些特殊方法，它们就无法通信。</li><li>我们的二进制大小必然会因为我们应用程序中包含的库的每个实例而增加。</li></ul><p>由于这些缺点，Cargo仅在需要时才采用这种技术来解决依赖图。</p><p>为了解决一般用例，这些似乎值得为Rust做出权衡，但对于其他语言，采用这样的东西可能会更加困难。以Java为例，Java<em>严重</em>依赖于静态字段和全局状态，因此简单地大规模采用Rust的方法肯定会增加破坏代码的次数，而Rust则将全局状态限制在最低限度。这种设计也没有对在运行时或反射时加载任意库进行说明，这两者都是许多其他语言提供的流行功能。</p><h2>结论</h2><p>Rust在编译和打包方面的精心设计以（主要）无痛依赖管理的形式带来红利，这通常消除了可能成为开发人员在其他语言中最糟糕的噩梦的整类问题。当我第一次开始玩Rust的时候，我当然很喜欢我所看到的，深入了解内部，看到宏大的架构，周到的设计，以及合理的权衡取舍对我来说更令人印象深刻。这只是其中的一个例子。</p><p>即使你没有使用Rust，希望这会让你对依赖管理器，编译器以及他们必须解决的棘手问题给予新的重视。（虽然我鼓励你至少尝试一下Rust，当然…）</p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog" target="_blank" rel="noopener">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui" target="_blank" rel="noopener">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文：&lt;a href=&quot;https://stephencoakley.com/2019/04/24/how-rust-solved-dependency-hell&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;How Rust Solved Dependency Hell&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;每隔一段时间我就会参与一个关于依赖管理和版本的对话，通常是在工作中，其中会出现“依赖地狱”的主题。如果你对这个术语不熟悉，那么我建议你查一下。简要总结可能是：“处理应用程序依赖版本和依赖冲突所带来的挫败感”。带着这个，让我们先获得关于依赖解析的一些技术。&lt;/p&gt;
&lt;h2&gt;问题&lt;/h2&gt;
&lt;p&gt;在讨论包应该具有哪种依赖关系以及哪些依赖关系可能导致问题时，本主题通常会进入讨论。作为一个真实的例子，在 &lt;a href=&quot;https://www.widen.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Widen Enterprises&lt;/a&gt;，我们有一个内部的，可重用的Java框架，它由几个软件包组成，为我们提供了创建许多内部服务的基础（如果你愿意的话，微服务）。这很好，但是如果你想创建一个依赖于框架中某些东西的可重用共享代码库呢？如果你尝试在应用程序中使用这样的库，最终可能会得到如下依赖关系图：&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>word2vec理解思路</title>
    <link href="https://qiwihui.com/qiwihui-blog-66/"/>
    <id>https://qiwihui.com/qiwihui-blog-66/</id>
    <published>2019-04-16T01:18:21.000Z</published>
    <updated>2020-05-16T15:36:39.346Z</updated>
    
    <content type="html"><![CDATA[<p>本文归纳整理了一些论文和博客对word2vec的理解，以期理解word2vec。</p><h2>概述</h2><h3>语言表示：词向量</h3><ol><li><p>词的独热表示（One-Hot Representation）</p><p>缺点：</p><ul><li>容易受维数灾难的困扰；</li><li>不能很好地刻画词与词之间的相似性，任意两个词之间都是孤立的；</li></ul></li><li><p>词的分布式表示（Distributed Representation）</p><ol><li>基于矩阵的分布表示：比如，GloVe模型；</li><li>基于聚类的分布表示；</li><li>基于神经网络的分布表示，词嵌入；</li></ol></li></ol><a id="more"></a><h3>语言模型</h3><p>文法语言模型，统计语言模型</p><p>核心是上下文的表示以及上下文与目标词之间的关系的建模。</p><p>语言模型就是计算一个句子的概率大小的模型。一个句子的打分概率越高，越说明他是更合乎人说出来的自然句子。常见的统计语言模型有N元文法模型（N-gram Model），最常见的是unigram model、bigram model、trigram model等等。还有N-pos模型。</p><h3>词嵌入</h3><p>2001年，Bengio 等人正式提出神经网络语言模型（ Neural Network Language Model ，NNLM），该模型在学习语言模型的同时，也得到了词向量。所以请注意：<strong>词向量可以认为是神经网络训练语言模型的副产品</strong>。</p><p>做法：</p><p>1、将one-hot中的vector每一个元素由整形改为浮点型，变为整个实数范围的表示；2、将原来稀疏的巨大维度压缩 <strong>嵌入</strong> 到一个更小维度的空间。</p><h3>神经网络语言模型与word2vec</h3><h4>神经网络语言模型：</h4><p>a. Neural Network Language Model ，NNLMb. Log-Bilinear Language Model， LBLc. Recurrent Neural Network based Language Model，RNNLMd. Collobert 和 Weston 在2008 年提出的 C&amp;W 模型e. Mikolov 等人提出了 CBOW（ Continuous Bagof-Words，连续词袋模型）和 Skip-gram 模型</p><p>CBOW和Skip-gram：</p><ul><li>如果是用一个词语作为输入，来预测它周围的上下文，那这个模型叫做“Skip-gram 模型”；</li><li>而如果是拿一个词语的上下文作为输入，来预测这个词语本身，则是 “CBOW 模型”。</li></ul><h4>word2vec</h4><p>实现CBOW和Skip-gram语言模型的工具（正如C&amp;W模型的实现工具是SENNA）。</p><h3>CBOW和Skip-gram</h3><ol><li>原理</li><li>加速训练技巧：<ul><li>Negative Sample</li><li>Hierarchical Softmax</li></ul></li></ol><h2>应用</h2><p>文本分类，个性化推荐，广告点击等</p><h2>论文和文章</h2><ol><li>Mikolov 两篇原论文：<ul><li>Distributed Representations of Sentences and Documents</li><li>Efficient estimation of word representations in vector space</li></ul></li><li>Yoav Goldberg 的论文：word2vec Explained- Deriving Mikolov et al.’s Negative-Sampling Word-Embedding Method</li><li>Xin Rong 的论文：word2vec Parameter Learning Explained</li><li>来斯惟的博士论文：《基于神经网络的词和文档语义向量表示方法研究》以及<a href="http://licstar.NET" target="_blank" rel="noopener">博客</a></li><li><a href="https://www.zhihu.com/question/53011711" target="_blank" rel="noopener">word2vec 相比之前的 Word Embedding 方法好在什么地方？</a></li><li>Sebastian 的博客：『On word embeddings - Part 2: Approximating the Softmax』</li><li>《How to Generate a Good Word Embedding?》,Siwei Lai, Kang Liu, Liheng Xu, Jun Zhao</li><li>《面向自然语言处理的分布式表示学习》，邱锡鹏</li><li>《Deep Learning 实战之 word2vec》</li><li>一些博文：<ul><li><a href="http://www.cnblogs.com/iloveai/p/word2vec.html" target="_blank" rel="noopener">http://www.cnblogs.com/iloveai/p/word2vec.html</a></li><li><a href="http://www.hankcs.com/nlp/word2vec.html" target="_blank" rel="noopener">http://www.hankcs.com/nlp/word2vec.html</a></li><li><a href="http://licstar.NET/archives/328" target="_blank" rel="noopener">http://licstar.NET/archives/328</a></li><li><a href="https://zhuanlan.zhihu.com/p/22477976" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/22477976</a></li><li><a href="http://blog.csdn.Net/itplus/article/details/37969519" target="_blank" rel="noopener">http://blog.csdn.Net/itplus/article/details/37969519</a></li><li><a href="http://www.tuicool.com/articles/fmuyamf" target="_blank" rel="noopener">http://www.tuicool.com/articles/fmuyamf</a></li><li><a href="http://licstar.net/archives/620#comment-1542" target="_blank" rel="noopener">http://licstar.net/archives/620#comment-1542</a></li><li><a href="http://blog.csdn.net/ycheng_sjtu/article/details/48520293" target="_blank" rel="noopener">http://blog.csdn.net/ycheng_sjtu/article/details/48520293</a></li></ul></li></ol><h2>本文参考</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/32590428" target="_blank" rel="noopener">word embedding与word2vec: 入门词嵌入前的开胃菜</a></li><li><a href="https://zhuanlan.zhihu.com/p/26306795" target="_blank" rel="noopener">秒懂词向量Word2vec的本质</a></li><li><a href="https://zhuanlan.zhihu.com/p/29076736" target="_blank" rel="noopener">基于 word2vec 和 CNN 的文本分类 ：综述 &amp; 实践</a></li><li><a href="https://x-algo.cn/index.php/2016/03/12/281/" target="_blank" rel="noopener">word2vec在工业界的应用场景</a></li><li><a href="https://www.zhihu.com/question/25269336/answer/49188284" target="_blank" rel="noopener">word2vec有什么应用？ - orangeprince的回答 - 知乎</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文归纳整理了一些论文和博客对word2vec的理解，以期理解word2vec。&lt;/p&gt;
&lt;h2&gt;概述&lt;/h2&gt;
&lt;h3&gt;语言表示：词向量&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;词的独热表示（One-Hot Representation）&lt;/p&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容易受维数灾难的困扰；&lt;/li&gt;
&lt;li&gt;不能很好地刻画词与词之间的相似性，任意两个词之间都是孤立的；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;词的分布式表示（Distributed Representation）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于矩阵的分布表示：比如，GloVe模型；&lt;/li&gt;
&lt;li&gt;基于聚类的分布表示；&lt;/li&gt;
&lt;li&gt;基于神经网络的分布表示，词嵌入；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="深度学习" scheme="https://qiwihui.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>解决33问题──将33写成3个整数的立方和</title>
    <link href="https://qiwihui.com/qiwihui-blog-61/"/>
    <id>https://qiwihui.com/qiwihui-blog-61/</id>
    <published>2019-04-08T17:20:40.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章内容翻译自论文 <a href="https://arxiv.org/abs/1903.04284" target="_blank" rel="noopener">Cracking the problem with 33</a>，论文研究了方程 $x^3+y^3+z^3=k$ 在一些小的 $k$ 值的解，并首次将33写成了3个整数的立方和。完成中文可以查看项目 <a href="https://github.com/qiwihui/cracking-the-problem-with-33" target="_blank" rel="noopener">qiwihui/cracking-the-problem-with-33</a>。截止到目前，100以内的自然数就剩下42还没有找到关于立方和的整数解了！</p><blockquote><p>Answer to the Ultimate Question of Life, the Universe, and Everything. – 42</p></blockquote><a id="more"></a><p>以下是论文正文翻译：</p><hr><h1>解决33问题</h1><p>作者：ANDREW R. BOOKER</p><p><strong>摘要</strong> 受到Tim Browning和Brady Haran的<a href="https://www.youtube.com/channel/UCoxcjq-8xIDTYp3uz647V5A" target="_blank" rel="noopener">Numberphile</a>视频&quot;<a href="https://www.youtube.com/watch?v=wymmCdLdPvM" target="_blank" rel="noopener">未解决的33问题</a>&quot;的启发，我们研究了方程 $x^3+y^3+z^3=k$ 在一些小的 $k$ 值的解。 我们找到了 $k=33$的第一个已知解。</p><h2>1. 简介</h2><p>令 $k$ 为正整数，其中 $k \equiv ±4(\mod 9)$。 然后Heath-Brown<a href="#HB92">[HB92]</a> 推测 有无限多的三元组$(x，y，z) \in \mathbb{Z}^3$ 满足</p><p>$$k = x^3 + y^3 + z^3. \quad \text{(1)}$$</p><p>早在1954年就开始对（1）进行各种数值研究<a href="#MW55">[MW55]</a>；请参阅<a href="#BPTYJ07">[BPTYJ07]</a>，了解截至2000年的这些研究的历史。自那时起进行的计算由于Elkies <a href="#Elk00">[Elk00]</a>而被算法所主导。我们所知道的最新内容是Huisman<a href="#Hui16">[Hui16]</a> 的论文， 该论文确定了（1）的所有解，其中$k \le 1000$ 且 $\max{|x|,|y|,|z|}\le 10^15$。特别是，Huisman报告说除了13个 $k \le 1000$的值以外的所有解决方案都是已知的：</p><p>$$33, 42, 114, 165, 390, 579, 627, 633, 732, 795, 906, 921, 975. \quad \text{(2)}$$</p><p>Elkies的算法通过使用格基减少（lattice basis reduction）在Fermat曲线$X^3+Y^3=1$ 附近寻找有理点来工作；它非常适合同时找到许多 $k$ 值的解。在本文中，我们描述了一种在k值确定时更有效的不同方法。它的优点是可以找到所有具有 <em>最小</em>坐标界限的解，而不是Elkies算法中的最大坐标。这总是产生搜索范围的非平凡的扩张（nontrivialexpansion），因为除了可以单独考虑的有限多个例外之外，还有</p><p>$$\max {|x|,|y|,|z|} &gt; \sqrt[3]{2} \min {|x|,|y|,|z|}$$</p><p>此外，根据经验，通常情况是其中一个变量比其他变量小得多，因此我们希望实际上增益更大。</p><p>我们的策略类似于一些早期的方法（特别参见<a href="#HBLtR93">[HBLtR93]</a>，<a href="#Bre95">[Bre95]</a>，<a href="#KTS97">[KTS97]</a>和 <a href="#BPTYJ07">[BPTYJ07]</a>）， 并且基于观察：$k-z^3=x^3+y^3$的任何解都具有 $x+y$ 作为一个因子。相对于早期研究，我们的主要贡献是注意到，通过一些时间空间权衡，运行时间在高度边界内非常接近线性，并且在现代64位计算机上实现时非常实用。</p><p>更详细地说，假设 $(x，y，z)$ 是（1）的解，并且不失一般性，假设$|x| \ge |y| \ge |z|$。 然后我们有</p><p>$$k-z^{3}=x^{3}+y^{3}=(x+y)(x^{2}-x y+y^{2})$$</p><p>如果 $k-z^3=0$ 则 $y=-x$，并且 $x$ 的每个值都产生一个解。 否则，设$d=|x+y|=|x|+y \operatorname{sgn} x$， 我们看到 $d$ 可以除 $|k-z^3|$并且</p><p>$$\begin{aligned}\begin{aligned}\frac{\left|k-z^{3}\right|}{d} &amp;=x^{2}-x y+y^{2}=x(2 x-(x+y))+y^{2} \&amp;=|x|(2|x|-d)+(d-|x|)^{2}=3 x^{2}-3 d|x|+d^{2}\end{aligned}\end{aligned}$$</p><p>得到</p><p>$${x, y}=\left{\frac{1}{2} \operatorname{sgn}\left(k-z^{3}\right)\left(d \pm \sqrt{\frac{4|k-z^{3}|-d^{3}}{3 d}}\right)\right}$$</p><p>因此，给定 $z$ 的候选值，通过遍历 $|k-z^3|$ 的所有除数，有一个有效的程序来查找 $x$ 和 $y$ 的所有相应值。这个基本算法在假设整数分解的时间复杂度的标准启发式（standardheuristics）下，已经能在 时间 $O(B^{1+\varepsilon})$ 内找到满足$\min{|x|,|y|,|z|}\ge B$ 的所有解。在下一节中，我们将解释如何避免因子分解并更有效地实现相同目的。</p><p><strong>感谢</strong> 感谢Roger Heath-Brown提供了有用的意见和建议。</p><h2>2. 方法</h2><p>为了便于表示，我们假设$k \equiv ±3(\mod 9)$；请注意，这适用于（2）中的所有 $k$。由于上述基本算法对于寻找小解是合理的，因此我们将假设 $|z|&gt;\sqrt{k}$。此外，如果我们将（1）专门用于 $y=z$ 的解，那么我们得到Thue方程$x^3+2y^3=k$，这是有效可解的。 使用 PARI/GP<a href="#The18">[The18]</a> 中的Thue求解器，我们验证了（2）中的 $k$不存在这样的解。 因此，我们可以进一步假设 $y \ne z$。</p><p>由于 $|z|&gt;\sqrt{k} \ge \sqrt[3]{k}$，我们有</p><p>$$\operatorname{sgn} z=-\operatorname{sgn}(k-z^{3})=-\operatorname{sgn}(x^{3}+y^{3})=-\operatorname{sgn} x.$$</p><p>同样，因为 $x^3 + z^3 = k-y^3$ 和 $|y|\ge |z|$， 我们有$\operatorname{sgn} y=-\operatorname{sgn} x=\operatorname{sgn} z$。将（1）的两边乘以 $-\operatorname{sgn} z$，我们得到</p><p>$$|x|^{3}-|y|^{3}-|z|^{3}=-k \operatorname{sgn} z \quad \text{(4)}$$</p><p>令 $\alpha=\sqrt[3]{2}-1$，并且 $d=|x+y|=|x|-|y|$。 如果$d \ge \alpha |z|$ 则</p><p>$$\begin{aligned}\begin{aligned}-k \operatorname{sgn} z &amp;=|x|^{3}-|y|^{3}-|z|^{3} \geq(|y|+\alpha|z|)^{3}-|y|^{3}-|z|^{3} \&amp;=3 \alpha(\alpha+2)(|y|-|z|) z^{2}+3 \alpha(|y|-|z|)^{2}|z| \&amp; \geq 3 \alpha(\alpha+2)|y-z| z^{2}\end{aligned}\end{aligned}$$</p><p>由于 $3 \alpha(\alpha+2)&gt;1$， 这与我们的假设不相容，即 $y \ne z$ 和$|z|&gt;\sqrt{k}$。 因此我们必然有 $0&lt;d&lt;\alpha|z|$。</p><p>接下来，减少（4）模3并回想我们的假设 $k \equiv ±3(\mod 9)$，我们有</p><p>$$d=|x|-|y| \equiv|z| \quad(\mod 3).$$</p><p>设 $\epsilon\in{±1}$ 使得 $k \equiv 3 \epsilon(\mod 9)$。然后，由于每个立方数都与 $0$ 或 $±1(mod 9)$ 相等， 我们必然有$x \equiv y \equiv z \equiv \epsilon(\mod 3)$， 因此$\operatorname{sgn} z=\epsilon(\frac{|z|}{3})=\epsilon(\frac{d}{3})$。基于（3），当且仅当 $d | z^{3}-k$ 以及$3d(4|z^{3}-k|-d^3) = 3d(4\epsilon(\frac{d}{3})(z^{3}-k)-d^{3})$是平方数时， 我们得到（1）的解。</p><p>总之，找到（1）的所有解并且满足$|x| \ge |y| \ge |z|&gt;\sqrt{k}$，$y \ne z$ 和$|z|\le B$，对于每个与3互质的 $d\in\mathbb{Z}\cap(0,\alpha B)$，解决以下系统就足够了：</p><p>$$\begin{aligned}\begin{aligned}&amp;{\frac{d}{\sqrt[3]{2}-1}&lt;|z| \le B, \quad \operatorname{sgn} z=\epsilon\left(\frac{d}{3}\right), \quad z^{3} \equiv k \quad(\mod d)} \&amp;{3 d\left(4 \epsilon\left(\frac{d}{3}\right)(z^{3}-k)-d^{3}\right)=\square} &amp; \text{(5)}\end{aligned}\end{aligned}$$</p><p>我们解决这个问题的方法很简单：我们通过它们的主要因子分解递归地计算 $d$的值， 并应用中国剩余定理来将 $z^{3} \equiv k(\mod d)$的解减少到素数模幂的情况下， 其中标准算法可以适用。设$r_{d}(k)=# \left{z(\mod d):z^{3} \equiv k(\mod d)\right}$ 表示 $k$ 模 $d$的立方根数。通过标准分析估计，由于 $k$ 不是立方数，我们有</p><p>$$\sum_{d \le \alpha B} r_{d}(k) \ll_{k} B$$</p><p>启发式地，计算对所有素数 $p\le \alpha B$ 的 $z^{3} \equiv k(\mod p)$的解 可以用 $[0, \alpha B]$ 上的整数在 $O(B)$ 算术运算来完成； 见例如[<a href="#NZM91">[NZM91]</a>，§2.9，练习8]中描述的算法。假设这一点，可以看出，使用Montgomery的批量反转技巧[<a href="#Mon87">[Mon87]</a>，§10.3.1]，计算对所有正整数$p\le \alpha B$ 的 $z^{3} \equiv k(\mod p)$ 的根的剩余工作可以再次用$O(B)$ 算术运算完成。</p><p>因此，我们可以在线性时间内计算满足（5）的第一行的所有 $z$，作为算术进展（arithmeticprogressions）的并集。为了检测最后一行的解，有一个快速的方法来确定$\Delta :=3d\left(4\epsilon(\frac{d}{3})(z^{3}-k)-d^{3}\right)$是一个平方数 至关重要。我们首先注意到对于固定$d$，这种情况减少到在椭圆曲线上找到积分点； 特别是，令 $X=12d|z|$ 和$Y=(6d^2|x-y|$，从（3）中我们看到（X，Y）位于Mordell曲线上</p><p>$$Y^{2}=X^{3}-2(6 d)^{3}\left(d^{3}+4 \epsilon\left(\frac{d}{3}\right) k\right). \quad \text{(6)}$$</p><p>因此，对于固定 $d$，存在至多有限多个解，并且它们可以被有效地约束。 对于$d$的一些小值，找到（6）上的所有积分点并检查是否产生任何满足（1）的解是切实可行的。例如，使用Magma[<a href="#BCFS18">[BCFS18]</a>，§128.2.8]中的积分点函数（functionality），我们验证了如（2）中的 $k$ 和 $d \le 40$ 情况下没有解， 除了$(k, d)\in{(579,29),(579,34),(975,22)}$。</p><p>接下来我们自然注意到一些同余和可分性约束：</p><p><strong>引理</strong> 设 $z$ 为（5）的解，设 $p$ 为素数， 设$s=ord_p d$，$t=ord_p(z^3-k)$。则</p><p>(i) $z \equiv \frac{4}{3} k\left(2-d^{2}\right)+9(k+d)(\mod 18)$；(ii) 如果 $p \equiv 2 (\mod 3)$ 则 $t \le 3s$；(iii) 如果 $t \le 3s$ 则 $s \equiv t (\mod 2)$；(iv) 如果 $ord_p k \in {1,2}$ 则 $s \in {0,ord_p k}$。</p><p><em>证明</em> 令 $\Delta=3d\left(4\epsilon(\frac{d}{3})(z^3-k)-d^3\right)$， 令$\delta=(\frac{d}{3})$，我们有 $|z| \equiv d \equiv \delta(\mod 3)$，观察到 $(\delta+3 n)^{3} \equiv \delta+9 n(\mod 27)$，模27，我们有</p><p>$$\begin{aligned}\begin{aligned}\frac{\Delta}{3 d} &amp;=4 \epsilon \delta\left(z^{3}-k\right)-d^{3}=4|z|^{3}-d^{3}-4 \epsilon \delta k \&amp; \equiv 4[\delta+3(|z|-\delta)]-[\delta+3(d-\delta)]-4 \epsilon \delta k=3(4|z|-d)-\delta[18+4(\epsilon k-3)] \&amp; \equiv 3(4|z|-d)-d[18+4(\epsilon k-3)]=12|z|-9 d-4 \epsilon d k \&amp; \equiv 3|z|-4 \epsilon d k\end{aligned}\end{aligned}$$</p><p>这消失了模9，所以为了使 $\Delta$ 成为平方数，它也必须消除mod 27。 于是</p><p>$$z=\epsilon \delta|z| \equiv \frac{4 \delta d k}{3} \equiv \frac{4(2-d^{2}) k}{3} \quad(\mod 9)$$</p><p>减少（1）模2我们得到 $z \equiv k+d(\mod 2)$，这得到（i）。</p><p>接下来设 $u=p^{-s} d$ 和 $v=p^{-t} \epsilon \delta(z^{3}-k)$，这样就有</p><p>$$\Delta=3\left(4 p^{s+t} u v-p^{4 s} u^{4}\right)$$</p><p>如果 $3s&lt;t$ 则 $p^{-4 s} \Delta \equiv-3 u^{4}(\mod 4 p)$， 但是当$p \equiv 2(\mod 3)$ 时这是不可能的，因为 $-3$ 不是 $4p$ 的平方模。因此，在这种情况下我们必须 $t&lt;3s$。</p><p>接下来假设 $t&lt;3s$。 我们考虑以下情况，涵盖所有可能性：</p><ul><li>若 $p = 3$ 则 $s = t = 0$，那么 $s \equiv t(\bmod 2)$。</li><li>若 $p \ne 3$ 且 $3s &gt; t+2 \operatorname{ord}<em>{p} 2$， 则 $\operatorname{ord}</em>{p} \Delta=s+t+2 \operatorname{ord}_{p} 2$，那么 $s \equiv t(\mod 2)$。</li><li>若 $3s\in{t, t+2}$ 则 $s \equiv t(\bmod 2)$。</li><li>如果 $p=2$ 且 $3s = t + 1$ 则 $2^{-4 s} \Delta=3(2 u v-u^{4}) \equiv 3(\bmod 4)$，这是不可能的。</li></ul><p>因此，在任何情况我们得出结论 $s \equiv t(\mod 2)$。</p><p>最后，假设 $p|k$ 和 $p \not | 3k$。如果 $s=0$则无需证明的，所以假设不然。 由于 $d | z^{3}-k$，我们必须有$d | k$，因为</p><p>$$0 &lt; s \le t=\operatorname{ord}<em>{p}(z^{3}-k)=\operatorname{ord}</em>{p} k&lt;3 s$$</p><p>通过部分（iii）得出 $s \equiv \operatorname{ord}<em>{p} k(\mod 2)$， 因此$s=\operatorname{ord}</em>{p} k$。</p><p>因此，一旦 $z(\mod d)$ 的残差类（residue class）固定， 则其残差模$lcm(d,18)$ 是确定的。还要注意，条件（ii）和（iii）对于测试 $p=2$是有效的。</p><p>然而，即使有这些优化，也有 $\ll B\log B$ 对 $d, z$满足（5）的第一行和引理的结论（i）和（iv）。 因此，为了实现比$O(B\log B)$ 更好的运行时间，需要从一开始就消除一些 $z$ 值。我们通过标准的时间空间交换来实现这一目标。确切地说，设置$P=3(\log \log B)(\log \log \log B)$， 并且让$M=\prod_{5 \le p \le P} p$ 是区间 $[5, P]$ 之间的素数的乘积。根据素数定理，我们得到 $\log M=(1+o(1)) P$。如果 $\Delta$ 是平方数，那么对于任意素数 $p|M$ 我们有</p><p>$$\left(\frac{\Delta}{p}\right)=\left(\frac{3 d}{p}\right)\left(\frac{|z|^{3}-c}{p}\right) \in{0,1} \quad \text{(7)}$$</p><p>其中 $c \equiv \epsilon\left(\frac{d}{3}\right) k+\frac{d^{3}}{4}$。 当$\operatorname{lcm}(d, 18) \le \alpha B / M$ 时， 我们首先为每个残差类$|z|(\bmod M)$ 计算该函数， 并且仅选择对于每个 $p|M$满足（7）的那些残基。 由Hasse约束，允许的残差的数量最多为</p><p>$$\frac{M}{2^{\omega(M /(M, d))}} \prod_{p | \frac{M}{(M, d)}}\left(1+O\left(\frac{1}{\sqrt{p}}\right)\right)=\frac{M}{2^{\omega(M /(M, d))}} e^{O(\sqrt{P} / \log P)}$$</p><p>因此，要考虑的 $z$ 值的总数最多为</p><p>$$\begin{aligned}\begin{array}{l}{\sum_{\operatorname{lcm}(d, 18) \le \frac{\alpha B}{M}} r_{d}(k)\left[M+\frac{e^{O(\sqrt{P} / \log P)}}{2^{\omega(M /(M, d))}} \frac{\alpha B}{d}\right] +\sum_{d \le \alpha B, {lcm}(d, 18) \le \frac{\alpha B}{M}} \frac{r_{d}(k) \alpha B}{d}} \{\ll_{k} B \log M+\frac{e^{O(\sqrt{P} / \log P)}}{2^{\omega(M)}} \sum_{g | M} \frac{2^{\omega(g)} r_{g}(k)}{g} \sum_{d^{\prime} \le \frac{\alpha B}{9 g M}} \frac{r_{d^{\prime}}(k) \alpha B}{d^{\prime}}} \{\ll_{k} B \log M+B \log B \frac{e^{O(\sqrt{P} / \log P)}}{2^{\omega(M)}} \prod_{p | M}\left(1+\frac{2 r_{p}(k)}{p}\right)} \{\ll B P+\frac{B \log B}{2^{(1+o(1)) P / \log P}} \ll B(\log \log B)(\log \log \log B)}\end{array}\end{aligned}$$</p><p>对于没有以这种方式消除的 $z$，我们遵循类似的策略， 其中一些其他辅助模$M^{\prime}$ 由较大的素数组成，以加速平方测试。 我们预先计算模为$M^{\prime}$ 的立方数表和Legendre符号模 $p|M^{\prime}$，因此将测试（7）简化为了表查找。只有当所有这些测试都通过时，我们才能在多精度算术中计算 $\Delta$并应用一般的平方检验，这种情况对于一小部分候选值来说都是如此。事实上，我们期望Legendre测试的数量平均有限，所以总的来说，找到所有解决方案的 $|z| \le B$ 应该要求不超过$O_k(B(\log \log B)(\log \log \log B))$ 次表查找和对 $[0, B]$中整数的算术运算。</p><p>因此，当 $B$符合机器字大小时，我们预计运行时间几乎是线性的，这就是我们在实践中观察到的$B&lt;2^{64}$。</p><h2>3. 实现</h2><p>我们在C中实现了上述算法，其中有一些内联汇编程序来源于由Ben Buhrow<a href="#Buh19">[Buh19]</a> 编写的Montgomery算法<a href="#Mon85">[Mon85]</a>， 以及Kim Walisch的用于枚举素数的<strong>primesieve</strong> 库 <a href="#Wal19">[Wal19]</a>。</p><p>该算法自然地在具有超过 $\sqrt{\alpha B}$ 的素因子和 具有$\sqrt{\alpha B}$ -平滑的素数的 $d$ 的值之间分配。 前一组 $d$消耗超过运行时间的三分之二，但更容易并行化。我们在布里斯托大学高级计算研究中心的大规模并行集群Bluecrystal Phase3上运行了这一部分。 对于平滑的$d$，我们使用了一个单独的32核和64核节点的小集群。</p><p>我们搜索了满足 $k \in {33,42}$ 和 $\min{|x|, |y|, |z|} \le 10^16$的（1）的解，找到了以下结果：</p><p>$$33 = 8 866 128 975 287 528^3 +（-8 778 405 442 862 239)^3 +（-2 736 111 468 807 040)^3$$</p><p>总计算在三个星期的实际时间中大约使用了15个核年。</p><h2>参考文献</h2><p>（略）</p><p>School of Mathematics, University of Bristol, University Walk, Bristol,BS8 1TW, United Kingdom</p><p>E-mail address: <a href="mailto:andrew.booker@bristol.ac.uk" target="_blank" rel="noopener">andrew.booker@bristol.ac.uk</a></p><hr><h2>博客参考：</h2><ul><li><a href="http://www.duodaa.com/blog/index.php/archives/1857/" target="_blank" rel="noopener">人类第一次将33写成了3个整数的立方和</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章内容翻译自论文 &lt;a href=&quot;https://arxiv.org/abs/1903.04284&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cracking the problem with 33&lt;/a&gt;，论文研究了方程 $x^3+y^3+z^3=k$ 在一些小的 $k$ 值的解，并首次将33写成了3个整数的立方和。完成中文可以查看项目 &lt;a href=&quot;https://github.com/qiwihui/cracking-the-problem-with-33&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;qiwihui/cracking-the-problem-with-33&lt;/a&gt;。截止到目前，100以内的自然数就剩下42还没有找到关于立方和的整数解了！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Answer to the Ultimate Question of Life, the Universe, and Everything. – 42&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="数学" scheme="https://qiwihui.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>赴日单次旅行签证申请记录</title>
    <link href="https://qiwihui.com/qiwihui-blog-59/"/>
    <id>https://qiwihui.com/qiwihui-blog-59/</id>
    <published>2019-03-10T07:43:06.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>这次赴日旅行，计划大阪奈良和东京，简单记录行前准备。</p><a id="more"></a><h2>签证所需材料</h2><p>以下材料为本次申请签证所需材料：</p><p>主申人：</p><ol><li>本人护照，原件（有效期至少在6个月以上）；</li><li>签证申请表：1份；</li><li>个人信息处理同意书：1份；</li><li>本人照片：2张，4.5*4.5cm白底彩色近照（现照，相片可淡妆）；</li><li>本人身份证正反复印件：1份；</li><li>户口本复印件：1份，户口本首页和本人页；</li><li>本人在职证明：1份，盖公司的公章；</li><li>企业营业执照副本复印件：1份；</li><li>经济证明材料：一年的工资流水账单，每个月存折上的大于8000，且近一年银行流水10万元以上；</li><li>结婚证复印件：1份。</li></ol><p>随行：</p><ol><li>本人护照，原件（有效期至少在6个月以上）；</li><li>签证申请表：1份；</li><li>个人信息处理同意书：1份；</li><li>本人照片：2张，4.5*4.5cm白底彩色近照（现照，相片可淡妆）；</li><li>本人身份证正反复印件：1份；</li><li>户口本复印件：1份，户口本首页和本人页；</li><li>结婚证复印件：1份。</li></ol><p>因为选择的代办旅行社没有要求赴日行程和机票酒店预订记录，所以没有提供。</p><h2>提前购买或预订的物品</h2><ol><li>机票，酒店预订；</li><li>通信：日本流量卡（也可以使用随身wifi或者办理电话卡国际套餐）；</li><li>预订和服体验；</li><li>预订东京迪斯尼海洋馆门票；</li><li>车票基本都在当地购买了，没有提前预订。</li></ol><p>最后，最最重要的，就是开心就好，不用太拘泥于景点有没有都游览一遍。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次赴日旅行，计划大阪奈良和东京，简单记录行前准备。&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="https://qiwihui.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>使用 TensorFlow Serving 和 Docker 快速部署机器学习服务</title>
    <link href="https://qiwihui.com/qiwihui-blog-58/"/>
    <id>https://qiwihui.com/qiwihui-blog-58/</id>
    <published>2019-03-03T01:00:06.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>从实验到生产，简单快速部署机器学习模型一直是一个挑战。这个过程要做的就是将训练好的模型对外提供预测服务。在生产中，这个过程需要可重现，隔离和安全。这里，我们使用基于Docker的TensorFlow Serving来简单地完成这个过程。TensorFlow 从1.8版本开始支持Docker部署，包括CPU和GPU，非常方便。</p><h2>获得训练好的模型</h2><p>获取模型的第一步当然是训练一个模型，但是这不是本篇的重点，所以我们使用一个已经训练好的模型，比如ResNet。TensorFlow Serving 使用SavedModel这种格式来保存其模型，SavedModel是一种独立于语言的，可恢复，密集的序列化格式，支持使用更高级别的系统和工具来生成，使用和转换TensorFlow模型。这里我们直接下载一个预训练好的模型：</p><a id="more"></a><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir /tmp/resnet</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -s https://storage.googleapis.com/download.tensorflow.org/models/official/20181001_resnet/savedmodels/resnet_v2_fp32_savedmodel_NHWC_jpg.tar.gz | tar --strip-components=2 -C /tmp/resnet -xvz</span></span><br></pre></td></tr></table></figure><p>如果是使用其他框架比如Keras生成的模型，则需要将模型转换为SavedModel格式，比如：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> backend <span class="keyword">as</span> K</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line"><span class="comment"># 中间省略模型构建</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型转换为SavedModel</span></span><br><span class="line">signature = tf.saved_model.signature_def_utils.predict_signature_def(</span><br><span class="line">    inputs=&#123;<span class="string">'input_param'</span>: model.input&#125;, outputs=&#123;<span class="string">'type'</span>: model.output&#125;)</span><br><span class="line">builder = tf.saved_model.builder.SavedModelBuilder(<span class="string">'/tmp/output_model_path/1/'</span>)</span><br><span class="line">builder.add_meta_graph_and_variables(</span><br><span class="line">    sess=K.get_session(),</span><br><span class="line">    tags=[tf.saved_model.tag_constants.SERVING],</span><br><span class="line">    signature_def_map=&#123;</span><br><span class="line">        tf.saved_model.signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY:</span><br><span class="line">            signature</span><br><span class="line">    &#125;)</span><br><span class="line">builder.save()</span><br></pre></td></tr></table></figure><p>下载完成后，文件目录树为：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tree /tmp/resnet</span></span><br><span class="line">/tmp/resnet</span><br><span class="line">└── 1538687457</span><br><span class="line">    ├── saved_model.pb</span><br><span class="line">    └── variables</span><br><span class="line">        ├── variables.data-00000-of-00001</span><br><span class="line">        └── variables.index</span><br></pre></td></tr></table></figure><h2>部署模型</h2><p>使用Docker部署模型服务：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker pull tensorflow/serving</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -p 8500:8500 -p 8501:8501 --name tfserving_resnet \</span></span><br><span class="line">--mount type=bind,source=/tmp/resnet,target=/models/resnet \</span><br><span class="line">-e MODEL_NAME=resnet -t tensorflow/serving</span><br></pre></td></tr></table></figure><p>其中，<code>8500</code>端口对于TensorFlow Serving提供的gRPC端口，<code>8501</code>为REST API服务端口。<code>-e MODEL_NAME=resnet</code>指出TensorFlow Serving需要加载的模型名称，这里为<code>resnet</code>。上述命令输出为</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2019-03-04 02:52:26.610387: I tensorflow_serving/model_servers/server.cc:82] Building single TensorFlow model file config:  model_name: resnet model_base_path: /models/resnet</span><br><span class="line">2019-03-04 02:52:26.618200: I tensorflow_serving/model_servers/server_core.cc:461] Adding/updating models.</span><br><span class="line">2019-03-04 02:52:26.618628: I tensorflow_serving/model_servers/server_core.cc:558]  (Re-)adding model: resnet</span><br><span class="line">2019-03-04 02:52:26.745813: I tensorflow_serving/core/basic_manager.cc:739] Successfully reserved resources to load servable &#123;name: resnet version: 1538687457&#125;</span><br><span class="line">2019-03-04 02:52:26.745901: I tensorflow_serving/core/loader_harness.cc:66] Approving load for servable version &#123;name: resnet version: 1538687457&#125;</span><br><span class="line">2019-03-04 02:52:26.745935: I tensorflow_serving/core/loader_harness.cc:74] Loading servable version &#123;name: resnet version: 1538687457&#125;</span><br><span class="line">2019-03-04 02:52:26.747590: I external/org_tensorflow/tensorflow/contrib/session_bundle/bundle_shim.cc:363] Attempting to load native SavedModelBundle in bundle-shim from: /models/resnet/1538687457</span><br><span class="line">2019-03-04 02:52:26.747705: I external/org_tensorflow/tensorflow/cc/saved_model/reader.cc:31] Reading SavedModel from: /models/resnet/1538687457</span><br><span class="line">2019-03-04 02:52:26.795363: I external/org_tensorflow/tensorflow/cc/saved_model/reader.cc:54] Reading meta graph with tags &#123; serve &#125;</span><br><span class="line">2019-03-04 02:52:26.828614: I external/org_tensorflow/tensorflow/core/platform/cpu_feature_guard.cc:141] Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX2 FMA</span><br><span class="line">2019-03-04 02:52:26.923902: I external/org_tensorflow/tensorflow/cc/saved_model/loader.cc:162] Restoring SavedModel bundle.</span><br><span class="line">2019-03-04 02:52:28.098479: I external/org_tensorflow/tensorflow/cc/saved_model/loader.cc:138] Running MainOp with key saved_model_main_op on SavedModel bundle.</span><br><span class="line">2019-03-04 02:52:28.144510: I external/org_tensorflow/tensorflow/cc/saved_model/loader.cc:259] SavedModel load for tags &#123; serve &#125;; Status: success. Took 1396689 microseconds.</span><br><span class="line">2019-03-04 02:52:28.146646: I tensorflow_serving/servables/tensorflow/saved_model_warmup.cc:83] No warmup data file found at /models/resnet/1538687457/assets.extra/tf_serving_warmup_requests</span><br><span class="line">2019-03-04 02:52:28.168063: I tensorflow_serving/core/loader_harness.cc:86] Successfully loaded servable version &#123;name: resnet version: 1538687457&#125;</span><br><span class="line">2019-03-04 02:52:28.174902: I tensorflow_serving/model_servers/server.cc:286] Running gRPC ModelServer at 0.0.0.0:8500 ...</span><br><span class="line">[warn] getaddrinfo: address family for nodename not supported</span><br><span class="line">2019-03-04 02:52:28.186724: I tensorflow_serving/model_servers/server.cc:302] Exporting HTTP/REST API at:localhost:8501 ...</span><br><span class="line">[evhttp_server.cc : 237] RAW: Entering the event loop ...</span><br></pre></td></tr></table></figure><p>我们可以看到，TensorFlow Serving使用<code>1538687457</code>作为模型的版本号。我们使用curl命令来查看一下启动的服务状态，也可以看到提供服务的模型版本以及模型状态。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl http://localhost:8501/v1/models/resnet</span></span><br><span class="line">&#123;</span><br><span class="line"> "model_version_status": [</span><br><span class="line">  &#123;</span><br><span class="line">   "version": "1538687457",</span><br><span class="line">   "state": "AVAILABLE",</span><br><span class="line">   "status": &#123;</span><br><span class="line">    "error_code": "OK",</span><br><span class="line">    "error_message": ""</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>查看模型输入输出</h2><p>很多时候我们需要查看模型的输出和输出参数的具体形式，TensorFlow提供了一个<code>saved_model_cli</code>命令来查看模型的输入和输出参数：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> saved_model_cli show --dir /tmp/resnet/1538687457/ --all</span></span><br><span class="line"></span><br><span class="line">MetaGraphDef with tag-set: 'serve' contains the following SignatureDefs:</span><br><span class="line"></span><br><span class="line">signature_def['predict']:</span><br><span class="line">  The given SavedModel SignatureDef contains the following input(s):</span><br><span class="line">    inputs['image_bytes'] tensor_info:</span><br><span class="line">        dtype: DT_STRING</span><br><span class="line">        shape: (-1)</span><br><span class="line">        name: input_tensor:0</span><br><span class="line">  The given SavedModel SignatureDef contains the following output(s):</span><br><span class="line">    outputs['classes'] tensor_info:</span><br><span class="line">        dtype: DT_INT64</span><br><span class="line">        shape: (-1)</span><br><span class="line">        name: ArgMax:0</span><br><span class="line">    outputs['probabilities'] tensor_info:</span><br><span class="line">        dtype: DT_FLOAT</span><br><span class="line">        shape: (-1, 1001)</span><br><span class="line">        name: softmax_tensor:0</span><br><span class="line">  Method name is: tensorflow/serving/predict</span><br><span class="line"></span><br><span class="line">signature_def['serving_default']:</span><br><span class="line">  The given SavedModel SignatureDef contains the following input(s):</span><br><span class="line">    inputs['image_bytes'] tensor_info:</span><br><span class="line">        dtype: DT_STRING</span><br><span class="line">        shape: (-1)</span><br><span class="line">        name: input_tensor:0</span><br><span class="line">  The given SavedModel SignatureDef contains the following output(s):</span><br><span class="line">    outputs['classes'] tensor_info:</span><br><span class="line">        dtype: DT_INT64</span><br><span class="line">        shape: (-1)</span><br><span class="line">        name: ArgMax:0</span><br><span class="line">    outputs['probabilities'] tensor_info:</span><br><span class="line">        dtype: DT_FLOAT</span><br><span class="line">        shape: (-1, 1001)</span><br><span class="line">        name: softmax_tensor:0</span><br><span class="line">  Method name is: tensorflow/serving/predict</span><br></pre></td></tr></table></figure><p>注意到<code>signature_def</code>，<code>inputs</code>的名称，类型和输出，这些参数在接下来的模型预测请求中需要。</p><h2>使用模型接口预测：REST和gRPC</h2><p>TensorFlow Serving提供REST API和gRPC两种请求方式，接下来将具体这两种方式。</p><h3>REST</h3><p>我们下载一个客户端脚本，这个脚本会下载一张猫的图片，同时使用这张图片来计算服务请求时间。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -o /tmp/resnet/resnet_client.py https://raw.githubusercontent.com/tensorflow/serving/master/tensorflow_serving/example/resnet_client.py</span></span><br></pre></td></tr></table></figure><p>以下脚本使用<code>requests</code>库来请求接口，使用图片的base64编码字符串作为请求内容，返回图片分类，并计算了平均处理时间。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># The server URL specifies the endpoint of your server running the ResNet</span></span><br><span class="line"><span class="comment"># model with the name "resnet" and using the predict interface.</span></span><br><span class="line">SERVER_URL = <span class="string">'http://localhost:8501/v1/models/resnet:predict'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The image URL is the location of the image we should send to the server</span></span><br><span class="line">IMAGE_URL = <span class="string">'https://tensorflow.org/images/blogs/serving/cat.jpg'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="comment"># Download the image</span></span><br><span class="line">  dl_request = requests.get(IMAGE_URL, stream=<span class="literal">True</span>)</span><br><span class="line">  dl_request.raise_for_status()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Compose a JSON Predict request (send JPEG image in base64).</span></span><br><span class="line">  jpeg_bytes = base64.b64encode(dl_request.content).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">  predict_request = <span class="string">'&#123;"instances" : [&#123;"b64": "%s"&#125;]&#125;'</span> % jpeg_bytes</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Send few requests to warm-up the model.</span></span><br><span class="line">  <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    response = requests.post(SERVER_URL, data=predict_request)</span><br><span class="line">    response.raise_for_status()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Send few actual requests and report average latency.</span></span><br><span class="line">  total_time = <span class="number">0</span></span><br><span class="line">  num_requests = <span class="number">10</span></span><br><span class="line">  <span class="keyword">for</span> _ <span class="keyword">in</span> range(num_requests):</span><br><span class="line">    response = requests.post(SERVER_URL, data=predict_request)</span><br><span class="line">    response.raise_for_status()</span><br><span class="line">    total_time += response.elapsed.total_seconds()</span><br><span class="line">    prediction = response.json()[<span class="string">'predictions'</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">  print(<span class="string">'Prediction class: &#123;&#125;, avg latency: &#123;&#125; ms'</span>.format(</span><br><span class="line">      prediction[<span class="string">'classes'</span>], (total_time*<span class="number">1000</span>)/num_requests))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  main()</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python resnet_client.py</span></span><br><span class="line">Prediction class: 286, avg latency: 210.12310000000002 ms</span><br></pre></td></tr></table></figure><h3>gRPC</h3><p>让我们下载另一个客户端脚本，这个脚本使用gRPC作为服务，传入图片并获取输出结果。这个脚本需要安装<code>tensorflow-serving-api</code>这个库。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -o /tmp/resnet/resnet_client_grpc.py https://raw.githubusercontent.com/tensorflow/serving/master/tensorflow_serving/example/resnet_client_grpc.py</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pip install tensorflow-serving-api</span></span><br></pre></td></tr></table></figure><p>脚本内容：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"></span><br><span class="line"><span class="comment"># This is a placeholder for a Google-internal import.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow_serving.apis <span class="keyword">import</span> predict_pb2</span><br><span class="line"><span class="keyword">from</span> tensorflow_serving.apis <span class="keyword">import</span> prediction_service_pb2_grpc</span><br><span class="line"></span><br><span class="line"><span class="comment"># The image URL is the location of the image we should send to the server</span></span><br><span class="line">IMAGE_URL = <span class="string">'https://tensorflow.org/images/blogs/serving/cat.jpg'</span></span><br><span class="line"></span><br><span class="line">tf.app.flags.DEFINE_string(<span class="string">'server'</span>, <span class="string">'localhost:8500'</span>,</span><br><span class="line">                           <span class="string">'PredictionService host:port'</span>)</span><br><span class="line">tf.app.flags.DEFINE_string(<span class="string">'image'</span>, <span class="string">''</span>, <span class="string">'path to image in JPEG format'</span>)</span><br><span class="line">FLAGS = tf.app.flags.FLAGS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(_)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> FLAGS.image:</span><br><span class="line">    <span class="keyword">with</span> open(FLAGS.image, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">      data = f.read()</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># Download the image since we weren't given one</span></span><br><span class="line">    dl_request = requests.get(IMAGE_URL, stream=<span class="literal">True</span>)</span><br><span class="line">    dl_request.raise_for_status()</span><br><span class="line">    data = dl_request.content</span><br><span class="line"></span><br><span class="line">  channel = grpc.insecure_channel(FLAGS.server)</span><br><span class="line">  stub = prediction_service_pb2_grpc.PredictionServiceStub(channel)</span><br><span class="line">  <span class="comment"># Send request</span></span><br><span class="line">  <span class="comment"># See prediction_service.proto for gRPC request/response details.</span></span><br><span class="line">  request = predict_pb2.PredictRequest()</span><br><span class="line">  request.model_spec.name = <span class="string">'resnet'</span></span><br><span class="line">  request.model_spec.signature_name = <span class="string">'serving_default'</span></span><br><span class="line">  request.inputs[<span class="string">'image_bytes'</span>].CopyFrom(</span><br><span class="line">      tf.contrib.util.make_tensor_proto(data, shape=[<span class="number">1</span>]))</span><br><span class="line">  result = stub.Predict(request, <span class="number">10.0</span>)  <span class="comment"># 10 secs timeout</span></span><br><span class="line">  print(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  tf.app.run()</span><br></pre></td></tr></table></figure><p>输出的结果可以看到图片的分类，概率和使用的模型信息：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python resnet_client_grpc.py</span></span><br><span class="line">outputs &#123;</span><br><span class="line">  key: "classes"</span><br><span class="line">  value &#123;</span><br><span class="line">    dtype: DT_INT64</span><br><span class="line">    tensor_shape &#123;</span><br><span class="line">      dim &#123;</span><br><span class="line">        size: 1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int64_val: 286</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">outputs &#123;</span><br><span class="line">  key: "probabilities"</span><br><span class="line">  value &#123;</span><br><span class="line">    dtype: DT_FLOAT</span><br><span class="line">    tensor_shape &#123;</span><br><span class="line">      dim &#123;</span><br><span class="line">        size: 1</span><br><span class="line">      &#125;</span><br><span class="line">      dim &#123;</span><br><span class="line">        size: 1001</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    float_val: 2.4162832232832443e-06</span><br><span class="line">    float_val: 1.9012182974620373e-06</span><br><span class="line">    float_val: 2.7247710022493266e-05</span><br><span class="line">    float_val: 4.426385658007348e-07</span><br><span class="line">    ...(中间省略)</span><br><span class="line">    float_val: 1.4636580090154894e-05</span><br><span class="line">    float_val: 5.812107133351674e-07</span><br><span class="line">    float_val: 6.599806511076167e-05</span><br><span class="line">    float_val: 0.0012952701654285192</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">model_spec &#123;</span><br><span class="line">  name: "resnet"</span><br><span class="line">  version &#123;</span><br><span class="line">    value: 1538687457</span><br><span class="line">  &#125;</span><br><span class="line">  signature_name: "serving_default"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>性能</h2><h3>通过编译优化的TensorFlow Serving二进制来提高性能</h3><p>TensorFlows serving有时会有输出如下的日志：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX2 FMA</span><br></pre></td></tr></table></figure><p>TensorFlow Serving已发布Docker镜像旨在尽可能多地使用CPU架构，因此省略了一些优化以最大限度地提高兼容性。如果你没有看到此消息，则你的二进制文件可能已针对你的CPU进行了优化。根据你的模型执行的操作，这些优化可能会对你的服务性能产生重大影响。幸运的是，编译优化的TensorFlow Serving二进制非常简单。官方已经提供了自动化脚本，分以下两部进行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 编译开发版本</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker build -t <span class="variable">$USER</span>/tensorflow-serving-devel -f Dockerfile.devel https://github.com/tensorflow/serving.git<span class="comment">#:tensorflow_serving/tools/docker</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 生产新的镜像</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker build -t <span class="variable">$USER</span>/tensorflow-serving --build-arg TF_SERVING_BUILD_IMAGE=<span class="variable">$USER</span>/tensorflow-serving-devel https://github.com/tensorflow/serving.git<span class="comment">#:tensorflow_serving/tools/docker</span></span></span><br></pre></td></tr></table></figure><p>之后，使用新编译的<code>$USER/tensorflow-serving</code>重新启动服务即可。</p><h2>总结</h2><p>上面我们快速实践了使用TensorFlow Serving和Docker部署机器学习服务的过程，可以看到，TensorFlow Serving提供了非常方便和高效的模型管理，配合Docker，可以快速搭建起机器学习服务。</p><h2>参考</h2><ul><li><a href="https://medium.com/tensorflow/serving-ml-quickly-with-tensorflow-serving-and-docker-7df7094aa008" target="_blank" rel="noopener">Serving ML Quickly with TensorFlow Serving and Docker</a></li><li><a href="https://www.tensorflow.org/tfx/serving/tutorials/Serving_REST_simple" target="_blank" rel="noopener">Train and serve a TensorFlow model with TensorFlow Serving</a></li></ul><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog" target="_blank" rel="noopener">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui" target="_blank" rel="noopener">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从实验到生产，简单快速部署机器学习模型一直是一个挑战。这个过程要做的就是将训练好的模型对外提供预测服务。在生产中，这个过程需要可重现，隔离和安全。这里，我们使用基于Docker的TensorFlow Serving来简单地完成这个过程。TensorFlow 从1.8版本开始支持Docker部署，包括CPU和GPU，非常方便。&lt;/p&gt;
&lt;h2&gt;获得训练好的模型&lt;/h2&gt;
&lt;p&gt;获取模型的第一步当然是训练一个模型，但是这不是本篇的重点，所以我们使用一个已经训练好的模型，比如ResNet。TensorFlow Serving 使用SavedModel这种格式来保存其模型，SavedModel是一种独立于语言的，可恢复，密集的序列化格式，支持使用更高级别的系统和工具来生成，使用和转换TensorFlow模型。这里我们直接下载一个预训练好的模型：&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="机器学习" scheme="https://qiwihui.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>使用 Sphinx 撰写技术文档并生成 PDF 总结</title>
    <link href="https://qiwihui.com/qiwihui-blog-57/"/>
    <id>https://qiwihui.com/qiwihui-blog-57/</id>
    <published>2019-02-23T17:33:05.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>这几天准备编排部分翻译的书籍和文档，找了好些工具，最终定格在 Sphinx 上，并基于 <a href="https://readthedocs.org" target="_blank" rel="noopener">ReadTheDocs</a> 提供的 SaaS 服务进行分发和分享。本篇博客是对整个过程的一次记录和总结。</p><p>项目代码：<a href="https://github.com/qiwihui/sphinx-doc-starter" target="_blank" rel="noopener">qiwihui/sphinx-doc-starter</a></p><h2>认识 Sphinx</h2><p><a href="http://sphinx-doc.org/" target="_blank" rel="noopener">Sphinx</a> 是一个基于 Python 的文档生成项目。最早只是用来生成 <a href="https://docs.python.org/3/" target="_blank" rel="noopener">Python</a> 的项目文档，使用 <em>reStructuredText</em> 格式。但随着项目的逐渐完善，很多非 Python 的项目也采用 Sphinx 作为文档写作工具，甚至完全可以用 Sphinx 来写书。</p><p>使用 <a href="http://sphinx-doc-zh.readthedocs.org/en/latest/" target="_blank" rel="noopener">Sphinx 生成文档的优点</a>包括：</p><ul><li><em>丰富的输出格式</em>: 支持输出为 HTML（包括 Windows 帮助文档），LaTeX（可以打印PDF版本）, manual pages（man 文档）, 纯文本等若干种格式；</li><li><em>完备的交叉引用</em>: 语义化的标签，并可以自动化链接函数、类、引文、术语等；</li><li><em>明晰的分层结构</em>: 轻松定义文档树，并自动化链接同级/父级/下级文章；</li><li><em>美观的自动索引</em>: 可自动生成美观的模块索引；</li><li><em>精确的语法高亮</em>: 基于 Pygments 自动生成语法高亮；</li><li><em>开放的扩展</em>: 支持代码块的自动测试，自动包含 Python 的模块自述文档，等等。</li></ul><a id="more"></a><h2>开始</h2><p>这个过程包括如下步骤：</p><ul><li>安装 Sphinx</li><li>第一个文档</li><li>在线托管</li><li>生成 PDF</li></ul><h3>安装 Sphinx</h3><p>Sphinx 依赖于 Python，并提供了 Python 包，所以使用 pip 安装既可。这里我只安装了 <code>sphinx-doc</code> 这个包。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install sphinx-doc</span><br></pre></td></tr></table></figure><p>这时，通过 bash 自动补全（连续两下 <code>tab</code>），可以看到有几个命令，Sphinx 推荐使用 <code>sphinx-quickstart</code>，这是一个设置向导。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sphinx-</span></span><br><span class="line">sphinx-apidoc      sphinx-autogen     sphinx-build       sphinx-quickstart</span><br></pre></td></tr></table></figure><h3>设置 Sphinx</h3><p>运行 <code>sphinx-quickstart</code>，以下主要设置项目名称，作者名称以及语言（<code>zh_CN</code>）即可，其他默认。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sphinx-quickstart</span></span><br><span class="line">Welcome to the Sphinx 1.8.4 quickstart utility.</span><br><span class="line"></span><br><span class="line">Please enter values for the following settings (just press Enter to</span><br><span class="line">accept a default value, if one is given in brackets).</span><br><span class="line"></span><br><span class="line">Selected root path: .</span><br><span class="line"></span><br><span class="line">You have two options for placing the build directory for Sphinx output.</span><br><span class="line">Either, you use a directory "_build" within the root path, or you separate</span><br><span class="line">"source" and "build" directories within the root path.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Separate <span class="built_in">source</span> and build directories (y/n) [n]: y</span></span><br><span class="line"></span><br><span class="line">Inside the root directory, two more directories will be created; "_templates"</span><br><span class="line">for custom HTML templates and "_static" for custom stylesheets and other static</span><br><span class="line">files. You can enter another prefix (such as ".") to replace the underscore.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Name prefix <span class="keyword">for</span> templates and static dir [_]: </span></span><br><span class="line"></span><br><span class="line">The project name will occur in several places in the built documentation.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Project name: 一本书</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Author name(s): qiwihui</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Project release []: 0.0.1</span></span><br><span class="line"></span><br><span class="line">If the documents are to be written in a language other than English,</span><br><span class="line">you can select a language here by its language code. Sphinx will then</span><br><span class="line">translate text that it generates into that language.</span><br><span class="line"></span><br><span class="line">For a list of supported codes, see</span><br><span class="line">http://sphinx-doc.org/config.html#confval-language.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Project language [en]: zh_CN</span></span><br><span class="line"></span><br><span class="line">The file name suffix for source files. Commonly, this is either ".txt"</span><br><span class="line">or ".rst".  Only files with this suffix are considered documents.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Source file suffix [.rst]: </span></span><br><span class="line"></span><br><span class="line">One document is special in that it is considered the top node of the</span><br><span class="line">"contents tree", that is, it is the root of the hierarchical structure</span><br><span class="line">of the documents. Normally, this is "index", but if your "index"</span><br><span class="line">document is a custom template, you can also set this to another filename.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Name of your master document (without suffix) [index]: </span></span><br><span class="line">Indicate which of the following Sphinx extensions should be enabled:</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> autodoc: automatically insert docstrings from modules (y/n) [n]: </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> doctest: automatically <span class="built_in">test</span> code snippets <span class="keyword">in</span> doctest blocks (y/n) [n]: </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> intersphinx: link between Sphinx documentation of different projects (y/n) [n]: </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> todo: write <span class="string">"todo"</span> entries that can be shown or hidden on build (y/n) [n]: </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> coverage: checks <span class="keyword">for</span> documentation coverage (y/n) [n]: </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> imgmath: include math, rendered as PNG or SVG images (y/n) [n]: </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> mathjax: include math, rendered <span class="keyword">in</span> the browser by MathJax (y/n) [n]: </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ifconfig: conditional inclusion of content based on config values (y/n) [n]: </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> viewcode: include links to the <span class="built_in">source</span> code of documented Python objects (y/n) [n]: </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> githubpages: create .nojekyll file to publish the document on GitHub pages (y/n) [n]: </span></span><br><span class="line"></span><br><span class="line">A Makefile and a Windows command file can be generated for you so that you</span><br><span class="line">only have to run e.g. `make html` instead of invoking sphinx-build</span><br><span class="line">directly.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Create Makefile? (y/n) [y]: </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Create Windows <span class="built_in">command</span> file? (y/n) [y]: </span></span><br><span class="line"></span><br><span class="line">Creating file ./source/conf.py.</span><br><span class="line">Creating file ./source/index.rst.</span><br><span class="line">Creating file ./Makefile.</span><br><span class="line">Creating file ./make.bat.</span><br><span class="line"></span><br><span class="line">Finished: An initial directory structure has been created.</span><br><span class="line"></span><br><span class="line">You should now populate your master file ./source/index.rst and create other documentation</span><br><span class="line">source files. Use the Makefile to build the docs, like so:</span><br><span class="line">   make builder</span><br><span class="line">where "builder" is one of the supported builders, e.g. html, latex or linkcheck.</span><br></pre></td></tr></table></figure><p>解释1，整个设置过程包括：</p><ol><li><p>是否分离源文件目录 <code>source</code> 和生成文件目录 <code>build</code>，默认否；</p></li><li><p>模板目录 <code>templates</code> 和静态文件目录 <code>static</code> 前缀，默认为<code>_</code>；</p></li><li><p>项目名称；</p></li><li><p>项目作者；</p></li><li><p>项目版本，默认为空；</p></li><li><p>项目语言，默认为 <code>en</code>；</p></li><li><p>文档扩展名，默认为 <code>.rst</code>；</p></li><li><p>首页文件名，默认为 <code>index</code>；</p></li><li><p>开启的扩展，均默认为否：</p><ul><li>autodoc</li><li>doctest</li><li>intersphinx</li><li>todo</li><li>coverage</li><li>imgmath</li><li>mathjax</li><li>ifconfig</li><li>viewcode</li><li>githubpages</li></ul></li><li><p>生成 Makefile，默认是；</p></li><li><p>生成 Windows 用命令行，默认是。</p></li></ol><p>解释2，项目目录文件结构如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sphinx-test</span><br><span class="line">├── Makefile</span><br><span class="line">├── build</span><br><span class="line">├── make.bat</span><br><span class="line">└── source</span><br><span class="line">    ├── _static</span><br><span class="line">    ├── _templates</span><br><span class="line">    ├── conf.py</span><br><span class="line">    └── index.rst</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>Makefile</code>：可以看作是一个包含指令的文件，在使用 make 命令时，可以使用这些指令来构建文档输出。</li><li><code>build</code>：生成的文件的输出目录。</li><li><code>make.bat</code>：Windows 用命令行。</li><li><code>_static</code>：静态文件目录，比如图片等。</li><li><code>_templates</code>：模板目录。</li><li><code>conf.py</code>：存放 Sphinx 的配置，包括在 <code>sphinx-quickstart</code> 时选中的那些值，可以自行定义其他的值。</li><li><code>index.rst</code>：文档项目起始文件。</li></ul><p>接下来看看默认生成的内容：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make html</span></span><br><span class="line">Running Sphinx v1.8.4</span><br><span class="line">loading translations [zh_CN]... done</span><br><span class="line">making output directory...</span><br><span class="line">building [mo]: targets for 0 po files that are out of date</span><br><span class="line">building [html]: targets for 1 source files that are out of date</span><br><span class="line">updating environment: 1 added, 0 changed, 0 removed</span><br><span class="line">reading sources... [100%] index                                                                                                         looking for now-outdated files... none found</span><br><span class="line">pickling environment... done</span><br><span class="line">checking consistency... done</span><br><span class="line">preparing documents... done</span><br><span class="line">writing output... [100%] index                                                                                                          generating indices... genindex</span><br><span class="line">writing additional pages... search</span><br><span class="line">copying static files... done</span><br><span class="line">copying extra files... done</span><br><span class="line">dumping search index in Chinese (code: zh) ... done</span><br><span class="line">dumping object inventory... done</span><br><span class="line">build succeeded.</span><br><span class="line"></span><br><span class="line">The HTML pages are in build/html.</span><br></pre></td></tr></table></figure><p>然后直接在浏览器中打开 <code>build/html/index.html</code> 这个文件。</p><p><img src="https://user-images.githubusercontent.com/3297411/53294694-86068e00-3826-11e9-93e6-4f3ad80cc245.png" alt="initial"></p><p>默认风格为 <code>alabaster</code>，可以改成 ReadTheDocs 的风格： <code>sphinx_rtd_theme</code>。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -- Options for HTML output -------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The theme to use for HTML and HTML Help pages.  See the documentation for</span></span><br><span class="line"><span class="comment"># a list of builtin themes.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">html_theme = <span class="string">'sphinx_rtd_theme'</span></span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/3297411/53294697-9585d700-3826-11e9-9eab-13d1d4e46aa4.png" alt="rtd_theme"></p><h3>第一个文档</h3><p>我们以一下文档为例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This is a Title</span><br><span class="line">===============</span><br><span class="line">That has a paragraph about a main subject and is set when the &apos;=&apos;</span><br><span class="line">is at least the same length of the title itself.</span><br><span class="line"></span><br><span class="line">Subject Subtitle</span><br><span class="line">----------------</span><br><span class="line">Subtitles are set with &apos;-&apos; and are required to have the same length</span><br><span class="line">of the subtitle itself, just like titles.</span><br><span class="line"></span><br><span class="line">Lists can be unnumbered like:</span><br><span class="line"></span><br><span class="line"> * Item Foo</span><br><span class="line"> * Item Bar</span><br><span class="line"></span><br><span class="line">Or automatically numbered:</span><br><span class="line"></span><br><span class="line"> #. Item 1</span><br><span class="line"> #. Item 2</span><br><span class="line"></span><br><span class="line">Inline Markup</span><br><span class="line">-------------</span><br><span class="line">Words can have *emphasis in italics* or be **bold** and you can define</span><br><span class="line">code samples with back quotes, like when you talk about a command: ``sudo``</span><br><span class="line">gives you super user powers!</span><br></pre></td></tr></table></figure><p>将之写入 <code>example.rst</code> 中，并修改 <code>index.rst</code> 为:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome to 一本书&apos;s documentation!</span><br><span class="line">==================================</span><br><span class="line"></span><br><span class="line">.. toctree::</span><br><span class="line">   :maxdepth: 2</span><br><span class="line">   :caption: 目录:</span><br><span class="line"></span><br><span class="line">   example</span><br><span class="line"></span><br><span class="line">Indices and tables</span><br><span class="line">==================</span><br><span class="line"></span><br><span class="line">* :ref:`genindex`</span><br><span class="line">* :ref:`modindex`</span><br><span class="line">* :ref:`search`</span><br></pre></td></tr></table></figure><p>重新编译，这时文档已经改变。</p><p><img src="https://user-images.githubusercontent.com/3297411/53294701-a5052000-3826-11e9-972f-85631118b372.png" alt="first_doc"><img src="https://user-images.githubusercontent.com/3297411/53294703-a9c9d400-3826-11e9-9c63-9fd73f19792c.png" alt="first_doc_page"></p><h3>在线托管</h3><p><a href="https://readthedocs.org" target="_blank" rel="noopener">ReadTheDocs</a> 可是直接用于托管 sphinx 生成的网页文档。将之前的文档用 Git 管理，并推送到 Github，然后在 ReadTheDocs 中 <code>Import a Project</code> 即可。</p><p><img src="https://user-images.githubusercontent.com/3297411/53294710-dd0c6300-3826-11e9-9b50-f257ccc9049d.png" alt="rtd"></p><p>另外，可以设置自定义域名：</p><ol><li>在域名管理中添加 DNS 的 CNAME 记录到 <code>readthedocs.io</code>，比如 <code>onebook.qiwihui.com</code></li><li>在项目的 <code>Admin</code> -&gt; <code>Domains</code> 中设置上一步添加的域名，开启 HTTPS，保存即可。</li></ol><p><img src="https://user-images.githubusercontent.com/3297411/53294706-b4846900-3826-11e9-8cc7-570d0f6e4430.png" alt="add_new_domain"></p><p>过程很简单。</p><h3>生成 PDF</h3><p>Sphinx 生成 PDF 的过程先将 rst 转换为 tex，再生成 PDF。这个过程遇到了比较多的坑，最后总结下来过程如下：</p><p>首先，安装 Tex 环境。在 Mac 上，推荐安装 <code>MacTex</code> 而不是 <code>BasicTex</code>，对于新手来说 BasicTex 上需要自己处理很多依赖问题。完成后使用 <code>tlmgr</code> 更新 TexLive。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew cask install mactex</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo tlmgr update --self</span></span><br></pre></td></tr></table></figure><p>然后，在 <a href="http://con.py" target="_blank" rel="noopener">con.py</a> 中设置 <code>latex_engine</code> 和 <code>latex_elements</code> 两个参数，同时也可以设置 <code>latex_documents</code> 参数来设置文档。因为 ReadTheDocs 上只有 pdflatex 引擎，如果需要同时在 ReadTheDocs 和本地化都能顺利编译中文pdf的话，可以在 <a href="http://conf.py" target="_blank" rel="noopener">conf.py</a> 中添加如下配置：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -- Options for LaTeX output ------------------------------------------------</span></span><br><span class="line"><span class="comment"># 检查是否为 READTHEDOCS 环境</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">on_rtd = os.environ.get(<span class="string">'READTHEDOCS'</span>, <span class="literal">None</span>) == <span class="string">'True'</span></span><br><span class="line"><span class="keyword">if</span> on_rtd:</span><br><span class="line">    latex_elements = &#123;</span><br><span class="line">        <span class="string">'preamble'</span>: <span class="string">r'''</span></span><br><span class="line"><span class="string">\hypersetup&#123;unicode=true&#125;</span></span><br><span class="line"><span class="string">\usepackage&#123;CJKutf8&#125;</span></span><br><span class="line"><span class="string">\DeclareUnicodeCharacter&#123;00A0&#125;&#123;\nobreakspace&#125;</span></span><br><span class="line"><span class="string">\DeclareUnicodeCharacter&#123;2203&#125;&#123;\ensuremath&#123;\exists&#125;&#125;</span></span><br><span class="line"><span class="string">\DeclareUnicodeCharacter&#123;2200&#125;&#123;\ensuremath&#123;\forall&#125;&#125;</span></span><br><span class="line"><span class="string">\DeclareUnicodeCharacter&#123;2286&#125;&#123;\ensuremath&#123;\subseteq&#125;&#125;</span></span><br><span class="line"><span class="string">\DeclareUnicodeCharacter&#123;2713&#125;&#123;x&#125;</span></span><br><span class="line"><span class="string">\DeclareUnicodeCharacter&#123;27FA&#125;&#123;\ensuremath&#123;\Longleftrightarrow&#125;&#125;</span></span><br><span class="line"><span class="string">\DeclareUnicodeCharacter&#123;221A&#125;&#123;\ensuremath&#123;\sqrt&#123;&#125;&#125;&#125;</span></span><br><span class="line"><span class="string">\DeclareUnicodeCharacter&#123;221B&#125;&#123;\ensuremath&#123;\sqrt[3]&#123;&#125;&#125;&#125;</span></span><br><span class="line"><span class="string">\DeclareUnicodeCharacter&#123;2295&#125;&#123;\ensuremath&#123;\oplus&#125;&#125;</span></span><br><span class="line"><span class="string">\DeclareUnicodeCharacter&#123;2297&#125;&#123;\ensuremath&#123;\otimes&#125;&#125;</span></span><br><span class="line"><span class="string">\begin&#123;CJK&#125;&#123;UTF8&#125;&#123;gbsn&#125;</span></span><br><span class="line"><span class="string">\AtEndDocument&#123;\end&#123;CJK&#125;&#125;</span></span><br><span class="line"><span class="string">'''</span>,</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 本地</span></span><br><span class="line">    latex_engine = <span class="string">'xelatex'</span></span><br><span class="line">    latex_elements = &#123;</span><br><span class="line">        <span class="string">'papersize'</span>: <span class="string">'a4paper'</span>,</span><br><span class="line">        <span class="string">'pointsize'</span>: <span class="string">'11pt'</span>,</span><br><span class="line">        <span class="string">'preamble'</span>: <span class="string">r'''</span></span><br><span class="line"><span class="string">\usepackage&#123;xeCJK&#125;</span></span><br><span class="line"><span class="string">\setCJKmainfont[BoldFont=STZhongsong, ItalicFont=STKaiti]&#123;STSong&#125;</span></span><br><span class="line"><span class="string">\setCJKsansfont[BoldFont=STHeiti]&#123;STXihei&#125;</span></span><br><span class="line"><span class="string">\setCJKmonofont&#123;STFangsong&#125;</span></span><br><span class="line"><span class="string">\XeTeXlinebreaklocale "zh"</span></span><br><span class="line"><span class="string">\XeTeXlinebreakskip = 0pt plus 1pt</span></span><br><span class="line"><span class="string">\parindent 2em</span></span><br><span class="line"><span class="string">\definecolor&#123;VerbatimColor&#125;&#123;rgb&#125;&#123;0.95,0.95,0.95&#125;</span></span><br><span class="line"><span class="string">\setcounter&#123;tocdepth&#125;&#123;3&#125;</span></span><br><span class="line"><span class="string">\renewcommand\familydefault&#123;\ttdefault&#125;</span></span><br><span class="line"><span class="string">\renewcommand\CJKfamilydefault&#123;\CJKrmdefault&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment"># 设置文档</span></span><br><span class="line">latex_documents = [</span><br><span class="line">    (master_doc, <span class="string">'sphinx.tex'</span>, <span class="string">'你的第一本 Sphinx 书'</span>,</span><br><span class="line">     <span class="string">'作者：qiwihui'</span>, <span class="string">'manual'</span>, <span class="literal">True</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>最后，编译：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make latexpdf</span></span><br></pre></td></tr></table></figure><p><code>make latexpdf</code> 会完成 rst转换为 tex 并将 tex 生成 PDF，可以手动分开：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make latex</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> build/latex</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br></pre></td></tr></table></figure><p>在 <code>build/latex</code> 下可以查看到生成的 PDF 文档。</p><h4>字体</h4><p>使用 <code>fc-list</code> 来获取字体信息，修改相应字体设置即可。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install fontconfig</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">fc</span>-list :lang=zh</span></span><br></pre></td></tr></table></figure><h4>遇到的问题:</h4><ol><li>遇到 <code>&quot;! LaTeX Error: File '*.sty' not found.&quot;</code> 类的问题：</li></ol><p>解决：使用 <code>sudo tlmgr install</code> 安装相应的包即可。</p><h2>总结</h2><p>简单过了一下整个文档的流程，总体来说，Sphinx非常适合用来编写项目文档，reStructuredText 比起 Markdown 也有太多的优势，值得推荐。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天准备编排部分翻译的书籍和文档，找了好些工具，最终定格在 Sphinx 上，并基于 &lt;a href=&quot;https://readthedocs.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ReadTheDocs&lt;/a&gt; 提供的 SaaS 服务进行分发和分享。本篇博客是对整个过程的一次记录和总结。&lt;/p&gt;
&lt;p&gt;项目代码：&lt;a href=&quot;https://github.com/qiwihui/sphinx-doc-starter&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;qiwihui/sphinx-doc-starter&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;认识 Sphinx&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://sphinx-doc.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Sphinx&lt;/a&gt; 是一个基于 Python 的文档生成项目。最早只是用来生成 &lt;a href=&quot;https://docs.python.org/3/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Python&lt;/a&gt; 的项目文档，使用 &lt;em&gt;reStructuredText&lt;/em&gt; 格式。但随着项目的逐渐完善，很多非 Python 的项目也采用 Sphinx 作为文档写作工具，甚至完全可以用 Sphinx 来写书。&lt;/p&gt;
&lt;p&gt;使用 &lt;a href=&quot;http://sphinx-doc-zh.readthedocs.org/en/latest/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Sphinx 生成文档的优点&lt;/a&gt;包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;丰富的输出格式&lt;/em&gt;: 支持输出为 HTML（包括 Windows 帮助文档），LaTeX（可以打印PDF版本）, manual pages（man 文档）, 纯文本等若干种格式；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;完备的交叉引用&lt;/em&gt;: 语义化的标签，并可以自动化链接函数、类、引文、术语等；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;明晰的分层结构&lt;/em&gt;: 轻松定义文档树，并自动化链接同级/父级/下级文章；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;美观的自动索引&lt;/em&gt;: 可自动生成美观的模块索引；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;精确的语法高亮&lt;/em&gt;: 基于 Pygments 自动生成语法高亮；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;开放的扩展&lt;/em&gt;: 支持代码块的自动测试，自动包含 Python 的模块自述文档，等等。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>机器学习项目清单</title>
    <link href="https://qiwihui.com/qiwihui-blog-56/"/>
    <id>https://qiwihui.com/qiwihui-blog-56/</id>
    <published>2019-02-17T18:10:49.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.ic.unicamp.br/~sandra/pdf/Hands_On_Machine_Learning_with_Scikit_Learn_and_TensorFlow-427-432.pdf" target="_blank" rel="noopener">原文</a>来自于《<a href="https://book.douban.com/subject/26840215/" target="_blank" rel="noopener">Hands-On Machine Learning with Scikit-Learn and TensorFlow</a>》，这是一本系统学习机器学习和深度学习非常不错的入门书籍，理论和实践兼而有之。</p><p>此清单可以指导你完成机器学习项目。主要有八个步骤：</p><ol><li>将问题框架化并且关注重点。</li><li>获取数据。</li><li>探索数据以洞悉数据。</li><li>准备数据以更好地将基础数据模式暴露给机器学习算法。</li><li>探索多种不同的模型并列出最好的那些。</li><li>微调模型并将它们组合成一个很好的解决方案。</li><li>展示你的解决方案。</li><li>启动，监督并维护你的系统。</li></ol><p>显然，你应该根据你的需求调整此清单。</p><a id="more"></a><h2>将问题框架化并且关注重点</h2><ol><li>用业务术语定义目标。</li><li>你的解决方案将如何使用？</li><li>目前的解决方案/解决方法（如果有的话）是什么？</li><li>你应该如何解决这个问题（监督/非监督，在线/离线等）？</li><li>如何度量模型的表现？</li><li>模型的表现是否和业务目标一致？</li><li>达到业务目标所需的最低性能是多少？</li><li>类似的问题如何解决？是否可以复用经验或工具？</li><li>人员是否专业？</li><li>你如何动手解决问题？</li><li>列出目前你（或者其他人）所做的假设。</li><li>如果可能，验证假设。</li></ol><h2>获取数据</h2><p>注意：尽可能自动化，以便你轻松获取新数据。</p><ol><li>列出你需要的数据和数据量。</li><li>查找并记录你可以获取该数据的位置。</li><li>检查它将占用多少存储空间。</li><li>检查法律义务并在必要时获取授权。</li><li>获取访问权限。</li><li>创建工作目录（拥有足够的存储空间）。</li><li>获取数据。</li><li>将数据转换为你可以轻松操作的格式（不更改数据本身）。</li><li>确保删除或保护敏感信息（比如，匿名）。</li><li>检查数据的大小和类型（时间序列，样本，地理信息等）。</li><li>抽样出测试集，将它放在一边，以后不需要关注它（没有数据窥探！）。</li></ol><h2>探索数据</h2><p>注意：尝试从领域专家那获取有关这些步骤的见解。</p><ol><li>创建用于探索的数据副本（如有必要，将其取样为可管理的大小）。</li><li>创建一个 Jupyter 笔记本来记录你的数据探索。</li><li>研究每个属性及其特征：</li></ol><ul><li>名称；</li><li>类型（分类，整数/浮点数，有界/无界，文本，结构化数据等）；</li><li>缺失数据的百分比；</li><li>噪声点和它的类型（随机点，异常点，舍入误差等）；</li><li>对任务可能有用吗？</li><li>分布类型（高斯分布，均匀分布，对数分布等）。</li></ul><ol start="4"><li>对于监督学习任务，确定目标属性。</li><li>可视化数据。</li><li>研究属性间的相关性。</li><li>研究怎如何手动解决问题。</li><li>确定你想要应用的有效的转换。</li><li>确定有用的额外数据。</li><li>记录你所学到的知识。</li></ol><h2>准备数据</h2><p>注意：</p><ul><li>处理数据副本（保持原始数据集完整）。</li><li>为你应用的所有数据转换编写函数，原因有五：<ul><li>你可以在下次获得新数据集时轻松准备数据</li><li>你可以在未来的项目中应用这些转换</li><li>用来清洗和准备测试数据集</li><li>一旦项目上线你可以用来清洗和准备新的数据集</li><li>为了便于将你的准备选择视为超参数</li></ul></li></ul><ol><li>数据清洗：</li></ol><ul><li>修正或移除异常值（可选）。</li><li>填补缺失值（比如用零，平均值，中位数等）或者删除所在行（或者列）。</li></ul><ol start="2"><li>特征提取（可选）：</li></ol><ul><li>丢弃不提供有用信息的属性；</li></ul><ol start="3"><li>适当的特征工程：</li></ol><ul><li>连续特征离散化。</li><li>分解特征（比如分类，日期/时间等）。</li><li>对特征添加有益的转换（比如 log(x)，sqrt(x)，x^2 等）</li><li>Aggregate features into promising new features. 将一些特征融合为有益的新特征</li></ul><ol start="4"><li>特征缩放：标准化或者正规化特征。</li></ol><h2>列出有用模型</h2><p>注意：</p><ul><li>如果数据量巨大，你可能需要采样出较小的训练集，以便在合理的时间内训练许多不同的模型（请注意，这会对诸如大型神经网络或随机森林等复杂模型进行处罚）。</li><li>再次尝试尽可能自动化这些步骤。</li></ul><ol><li>使用标准参数训练许多快速、粗糙的模型（比如线性模型，朴素贝叶斯模型，支持向量机模型，随机森林模型，神经网络等）。</li><li>衡量并比较他们的表现。</li></ol><ul><li>对于每个模型，使用 N 折交叉验证法，并且计算基于 N 折交叉验证的均值与方差。</li></ul><ol start="3"><li>分析每种算法的最重要变量。</li><li>分析模型产生的错误类型。</li></ol><ul><li>人们用什么数据来避免这些错误？</li></ul><ol start="5"><li>进行一轮快速的特征提取和特征工程。</li><li>对之前的五个步骤进行一两次的快速迭代。</li><li>列出前三到五名最有用的模型，由其是产生不同类型错误的模型。</li></ol><h2>微调系统</h2><p>注意：</p><ul><li>这一步你将会使用尽可能多的数据，特别是当你微调结束时。</li><li>像之前一样尽可能自动化。</li></ul><ol><li>使用交叉验证方法调节超参数</li></ol><ul><li>要像调节超参数那样对待数据转换的过程，特别是当你不知如何下手的时候（比如，我应该是用零或中值替换缺失值吗？或者直接丢弃它们？）</li><li>除非要探索的超参数值非常少，否则最好使用随机搜索而非网格搜索。如果训练的时间很长，你应该使用贝叶斯优化方法（比如，使用在 <a href="https://arxiv.org/pdf/1206.2944.pdf" target="_blank" rel="noopener">Jasper Snoek，Hugo Larochelle 和 Ryan Adams 的论文</a>中描述的，用高斯处理先验）</li></ul><ol start="2"><li>尝试集成方法，结合最佳模型通常比单独运行它们更好。</li><li>一旦你对最终的模型有自信，请在测试集上测量其性能以估计泛化误差。</li></ol><blockquote><p>在测量泛化误差后不要调整模型：你会开始过度拟合测试集的。</p></blockquote><h2>展示你的解决方案</h2><ol><li>将你做的工作整理成文档。</li><li>制作精美的演示。</li></ol><ul><li>确保你首先突出重点。</li></ul><ol start="3"><li>解释你的解决方案实现业务目标的原因。</li><li>不要忘记展示在这过程中你注意到的有趣的点。</li></ol><ul><li>描述哪些有效，哪些无效。-列出你的假设和系统的限制。</li></ul><ol start="5"><li>确保通过精美的可视化或易于记忆的陈述来传达你的主要发现（例如，“收入中位数是房价的第一预测因子”）。</li></ol><h2>启动</h2><ol><li>准备好生产解决方案（插入生产数据输入，编写单元测试等）。</li><li>编写监控代码以定期检查系统的实时性能，并在信号丢失时触发警报。</li></ol><ul><li>谨防模型退化：随着数据的进入，模型往往会“腐烂”。</li><li>评估模型可能需要大量的人力（比如，通过众包服务可以解决这个问题）</li><li>同时监控输入数据的质量（例如，一个有故障的传感器发送随机数据，或者另外一个团队的输出变得陈旧），这对于在线学习系统尤其重要。</li></ul><ol start="3"><li>定期在新数据上重新训练模型（尽可能自动化）。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.ic.unicamp.br/~sandra/pdf/Hands_On_Machine_Learning_with_Scikit_Learn_and_TensorFlow-427-432.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;来自于《&lt;a href=&quot;https://book.douban.com/subject/26840215/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hands-On Machine Learning with Scikit-Learn and TensorFlow&lt;/a&gt;》，这是一本系统学习机器学习和深度学习非常不错的入门书籍，理论和实践兼而有之。&lt;/p&gt;
&lt;p&gt;此清单可以指导你完成机器学习项目。主要有八个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将问题框架化并且关注重点。&lt;/li&gt;
&lt;li&gt;获取数据。&lt;/li&gt;
&lt;li&gt;探索数据以洞悉数据。&lt;/li&gt;
&lt;li&gt;准备数据以更好地将基础数据模式暴露给机器学习算法。&lt;/li&gt;
&lt;li&gt;探索多种不同的模型并列出最好的那些。&lt;/li&gt;
&lt;li&gt;微调模型并将它们组合成一个很好的解决方案。&lt;/li&gt;
&lt;li&gt;展示你的解决方案。&lt;/li&gt;
&lt;li&gt;启动，监督并维护你的系统。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;显然，你应该根据你的需求调整此清单。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="机器学习" scheme="https://qiwihui.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>如何在 Titanic Kaggle Challenge 中获得0.8134分</title>
    <link href="https://qiwihui.com/qiwihui-blog-55/"/>
    <id>https://qiwihui.com/qiwihui-blog-55/</id>
    <published>2019-02-12T02:14:46.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://ahmedbesbes.com/how-to-score-08134-in-titanic-kaggle-challenge.html" target="_blank" rel="noopener">How to score 0.8134 in Titanic Kaggle Challenge</a></p><p>由 Kaggle 主持的<a href="https://www.kaggle.com/c/titanic/" target="_blank" rel="noopener">泰坦尼克号生存挑战赛</a>是一项竞赛，其目标是基于一组描述乘客的变量，例如他的年龄，性别或乘客在船上的等级，来预测特定乘客是生存或死亡。</p><p>我一直在玩 Titanic 数据集，我最近在公共排行榜上获得了0.8134的准确度分数。当我写这篇文章时，我在所有 Kagglers 中排名前4％。</p><p><img src="https://raw.githubusercontent.com/qiwihui/How-to-score-0.8134-in-Titanic-Kaggle-Challenge/master/images/article_1/score.png" alt="png"></p><p>这篇文章将分享我的解决方案。</p><p>为了使本教程更具“学术性”以便任何人都能从中受益，我将首先从探索性数据分析（EDA）开始，然后我将遵循特征工程并最终呈现我设置的预测模型。</p><a id="more"></a><p>在这个 jupyter 笔记本中，我将在每个级别的管道中使用 Python。</p><p>本教程涉及的主要库是：</p><ul><li><strong>Pandas</strong> 用于数据操作和接入（ingestion）</li><li><strong>Matplotlib</strong> 和 <strong>seaborn</strong> 用于数据可视化</li><li><strong>Numpy</strong> 用于多维数组计算</li><li><strong>sklearn</strong> 用于机器学习和预测建模</li></ul><h3>安装过程</h3><p>安装这些软件包的一种非常简单的方法是下载并安装 <a href="href=%22http://conda.pydata.org/docs/install/quick.html#os-x-miniconda-install">Conda</a>，它是将以上所有包封装起来的发行版。此发行版适用于所有平台（Windows，Linux 和 Mac OSX）。</p><h3>特别注意</h3><p>这是我作为博主和机器学习从业者的第一次尝试。</p><p>如果您对我所做的代码或假设有疑问，请不要犹豫，在下面的评论部分发表评论。</p><p>如果您对如何改进笔记本电脑也有建议，请联系我。</p><p>本教程可在我的 <a href="https://github.com/ahmedbesbes/How-to-score-0.8134-in-Titanic-Kaggle-Challenge" target="_blank" rel="noopener">github</a> 帐户中找到。</p><blockquote><p>译者注：本翻译在 <a href="https://github.com/qiwihui/How-to-score-0.8134-in-Titanic-Kaggle-Challenge" target="_blank" rel="noopener">qiwihui</a> 下。</p></blockquote><p>希望你已经在计算机上设置了所有内容。让我们开始吧。</p><h2>I - 探索性数据分析</h2><p>正如在不同的数据项目中，我们将首先开始深入研究数据并建立我们的第一个直觉。</p><p>在本节中，我们将做四件事。</p><ul><li>数据提取：我们将加载数据集并首先查看它。</li><li>清洁：我们将填写缺失值。</li><li>绘图：我们将创建一些有趣的图表，这些图表（希望）可以发现数据中的相关性和隐藏的见解。</li><li>假设：我们将从图表中提出假设。</li></ul><p>我们稍微调整了这款笔记本的风格，以便画图居中。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.display <span class="keyword">import</span> HTML</span><br><span class="line">HTML(<span class="string">"""</span></span><br><span class="line"><span class="string">&lt;style&gt;</span></span><br><span class="line"><span class="string">.output_png &#123;</span></span><br><span class="line"><span class="string">    display: table-cell;</span></span><br><span class="line"><span class="string">    text-align: center;</span></span><br><span class="line"><span class="string">    vertical-align: middle;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;/style&gt;</span></span><br><span class="line"><span class="string">"""</span>);</span><br></pre></td></tr></table></figure><p>导入有用的包。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">'ignore'</span>)</span><br><span class="line">warnings.filterwarnings(<span class="string">'ignore'</span>, category=DeprecationWarning)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">pd.options.display.max_columns = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pylab <span class="keyword">as</span> plot</span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">'axes.labelsize'</span>: <span class="string">"large"</span>,</span><br><span class="line">    <span class="string">'xtick.labelsize'</span>: <span class="string">'x-large'</span>,</span><br><span class="line">    <span class="string">'legend.fontsize'</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">'figure.dpi'</span>: <span class="number">150</span>,</span><br><span class="line">    <span class="string">'figure.figsize'</span>: [<span class="number">25</span>, <span class="number">7</span>]</span><br><span class="line">&#125;</span><br><span class="line">plot.rcParams.update(params)</span><br></pre></td></tr></table></figure><p>有两个数据集：训练集和测试集。我们将使用训练集来构建我们的预测模型，用测试集来对其进行评分并生成输出文件以在Kaggle评估系统上提交。</p><p>我们将在本文末尾看到这个过程是如何完成的。</p><p>现在让我们开始加载训练集。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = pd.read_csv(<span class="string">'./data/train.csv'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> data.shape</span><br></pre></td></tr></table></figure><pre><code>(891, 12)</code></pre><p>我们得到:</p><ul><li>891 行</li><li>12 列</li></ul><p>Pandas 允许你鸟瞰数据。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.head()</span><br></pre></td></tr></table></figure><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>PassengerId</th>      <th>Survived</th>      <th>Pclass</th>      <th>Name</th>      <th>Sex</th>      <th>Age</th>      <th>SibSp</th>      <th>Parch</th>      <th>Ticket</th>      <th>Fare</th>      <th>Cabin</th>      <th>Embarked</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>1</td>      <td>0</td>      <td>3</td>      <td>Braund, Mr. Owen Harris</td>      <td>male</td>      <td>22.0</td>      <td>1</td>      <td>0</td>      <td>A/5 21171</td>      <td>7.2500</td>      <td>NaN</td>      <td>S</td>    </tr>    <tr>      <th>1</th>      <td>2</td>      <td>1</td>      <td>1</td>      <td>Cumings, Mrs. John Bradley (Florence Briggs Th...</td>      <td>female</td>      <td>38.0</td>      <td>1</td>      <td>0</td>      <td>PC 17599</td>      <td>71.2833</td>      <td>C85</td>      <td>C</td>    </tr>    <tr>      <th>2</th>      <td>3</td>      <td>1</td>      <td>3</td>      <td>Heikkinen, Miss. Laina</td>      <td>female</td>      <td>26.0</td>      <td>0</td>      <td>0</td>      <td>STON/O2. 3101282</td>      <td>7.9250</td>      <td>NaN</td>      <td>S</td>    </tr>    <tr>      <th>3</th>      <td>4</td>      <td>1</td>      <td>1</td>      <td>Futrelle, Mrs. Jacques Heath (Lily May Peel)</td>      <td>female</td>      <td>35.0</td>      <td>1</td>      <td>0</td>      <td>113803</td>      <td>53.1000</td>      <td>C123</td>      <td>S</td>    </tr>    <tr>      <th>4</th>      <td>5</td>      <td>0</td>      <td>3</td>      <td>Allen, Mr. William Henry</td>      <td>male</td>      <td>35.0</td>      <td>0</td>      <td>0</td>      <td>373450</td>      <td>8.0500</td>      <td>NaN</td>      <td>S</td>    </tr>  </tbody></table><p><code>Survived</code> 列是 <strong>目标变量</strong>。 如果 <code>Survived</code> 为 1，乘客幸免于难，否则他已经死了。这是我们要预测的变量。</p><p>其他变量描述了乘客。 它们是 <strong>特征</strong>。</p><ul><li><code>PassengerId</code>：船上每位旅客的身份证明</li><li><code>Pclass</code>：乘客等级。 它有三个可能的值：1，2，3（第一，第二和第三类）</li><li><code>Name</code>：Passeger的名字</li><li><code>Sex</code>：性别</li><li><code>Age</code>：年龄</li><li><code>SibSp</code>：与乘客一起旅行的兄弟姐妹和配偶的数量</li><li><code>Parch</code>：与乘客一起旅行的父母和孩子的数量</li><li><code>Ticket</code>：船票号码</li><li><code>Fare</code>：票价</li><li><code>Cabin</code>：船舱号码</li><li><code>Embarked</code>：这描述了人们登上的泰坦尼克号的三个可能区域。 三个可能的值 S，C，Q</li></ul><p>Pandas 允许您对数字特征进行高级简单的统计描述。这可以使用 <code>describe</code> 方法完成。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.describe()</span><br></pre></td></tr></table></figure><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>PassengerId</th>      <th>Survived</th>      <th>Pclass</th>      <th>Age</th>      <th>SibSp</th>      <th>Parch</th>      <th>Fare</th>    </tr>  </thead>  <tbody>    <tr>      <th>count</th>      <td>891.000000</td>      <td>891.000000</td>      <td>891.000000</td>      <td>714.000000</td>      <td>891.000000</td>      <td>891.000000</td>      <td>891.000000</td>    </tr>    <tr>      <th>mean</th>      <td>446.000000</td>      <td>0.383838</td>      <td>2.308642</td>      <td>29.699118</td>      <td>0.523008</td>      <td>0.381594</td>      <td>32.204208</td>    </tr>    <tr>      <th>std</th>      <td>257.353842</td>      <td>0.486592</td>      <td>0.836071</td>      <td>14.526497</td>      <td>1.102743</td>      <td>0.806057</td>      <td>49.693429</td>    </tr>    <tr>      <th>min</th>      <td>1.000000</td>      <td>0.000000</td>      <td>1.000000</td>      <td>0.420000</td>      <td>0.000000</td>      <td>0.000000</td>      <td>0.000000</td>    </tr>    <tr>      <th>25%</th>      <td>223.500000</td>      <td>0.000000</td>      <td>2.000000</td>      <td>20.125000</td>      <td>0.000000</td>      <td>0.000000</td>      <td>7.910400</td>    </tr>    <tr>      <th>50%</th>      <td>446.000000</td>      <td>0.000000</td>      <td>3.000000</td>      <td>28.000000</td>      <td>0.000000</td>      <td>0.000000</td>      <td>14.454200</td>    </tr>    <tr>      <th>75%</th>      <td>668.500000</td>      <td>1.000000</td>      <td>3.000000</td>      <td>38.000000</td>      <td>1.000000</td>      <td>0.000000</td>      <td>31.000000</td>    </tr>    <tr>      <th>max</th>      <td>891.000000</td>      <td>1.000000</td>      <td>3.000000</td>      <td>80.000000</td>      <td>8.000000</td>      <td>6.000000</td>      <td>512.329200</td>    </tr>  </tbody></table><p><code>count</code> 变量显示 <code>Age</code> 列中缺少177个值。</p><p>一种解决方案是用中值年龄填充空值。我们也可以用平均年龄来估算，但中位数对异常值更为稳健。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data[<span class="string">'Age'</span>] = data[<span class="string">'Age'</span>].fillna(data[<span class="string">'Age'</span>].median())</span><br></pre></td></tr></table></figure><p>让我们看一下结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.describe()</span><br></pre></td></tr></table></figure><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>PassengerId</th>      <th>Survived</th>      <th>Pclass</th>      <th>Age</th>      <th>SibSp</th>      <th>Parch</th>      <th>Fare</th>    </tr>  </thead>  <tbody>    <tr>      <th>count</th>      <td>891.000000</td>      <td>891.000000</td>      <td>891.000000</td>      <td>891.000000</td>      <td>891.000000</td>      <td>891.000000</td>      <td>891.000000</td>    </tr>    <tr>      <th>mean</th>      <td>446.000000</td>      <td>0.383838</td>      <td>2.308642</td>      <td>29.361582</td>      <td>0.523008</td>      <td>0.381594</td>      <td>32.204208</td>    </tr>    <tr>      <th>std</th>      <td>257.353842</td>      <td>0.486592</td>      <td>0.836071</td>      <td>13.019697</td>      <td>1.102743</td>      <td>0.806057</td>      <td>49.693429</td>    </tr>    <tr>      <th>min</th>      <td>1.000000</td>      <td>0.000000</td>      <td>1.000000</td>      <td>0.420000</td>      <td>0.000000</td>      <td>0.000000</td>      <td>0.000000</td>    </tr>    <tr>      <th>25%</th>      <td>223.500000</td>      <td>0.000000</td>      <td>2.000000</td>      <td>22.000000</td>      <td>0.000000</td>      <td>0.000000</td>      <td>7.910400</td>    </tr>    <tr>      <th>50%</th>      <td>446.000000</td>      <td>0.000000</td>      <td>3.000000</td>      <td>28.000000</td>      <td>0.000000</td>      <td>0.000000</td>      <td>14.454200</td>    </tr>    <tr>      <th>75%</th>      <td>668.500000</td>      <td>1.000000</td>      <td>3.000000</td>      <td>35.000000</td>      <td>1.000000</td>      <td>0.000000</td>      <td>31.000000</td>    </tr>    <tr>      <th>max</th>      <td>891.000000</td>      <td>1.000000</td>      <td>3.000000</td>      <td>80.000000</td>      <td>8.000000</td>      <td>6.000000</td>      <td>512.329200</td>    </tr>  </tbody></table><p>完美。</p><p>我们现在制作一些图表。让我们根据性别来看待生存。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data[<span class="string">'Died'</span>] = <span class="number">1</span> - data[<span class="string">'Survived'</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.groupby(<span class="string">'Sex'</span>).agg(<span class="string">'sum'</span>)[[<span class="string">'Survived'</span>, <span class="string">'Died'</span>]].plot(kind=<span class="string">'bar'</span>, figsize=(<span class="number">25</span>, <span class="number">7</span>),</span><br><span class="line">                                                          stacked=<span class="literal">True</span>, colors=[<span class="string">'g'</span>, <span class="string">'r'</span>]);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/qiwihui/How-to-score-0.8134-in-Titanic-Kaggle-Challenge/master/images/article_1/1.png" alt="png"></p><p>看起来男性乘客更容易死亡。让我们绘制相同的图形，但用比例代替。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.groupby(<span class="string">'Sex'</span>).agg(<span class="string">'mean'</span>)[[<span class="string">'Survived'</span>, <span class="string">'Died'</span>]].plot(kind=<span class="string">'bar'</span>, figsize=(<span class="number">25</span>, <span class="number">7</span>), </span><br><span class="line">                                                           stacked=<span class="literal">True</span>, colors=[<span class="string">'g'</span>, <span class="string">'r'</span>]);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/qiwihui/How-to-score-0.8134-in-Titanic-Kaggle-Challenge/master/images/article_1/2.png" alt="png"></p><p>性别变量似乎是一种歧视性特征。女性更有可能生存。</p><p>现在让我们将生存与年龄变量联系起来。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure(figsize=(<span class="number">25</span>, <span class="number">7</span>))</span><br><span class="line">sns.violinplot(x=<span class="string">'Sex'</span>, y=<span class="string">'Age'</span>, </span><br><span class="line">               hue=<span class="string">'Survived'</span>, data=data, </span><br><span class="line">               split=<span class="literal">True</span>,</span><br><span class="line">               palette=&#123;<span class="number">0</span>: <span class="string">"r"</span>, <span class="number">1</span>: <span class="string">"g"</span>&#125;</span><br><span class="line">              );</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/qiwihui/How-to-score-0.8134-in-Titanic-Kaggle-Challenge/master/images/article_1/3.png" alt="png"></p><p>正如我们在上面的图表中看到并通过以下方式验证：</p><ul><li>女性的生存率高于男性，如较大的女性绿色直方图所示</li></ul><p>现在，我们看到：</p><ul><li><p>年龄为男性乘客的生存：</p><ul><li>年轻的男性倾向于生存  * 20至40岁之间的大量乘客死亡</li></ul></li><li><p>年龄似乎没有对女性生存产生直接影响</p></li></ul><p>以下小提琴情节证实，在遇到威胁的情况下，水手和船长遵守一条旧的行为准则：“<strong>妇女和儿童优先！</strong>”。</p><p><img src="https://raw.githubusercontent.com/qiwihui/How-to-score-0.8134-in-Titanic-Kaggle-Challenge/master/images/article_1/titanic.jpg" alt="png"></p><p>对吗？</p><p>现在让我们关注每位乘客的票价，看看它如何影响生存。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">figure = plt.figure(figsize=(<span class="number">25</span>, <span class="number">7</span>))</span><br><span class="line">plt.hist([data[data[<span class="string">'Survived'</span>] == <span class="number">1</span>][<span class="string">'Fare'</span>], data[data[<span class="string">'Survived'</span>] == <span class="number">0</span>][<span class="string">'Fare'</span>]], </span><br><span class="line">         stacked=<span class="literal">True</span>, color = [<span class="string">'g'</span>,<span class="string">'r'</span>],</span><br><span class="line">         bins = <span class="number">50</span>, label = [<span class="string">'Survived'</span>,<span class="string">'Dead'</span>])</span><br><span class="line">plt.xlabel(<span class="string">'Fare'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Number of passengers'</span>)</span><br><span class="line">plt.legend();</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/qiwihui/How-to-score-0.8134-in-Titanic-Kaggle-Challenge/master/images/article_1/4.png" alt="png"></p><p>票价较低的乘客更容易死亡。换句话说，拥有更昂贵门票，因此更重要的社会地位的乘客似乎首先获救。</p><p>好的，这很好。 现在让我们将年龄，票价和生存结合在一张图表上。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">25</span>, <span class="number">7</span>))</span><br><span class="line">ax = plt.subplot()</span><br><span class="line"></span><br><span class="line">ax.scatter(data[data[<span class="string">'Survived'</span>] == <span class="number">1</span>][<span class="string">'Age'</span>], data[data[<span class="string">'Survived'</span>] == <span class="number">1</span>][<span class="string">'Fare'</span>], </span><br><span class="line">           c=<span class="string">'green'</span>, s=data[data[<span class="string">'Survived'</span>] == <span class="number">1</span>][<span class="string">'Fare'</span>])</span><br><span class="line">ax.scatter(data[data[<span class="string">'Survived'</span>] == <span class="number">0</span>][<span class="string">'Age'</span>], data[data[<span class="string">'Survived'</span>] == <span class="number">0</span>][<span class="string">'Fare'</span>], </span><br><span class="line">           c=<span class="string">'red'</span>, s=data[data[<span class="string">'Survived'</span>] == <span class="number">0</span>][<span class="string">'Fare'</span>]);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/qiwihui/How-to-score-0.8134-in-Titanic-Kaggle-Challenge/master/images/article_1/5.png" alt="png"></p><p>圆圈的大小与票价成正比。</p><p>在 x 轴上，我们有年龄，在 y 轴，我们考虑票价。</p><p>我们可以观察不同的集群：</p><ol><li>x = 20 和 x = 45 之间的大绿点：票价最高的成人</li><li>x = 10 和 x = 45 之间的小红点，船上较低级别的成年人</li><li>x = 0 和 x = 7 之间的小密集点：这些是被保存的孩子</li></ol><p>事实上，票价与我们在下面的图表中看到的类别相关。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ax = plt.subplot()</span><br><span class="line">ax.set_ylabel(<span class="string">'Average fare'</span>)</span><br><span class="line">data.groupby(<span class="string">'Pclass'</span>).mean()[<span class="string">'Fare'</span>].plot(kind=<span class="string">'bar'</span>, figsize=(<span class="number">25</span>, <span class="number">7</span>), ax = ax);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/qiwihui/How-to-score-0.8134-in-Titanic-Kaggle-Challenge/master/images/article_1/6.png" alt="png"></p><p>现在让我们看看登船地点如何影响生存。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure(figsize=(<span class="number">25</span>, <span class="number">7</span>))</span><br><span class="line">sns.violinplot(x=<span class="string">'Embarked'</span>, y=<span class="string">'Fare'</span>, hue=<span class="string">'Survived'</span>, data=data, split=<span class="literal">True</span>, palette=&#123;<span class="number">0</span>: <span class="string">"r"</span>, <span class="number">1</span>: <span class="string">"g"</span>&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/qiwihui/How-to-score-0.8134-in-Titanic-Kaggle-Challenge/master/images/article_1/7.png" alt="png"></p><p>似乎登船地点 C 的票价范围更广，因此支付最高价格的乘客是那些幸存的乘客。</p><p>我们也看到这种情况发生在登船地点 S 而不是登船地点 Q。</p><p>现在让我们停止数据探索并切换到下一部分。</p><h2>II - 特征工程</h2><p>在前一部分中，我们调查了数据并发现了一些有趣的相关性。</p><p>在这一部分中，我们将看到如何处理和转换这些变量，使数据变得可以通过机器学习算法进行管理。</p><p>我们还将创建或“设计”在构建模型时有用的其他功能。</p><p>我们将在此过程中看到如何处理文本变量（如乘客姓名）并将此信息集成到我们的模型中。</p><p>为了更加清晰，我们将代码分散在单独的函数中。</p><p>但首先，让我们定义一个打印函数，断言是否已经处理了一个特征。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">status</span><span class="params">(feature)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Processing'</span>, feature, <span class="string">': ok'</span></span><br></pre></td></tr></table></figure><h3>加载数据</h3><p>启动机器学习问题的一个技巧是将训练集一起附加到测试集。</p><p>我们将使用训练集进行特征工程以防止信息泄漏。然后我们将这些变量添加到测试集中。</p><p>让我们加载训练集和测试集并将它们合在一起。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_combined_data</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># reading train data</span></span><br><span class="line">    train = pd.read_csv(<span class="string">'./data/train.csv'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># reading test data</span></span><br><span class="line">    test = pd.read_csv(<span class="string">'./data/test.csv'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># extracting and then removing the targets from the training data </span></span><br><span class="line">    targets = train.Survived</span><br><span class="line">    train.drop([<span class="string">'Survived'</span>], <span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># merging train data and test data for future feature engineering</span></span><br><span class="line">    <span class="comment"># we'll also remove the PassengerID since this is not an informative feature</span></span><br><span class="line">    combined = train.append(test)</span><br><span class="line">    combined.reset_index(inplace=<span class="literal">True</span>)</span><br><span class="line">    combined.drop([<span class="string">'index'</span>, <span class="string">'PassengerId'</span>], inplace=<span class="literal">True</span>, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> combined</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined = get_combined_data()</span><br></pre></td></tr></table></figure><p>让我们看一下数据的维度。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> combined.shape</span><br></pre></td></tr></table></figure><pre><code>(1309, 10)</code></pre><p>训练集和测试集被合并。您可能会注意到总行数（1309）是训练集和测试集中行数的精确总和。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined.head()</span><br></pre></td></tr></table></figure><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Pclass</th>      <th>Name</th>      <th>Sex</th>      <th>Age</th>      <th>SibSp</th>      <th>Parch</th>      <th>Ticket</th>      <th>Fare</th>      <th>Cabin</th>      <th>Embarked</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>3</td>      <td>Braund, Mr. Owen Harris</td>      <td>male</td>      <td>22.0</td>      <td>1</td>      <td>0</td>      <td>A/5 21171</td>      <td>7.2500</td>      <td>NaN</td>      <td>S</td>    </tr>    <tr>      <th>1</th>      <td>1</td>      <td>Cumings, Mrs. John Bradley (Florence Briggs Th...</td>      <td>female</td>      <td>38.0</td>      <td>1</td>      <td>0</td>      <td>PC 17599</td>      <td>71.2833</td>      <td>C85</td>      <td>C</td>    </tr>    <tr>      <th>2</th>      <td>3</td>      <td>Heikkinen, Miss. Laina</td>      <td>female</td>      <td>26.0</td>      <td>0</td>      <td>0</td>      <td>STON/O2. 3101282</td>      <td>7.9250</td>      <td>NaN</td>      <td>S</td>    </tr>    <tr>      <th>3</th>      <td>1</td>      <td>Futrelle, Mrs. Jacques Heath (Lily May Peel)</td>      <td>female</td>      <td>35.0</td>      <td>1</td>      <td>0</td>      <td>113803</td>      <td>53.1000</td>      <td>C123</td>      <td>S</td>    </tr>    <tr>      <th>4</th>      <td>3</td>      <td>Allen, Mr. William Henry</td>      <td>male</td>      <td>35.0</td>      <td>0</td>      <td>0</td>      <td>373450</td>      <td>8.0500</td>      <td>NaN</td>      <td>S</td>    </tr>  </tbody></table><h3>提取乘客称谓</h3><p>在查看乘客姓名时，人们可能想知道如何处理它们以提取有用的信息。</p><p>如果你仔细看看这些第一个例子：</p><ul><li>Braund, <strong>Mr.</strong> Owen Harris</li><li>Heikkinen, <strong>Miss.</strong> Laina</li><li>Oliva y Ocana, <strong>Dona.</strong> Fermina</li><li>Peter, <strong>Master.</strong> Michael J</li></ul><p>你会注意到每个名字都有一个称谓！这可能是一个简单的小姐（Miss.）或太太（Mrs.），但它有时可能像 Master，Sir 或 Dona 那样更复杂。在这种情况下，我们可以通过简单地解析称谓并提取标题并转换为二进制变量来引入有关社会地位的其他信息。</p><p>让我们看看我们将如何在下面的函数中执行此操作。</p><p>让我们先来看看在训练集中有什么不同的称谓。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">titles = set()</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> data[<span class="string">'Name'</span>]:</span><br><span class="line">    titles.add(name.split(<span class="string">','</span>)[<span class="number">1</span>].split(<span class="string">'.'</span>)[<span class="number">0</span>].strip())</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> titles</span><br></pre></td></tr></table></figure><pre><code>set(['Sir', 'Major', 'the Countess', 'Don', 'Mlle', 'Capt', 'Dr', 'Lady', 'Rev', 'Mrs', 'Jonkheer', 'Master', 'Ms', 'Mr', 'Mme', 'Miss', 'Col'])</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Title_Dictionary = &#123;</span><br><span class="line">    <span class="string">"Capt"</span>: <span class="string">"Officer"</span>,</span><br><span class="line">    <span class="string">"Col"</span>: <span class="string">"Officer"</span>,</span><br><span class="line">    <span class="string">"Major"</span>: <span class="string">"Officer"</span>,</span><br><span class="line">    <span class="string">"Jonkheer"</span>: <span class="string">"Royalty"</span>,</span><br><span class="line">    <span class="string">"Don"</span>: <span class="string">"Royalty"</span>,</span><br><span class="line">    <span class="string">"Sir"</span> : <span class="string">"Royalty"</span>,</span><br><span class="line">    <span class="string">"Dr"</span>: <span class="string">"Officer"</span>,</span><br><span class="line">    <span class="string">"Rev"</span>: <span class="string">"Officer"</span>,</span><br><span class="line">    <span class="string">"the Countess"</span>:<span class="string">"Royalty"</span>,</span><br><span class="line">    <span class="string">"Mme"</span>: <span class="string">"Mrs"</span>,</span><br><span class="line">    <span class="string">"Mlle"</span>: <span class="string">"Miss"</span>,</span><br><span class="line">    <span class="string">"Ms"</span>: <span class="string">"Mrs"</span>,</span><br><span class="line">    <span class="string">"Mr"</span> : <span class="string">"Mr"</span>,</span><br><span class="line">    <span class="string">"Mrs"</span> : <span class="string">"Mrs"</span>,</span><br><span class="line">    <span class="string">"Miss"</span> : <span class="string">"Miss"</span>,</span><br><span class="line">    <span class="string">"Master"</span> : <span class="string">"Master"</span>,</span><br><span class="line">    <span class="string">"Lady"</span> : <span class="string">"Royalty"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_titles</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># we extract the title from each name</span></span><br><span class="line">    combined[<span class="string">'Title'</span>] = combined[<span class="string">'Name'</span>].map(<span class="keyword">lambda</span> name:name.split(<span class="string">','</span>)[<span class="number">1</span>].split(<span class="string">'.'</span>)[<span class="number">0</span>].strip())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># a map of more aggregated title</span></span><br><span class="line">    <span class="comment"># we map each title</span></span><br><span class="line">    combined[<span class="string">'Title'</span>] = combined.Title.map(Title_Dictionary)</span><br><span class="line">    status(<span class="string">'Title'</span>)</span><br><span class="line">    <span class="keyword">return</span> combined</span><br></pre></td></tr></table></figure><p>此函数解析名称并提取称谓。 然后，它将称谓映射到称谓类别。我们选择：</p><ul><li>Officer</li><li>Royalty</li><li>Mr</li><li>Mrs</li><li>Miss</li><li>Master</li></ul><p>让我们运行一下！</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined = get_titles()</span><br></pre></td></tr></table></figure><pre><code>Processing Title : ok</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined.head()</span><br></pre></td></tr></table></figure><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Pclass</th>      <th>Name</th>      <th>Sex</th>      <th>Age</th>      <th>SibSp</th>      <th>Parch</th>      <th>Ticket</th>      <th>Fare</th>      <th>Cabin</th>      <th>Embarked</th>      <th>Title</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>3</td>      <td>Braund, Mr. Owen Harris</td>      <td>male</td>      <td>22.0</td>      <td>1</td>      <td>0</td>      <td>A/5 21171</td>      <td>7.2500</td>      <td>NaN</td>      <td>S</td>      <td>Mr</td>    </tr>    <tr>      <th>1</th>      <td>1</td>      <td>Cumings, Mrs. John Bradley (Florence Briggs Th...</td>      <td>female</td>      <td>38.0</td>      <td>1</td>      <td>0</td>      <td>PC 17599</td>      <td>71.2833</td>      <td>C85</td>      <td>C</td>      <td>Mrs</td>    </tr>    <tr>      <th>2</th>      <td>3</td>      <td>Heikkinen, Miss. Laina</td>      <td>female</td>      <td>26.0</td>      <td>0</td>      <td>0</td>      <td>STON/O2. 3101282</td>      <td>7.9250</td>      <td>NaN</td>      <td>S</td>      <td>Miss</td>    </tr>    <tr>      <th>3</th>      <td>1</td>      <td>Futrelle, Mrs. Jacques Heath (Lily May Peel)</td>      <td>female</td>      <td>35.0</td>      <td>1</td>      <td>0</td>      <td>113803</td>      <td>53.1000</td>      <td>C123</td>      <td>S</td>      <td>Mrs</td>    </tr>    <tr>      <th>4</th>      <td>3</td>      <td>Allen, Mr. William Henry</td>      <td>male</td>      <td>35.0</td>      <td>0</td>      <td>0</td>      <td>373450</td>      <td>8.0500</td>      <td>NaN</td>      <td>S</td>      <td>Mr</td>    </tr>  </tbody></table><p>让我们检查一下称谓是否填写正确。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined[combined[<span class="string">'Title'</span>].isnull()]</span><br></pre></td></tr></table></figure><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Pclass</th>      <th>Name</th>      <th>Sex</th>      <th>Age</th>      <th>SibSp</th>      <th>Parch</th>      <th>Ticket</th>      <th>Fare</th>      <th>Cabin</th>      <th>Embarked</th>      <th>Title</th>    </tr>  </thead>  <tbody>    <tr>      <th>1305</th>      <td>1</td>      <td>Oliva y Ocana, Dona. Fermina</td>      <td>female</td>      <td>39.0</td>      <td>0</td>      <td>0</td>      <td>PC 17758</td>      <td>108.9</td>      <td>C105</td>      <td>C</td>      <td>NaN</td>    </tr>  </tbody></table><p>在1305行中确实存在 NaN 值。实际上相应的名称是 <code>Oliva y Ocana, **Dona**. Fermina</code>。</p><p>在训练数据集中没有遇到这个标题。</p><p>很好，现在我们有一个名为 <strong>Title</strong> 的附加列来包含这些信息。</p><h3>处理年龄（Age）</h3><p>我们在第一部分中看到 <code>Age</code> 变量缺少177个值。这是一个很大的数字（约占数据集的13％）。简单地用平均年龄或中位年龄替换它们可能不是最佳解决方案，因为年龄可能因乘客的类别和类别而不同。</p><p>为了理解原因，让我们按性别（Sex），称谓（Title）和乘客类（Pclass）对我们的数据集进行分组，并为每个子集计算中位数年龄。</p><p>为了避免测试集中的数据泄漏，我们使用训练集填写训练中的缺失年龄，并且我们使用从训练集计算的值来填充测试集中的年龄。</p><p>训练级中缺少的年龄数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> combined.iloc[:<span class="number">891</span>].Age.isnull().sum()</span><br></pre></td></tr></table></figure><pre><code>177</code></pre><p>测试集中缺少的年龄数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> combined.iloc[<span class="number">891</span>:].Age.isnull().sum()</span><br></pre></td></tr></table></figure><pre><code>86</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">grouped_train = combined.iloc[:<span class="number">891</span>].groupby([<span class="string">'Sex'</span>,<span class="string">'Pclass'</span>,<span class="string">'Title'</span>])</span><br><span class="line">grouped_median_train = grouped_train.median()</span><br><span class="line">grouped_median_train = grouped_median_train.reset_index()[[<span class="string">'Sex'</span>, <span class="string">'Pclass'</span>, <span class="string">'Title'</span>, <span class="string">'Age'</span>]]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">grouped_median_train.head()</span><br></pre></td></tr></table></figure><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Sex</th>      <th>Pclass</th>      <th>Title</th>      <th>Age</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>female</td>      <td>1</td>      <td>Miss</td>      <td>30.0</td>    </tr>    <tr>      <th>1</th>      <td>female</td>      <td>1</td>      <td>Mrs</td>      <td>40.0</td>    </tr>    <tr>      <th>2</th>      <td>female</td>      <td>1</td>      <td>Officer</td>      <td>49.0</td>    </tr>    <tr>      <th>3</th>      <td>female</td>      <td>1</td>      <td>Royalty</td>      <td>40.5</td>    </tr>    <tr>      <th>4</th>      <td>female</td>      <td>2</td>      <td>Miss</td>      <td>24.0</td>    </tr>  </tbody></table><p>此 dataframe 将帮助我们根据不同的标准估算缺失的年龄值。</p><p>查看中位年龄列，看看这个值如何根据 <code>Sex</code>，<code>Pclass</code> 和 <code>Title</code> 组合在一起。</p><p>例如：</p><ul><li>如果乘客是女性，则来自 Pclass 1 和来自王室（royalty），中位年龄为40.5岁。</li><li>如果乘客是男性，来自 Pclass 3，拥有 Mr 称谓，则年龄中位数为26岁。</li></ul><p>让我们创建一个函数，根据这些不同的属性填充 <strong>组合</strong> 中的缺失年龄。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill_age</span><span class="params">(row)</span>:</span></span><br><span class="line">    condition = (</span><br><span class="line">        (grouped_median_train[<span class="string">'Sex'</span>] == row[<span class="string">'Sex'</span>]) &amp; </span><br><span class="line">        (grouped_median_train[<span class="string">'Title'</span>] == row[<span class="string">'Title'</span>]) &amp; </span><br><span class="line">        (grouped_median_train[<span class="string">'Pclass'</span>] == row[<span class="string">'Pclass'</span>])</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> grouped_median_train[condition][<span class="string">'Age'</span>].values[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_age</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> combined</span><br><span class="line">    <span class="comment"># a function that fills the missing values of the Age variable</span></span><br><span class="line">    combined[<span class="string">'Age'</span>] = combined.apply(<span class="keyword">lambda</span> row: fill_age(row) <span class="keyword">if</span> np.isnan(row[<span class="string">'Age'</span>]) <span class="keyword">else</span> row[<span class="string">'Age'</span>], axis=<span class="number">1</span>)</span><br><span class="line">    status(<span class="string">'age'</span>)</span><br><span class="line">    <span class="keyword">return</span> combined</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined = process_age()</span><br></pre></td></tr></table></figure><pre><code>Processing age : ok</code></pre><p>完美。失踪的年龄已被取代。</p><p>但是，我们注意到票价（Fare）中缺少1个值，登船位置（Embarked）有两个缺失值，而船舱位置（Cabin）有很多缺失值。我们稍后会处理这些变量。</p><p>我们现在处理名字。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_names</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> combined</span><br><span class="line">    <span class="comment"># we clean the Name variable</span></span><br><span class="line">    combined.drop(<span class="string">'Name'</span>, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># encoding in dummy variable</span></span><br><span class="line">    titles_dummies = pd.get_dummies(combined[<span class="string">'Title'</span>], prefix=<span class="string">'Title'</span>)</span><br><span class="line">    combined = pd.concat([combined, titles_dummies], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># removing the title variable</span></span><br><span class="line">    combined.drop(<span class="string">'Title'</span>, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    status(<span class="string">'names'</span>)</span><br><span class="line">    <span class="keyword">return</span> combined</span><br></pre></td></tr></table></figure><p>此函数会删除 <code>Name</code> 列，我们不再使用它，因为我们创建了 <code>Title</code> 列。</p><p>然后我们使用虚拟编码（dummy encoding）对称谓值进行编码。</p><p>您可以了解虚拟编码以及如何在 <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.get_dummies.html" target="_blank" rel="noopener">Pandas</a> 中轻松完成此操作。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined = process_names()</span><br></pre></td></tr></table></figure><pre><code>Processing names : ok</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined.head()</span><br></pre></td></tr></table></figure><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Pclass</th>      <th>Sex</th>      <th>Age</th>      <th>SibSp</th>      <th>Parch</th>      <th>Ticket</th>      <th>Fare</th>      <th>Cabin</th>      <th>Embarked</th>      <th>Title_Master</th>      <th>Title_Miss</th>      <th>Title_Mr</th>      <th>Title_Mrs</th>      <th>Title_Officer</th>      <th>Title_Royalty</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>3</td>      <td>male</td>      <td>22.0</td>      <td>1</td>      <td>0</td>      <td>A/5 21171</td>      <td>7.2500</td>      <td>NaN</td>      <td>S</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <th>1</th>      <td>1</td>      <td>female</td>      <td>38.0</td>      <td>1</td>      <td>0</td>      <td>PC 17599</td>      <td>71.2833</td>      <td>C85</td>      <td>C</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <th>2</th>      <td>3</td>      <td>female</td>      <td>26.0</td>      <td>0</td>      <td>0</td>      <td>STON/O2. 3101282</td>      <td>7.9250</td>      <td>NaN</td>      <td>S</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <th>3</th>      <td>1</td>      <td>female</td>      <td>35.0</td>      <td>1</td>      <td>0</td>      <td>113803</td>      <td>53.1000</td>      <td>C123</td>      <td>S</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <th>4</th>      <td>3</td>      <td>male</td>      <td>35.0</td>      <td>0</td>      <td>0</td>      <td>373450</td>      <td>8.0500</td>      <td>NaN</td>      <td>S</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>    </tr>  </tbody></table><p>如你看到的 ：</p><ul><li>不再有名字特征。</li><li>出现了新的变量（Title_X）。这些特征是二进制的。<ul><li>例如，如果 Title_Mr = 1，则相应的称谓为 Mr。</li></ul></li></ul><h3>处理票价（Fare）</h3><p>让我们通过在训练集上计算的平均票价估算缺失的票价值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_fares</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> combined</span><br><span class="line">    <span class="comment"># there's one missing fare value - replacing it with the mean.</span></span><br><span class="line">    combined.Fare.fillna(combined.iloc[:<span class="number">891</span>].Fare.mean(), inplace=<span class="literal">True</span>)</span><br><span class="line">    status(<span class="string">'fare'</span>)</span><br><span class="line">    <span class="keyword">return</span> combined</span><br></pre></td></tr></table></figure><p>此函数用平均值替换一个缺失的票价（Fare）值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined = process_fares()</span><br></pre></td></tr></table></figure><pre><code>Processing fare : ok</code></pre><h3>处理登船位置（Embarked）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_embarked</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> combined</span><br><span class="line">    <span class="comment"># two missing embarked values - filling them with the most frequent one in the train  set(S)</span></span><br><span class="line">    combined.Embarked.fillna(<span class="string">'S'</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># dummy encoding</span></span><br><span class="line">    embarked_dummies = pd.get_dummies(combined[<span class="string">'Embarked'</span>], prefix=<span class="string">'Embarked'</span>)</span><br><span class="line">    combined = pd.concat([combined, embarked_dummies], axis=<span class="number">1</span>)</span><br><span class="line">    combined.drop(<span class="string">'Embarked'</span>, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    status(<span class="string">'embarked'</span>)</span><br><span class="line">    <span class="keyword">return</span> combined</span><br></pre></td></tr></table></figure><p>此函数用最常用的 <code>Embarked</code> 值替换了两个缺失的 <code>Embarked</code> 值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined = process_embarked()</span><br></pre></td></tr></table></figure><pre><code>Processing embarked : ok</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined.head()</span><br></pre></td></tr></table></figure><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Pclass</th>      <th>Sex</th>      <th>Age</th>      <th>SibSp</th>      <th>Parch</th>      <th>Ticket</th>      <th>Fare</th>      <th>Cabin</th>      <th>Title_Master</th>      <th>Title_Miss</th>      <th>Title_Mr</th>      <th>Title_Mrs</th>      <th>Title_Officer</th>      <th>Title_Royalty</th>      <th>Embarked_C</th>      <th>Embarked_Q</th>      <th>Embarked_S</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>3</td>      <td>male</td>      <td>22.0</td>      <td>1</td>      <td>0</td>      <td>A/5 21171</td>      <td>7.2500</td>      <td>NaN</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>1</th>      <td>1</td>      <td>female</td>      <td>38.0</td>      <td>1</td>      <td>0</td>      <td>PC 17599</td>      <td>71.2833</td>      <td>C85</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <th>2</th>      <td>3</td>      <td>female</td>      <td>26.0</td>      <td>0</td>      <td>0</td>      <td>STON/O2. 3101282</td>      <td>7.9250</td>      <td>NaN</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>3</th>      <td>1</td>      <td>female</td>      <td>35.0</td>      <td>1</td>      <td>0</td>      <td>113803</td>      <td>53.1000</td>      <td>C123</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>4</th>      <td>3</td>      <td>male</td>      <td>35.0</td>      <td>0</td>      <td>0</td>      <td>373450</td>      <td>8.0500</td>      <td>NaN</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>    </tr>  </tbody></table><h3>处理船舱位置（Cabin）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_cabin, test_cabin = set(), set()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> combined.iloc[:<span class="number">891</span>][<span class="string">'Cabin'</span>]:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        train_cabin.add(c[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        train_cabin.add(<span class="string">'U'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> combined.iloc[<span class="number">891</span>:][<span class="string">'Cabin'</span>]:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        test_cabin.add(c[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        test_cabin.add(<span class="string">'U'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> train_cabin</span><br></pre></td></tr></table></figure><pre><code>set(['A', 'C', 'B', 'E', 'D', 'G', 'F', 'U', 'T'])</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> test_cabin</span><br></pre></td></tr></table></figure><pre><code>set(['A', 'C', 'B', 'E', 'D', 'G', 'F', 'U'])</code></pre><p>我们在测试集中没有任何不存在于训练集中的船舱位置字母。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_cabin</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> combined</span><br><span class="line">    <span class="comment"># replacing missing cabins with U (for Uknown)</span></span><br><span class="line">    combined.Cabin.fillna(<span class="string">'U'</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># mapping each Cabin value with the cabin letter</span></span><br><span class="line">    combined[<span class="string">'Cabin'</span>] = combined[<span class="string">'Cabin'</span>].map(<span class="keyword">lambda</span> c: c[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># dummy encoding ...</span></span><br><span class="line">    cabin_dummies = pd.get_dummies(combined[<span class="string">'Cabin'</span>], prefix=<span class="string">'Cabin'</span>)</span><br><span class="line">    combined = pd.concat([combined, cabin_dummies], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    combined.drop(<span class="string">'Cabin'</span>, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    status(<span class="string">'cabin'</span>)</span><br><span class="line">    <span class="keyword">return</span> combined</span><br></pre></td></tr></table></figure><p>此函数将 <code>NaN</code> 值替换为 U（表示 <em>Unknow</em> ）。 然后它将每个 <code>Cabin</code> 值映射到第一个字母。然后它再次使用虚拟编码对舱位值进行编码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined = process_cabin()</span><br></pre></td></tr></table></figure><pre><code>Processing cabin : ok</code></pre><p>好了，没有缺失值了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined.head()</span><br></pre></td></tr></table></figure><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Pclass</th>      <th>Sex</th>      <th>Age</th>      <th>SibSp</th>      <th>Parch</th>      <th>Ticket</th>      <th>Fare</th>      <th>Title_Master</th>      <th>Title_Miss</th>      <th>Title_Mr</th>      <th>Title_Mrs</th>      <th>Title_Officer</th>      <th>Title_Royalty</th>      <th>Embarked_C</th>      <th>Embarked_Q</th>      <th>Embarked_S</th>      <th>Cabin_A</th>      <th>Cabin_B</th>      <th>Cabin_C</th>      <th>Cabin_D</th>      <th>Cabin_E</th>      <th>Cabin_F</th>      <th>Cabin_G</th>      <th>Cabin_T</th>      <th>Cabin_U</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>3</td>      <td>male</td>      <td>22.0</td>      <td>1</td>      <td>0</td>      <td>A/5 21171</td>      <td>7.2500</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>1</th>      <td>1</td>      <td>female</td>      <td>38.0</td>      <td>1</td>      <td>0</td>      <td>PC 17599</td>      <td>71.2833</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <th>2</th>      <td>3</td>      <td>female</td>      <td>26.0</td>      <td>0</td>      <td>0</td>      <td>STON/O2. 3101282</td>      <td>7.9250</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>3</th>      <td>1</td>      <td>female</td>      <td>35.0</td>      <td>1</td>      <td>0</td>      <td>113803</td>      <td>53.1000</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <th>4</th>      <td>3</td>      <td>male</td>      <td>35.0</td>      <td>0</td>      <td>0</td>      <td>373450</td>      <td>8.0500</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>    </tr>  </tbody></table><h3>处理性别（Sex）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_sex</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> combined</span><br><span class="line">    <span class="comment"># mapping string values to numerical one</span></span><br><span class="line">    combined[<span class="string">'Sex'</span>] = combined[<span class="string">'Sex'</span>].map(&#123;<span class="string">'male'</span>:<span class="number">1</span>, <span class="string">'female'</span>:<span class="number">0</span>&#125;)</span><br><span class="line">    status(<span class="string">'Sex'</span>)</span><br><span class="line">    <span class="keyword">return</span> combined</span><br></pre></td></tr></table></figure><p>此函数将字符串值 <code>male</code> 和 <code>female</code> 分别映射到1和0。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined = process_sex()</span><br></pre></td></tr></table></figure><pre><code>Processing Sex : ok</code></pre><h3>处理乘客等级（Pclass）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_pclass</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">global</span> combined</span><br><span class="line">    <span class="comment"># encoding into 3 categories:</span></span><br><span class="line">    pclass_dummies = pd.get_dummies(combined[<span class="string">'Pclass'</span>], prefix=<span class="string">"Pclass"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># adding dummy variable</span></span><br><span class="line">    combined = pd.concat([combined, pclass_dummies],axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># removing "Pclass"</span></span><br><span class="line">    combined.drop(<span class="string">'Pclass'</span>,axis=<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    status(<span class="string">'Pclass'</span>)</span><br><span class="line">    <span class="keyword">return</span> combined</span><br></pre></td></tr></table></figure><p>此函数使用虚拟编码对 Pclass（1,2,3）的值进行编码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined = process_pclass()</span><br></pre></td></tr></table></figure><pre><code>Processing Pclass : ok</code></pre><h3>处理船票号码（Ticket）</h3><p>让我们首先看看我们的数据集中不同的船票号码前缀</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cleanTicket</span><span class="params">(ticket)</span>:</span></span><br><span class="line">    ticket = ticket.replace(<span class="string">'.'</span>, <span class="string">''</span>)</span><br><span class="line">    ticket = ticket.replace(<span class="string">'/'</span>, <span class="string">''</span>)</span><br><span class="line">    ticket = ticket.split()</span><br><span class="line">    ticket = map(<span class="keyword">lambda</span> t : t.strip(), ticket)</span><br><span class="line">    ticket = list(filter(<span class="keyword">lambda</span> t : <span class="keyword">not</span> t.isdigit(), ticket))</span><br><span class="line">    <span class="keyword">if</span> len(ticket) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> ticket[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'XXX'</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tickets = set()</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> combined[<span class="string">'Ticket'</span>]:</span><br><span class="line">    tickets.add(cleanTicket(t))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> len(tickets)</span><br></pre></td></tr></table></figure><pre><code>37</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_ticket</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">global</span> combined</span><br><span class="line"></span><br><span class="line">    <span class="comment"># a function that extracts each prefix of the ticket, returns 'XXX' if no prefix (i.e the ticket is a digit)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cleanTicket</span><span class="params">(ticket)</span>:</span></span><br><span class="line">        ticket = ticket.replace(<span class="string">'.'</span>,<span class="string">''</span>)</span><br><span class="line">        ticket = ticket.replace(<span class="string">'/'</span>,<span class="string">''</span>)</span><br><span class="line">        ticket = ticket.split()</span><br><span class="line">        ticket = map(<span class="keyword">lambda</span> t : t.strip(), ticket)</span><br><span class="line">        ticket = filter(<span class="keyword">lambda</span> t : <span class="keyword">not</span> t.isdigit(), ticket)</span><br><span class="line">        <span class="keyword">if</span> len(ticket) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> ticket[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'XXX'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Extracting dummy variables from tickets:</span></span><br><span class="line"></span><br><span class="line">    combined[<span class="string">'Ticket'</span>] = combined[<span class="string">'Ticket'</span>].map(cleanTicket)</span><br><span class="line">    tickets_dummies = pd.get_dummies(combined[<span class="string">'Ticket'</span>], prefix=<span class="string">'Ticket'</span>)</span><br><span class="line">    combined = pd.concat([combined, tickets_dummies], axis=<span class="number">1</span>)</span><br><span class="line">    combined.drop(<span class="string">'Ticket'</span>, inplace=<span class="literal">True</span>, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    status(<span class="string">'Ticket'</span>)</span><br><span class="line">    <span class="keyword">return</span> combined</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined = process_ticket()</span><br></pre></td></tr></table></figure><pre><code>Processing Ticket : ok</code></pre><h3>处理家庭</h3><p>这部分包括根据家庭的大小创建新变量（大小是我们创建的另一个变量）。</p><p>这种新变量的创建是在一个现实的假设下完成的：大家庭聚集在一起，因此他们比单独旅行的人更有可能获救。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_family</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">global</span> combined</span><br><span class="line">    <span class="comment"># introducing a new feature : the size of families (including the passenger)</span></span><br><span class="line">    combined[<span class="string">'FamilySize'</span>] = combined[<span class="string">'Parch'</span>] + combined[<span class="string">'SibSp'</span>] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># introducing other features based on the family size</span></span><br><span class="line">    combined[<span class="string">'Singleton'</span>] = combined[<span class="string">'FamilySize'</span>].map(<span class="keyword">lambda</span> s: <span class="number">1</span> <span class="keyword">if</span> s == <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">    combined[<span class="string">'SmallFamily'</span>] = combined[<span class="string">'FamilySize'</span>].map(<span class="keyword">lambda</span> s: <span class="number">1</span> <span class="keyword">if</span> <span class="number">2</span> &lt;= s &lt;= <span class="number">4</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">    combined[<span class="string">'LargeFamily'</span>] = combined[<span class="string">'FamilySize'</span>].map(<span class="keyword">lambda</span> s: <span class="number">1</span> <span class="keyword">if</span> <span class="number">5</span> &lt;= s <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    status(<span class="string">'family'</span>)</span><br><span class="line">    <span class="keyword">return</span> combined</span><br></pre></td></tr></table></figure><p>此函数引入了4个新特征：</p><ul><li><code>FamilySize</code>：包括乘客（他/她）自己在内的亲属总数。</li><li><code>Sigleton</code>：描述 size = 1 的家庭的布尔变量</li><li><code>SmallFamily</code>：一个布尔变量，描述 2 &lt;= size &lt;= 4 的家庭</li><li><code>LargeFamily</code>：一个布尔变量，描述 5 &lt; size 的家庭</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined = process_family()</span><br></pre></td></tr></table></figure><pre><code>Processing family : ok</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> combined.shape</span><br></pre></td></tr></table></figure><pre><code>(1309, 67)</code></pre><p>最后我们得到了67个特征。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined.head()</span><br></pre></td></tr></table></figure><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Sex</th>      <th>Age</th>      <th>SibSp</th>      <th>Parch</th>      <th>Fare</th>      <th>Title_Master</th>      <th>Title_Miss</th>      <th>Title_Mr</th>      <th>Title_Mrs</th>      <th>Title_Officer</th>      <th>Title_Royalty</th>      <th>Embarked_C</th>      <th>Embarked_Q</th>      <th>Embarked_S</th>      <th>Cabin_A</th>      <th>Cabin_B</th>      <th>Cabin_C</th>      <th>Cabin_D</th>      <th>Cabin_E</th>      <th>Cabin_F</th>      <th>Cabin_G</th>      <th>Cabin_T</th>      <th>Cabin_U</th>      <th>Pclass_1</th>      <th>Pclass_2</th>      <th>Pclass_3</th>      <th>Ticket_A</th>      <th>Ticket_A4</th>      <th>Ticket_A5</th>      <th>Ticket_AQ3</th>      <th>Ticket_AQ4</th>      <th>Ticket_AS</th>      <th>Ticket_C</th>      <th>Ticket_CA</th>      <th>Ticket_CASOTON</th>      <th>Ticket_FC</th>      <th>Ticket_FCC</th>      <th>Ticket_Fa</th>      <th>Ticket_LINE</th>      <th>Ticket_LP</th>      <th>Ticket_PC</th>      <th>Ticket_PP</th>      <th>Ticket_PPP</th>      <th>Ticket_SC</th>      <th>Ticket_SCA3</th>      <th>Ticket_SCA4</th>      <th>Ticket_SCAH</th>      <th>Ticket_SCOW</th>      <th>Ticket_SCPARIS</th>      <th>Ticket_SCParis</th>      <th>Ticket_SOC</th>      <th>Ticket_SOP</th>      <th>Ticket_SOPP</th>      <th>Ticket_SOTONO2</th>      <th>Ticket_SOTONOQ</th>      <th>Ticket_SP</th>      <th>Ticket_STONO</th>      <th>Ticket_STONO2</th>      <th>Ticket_STONOQ</th>      <th>Ticket_SWPP</th>      <th>Ticket_WC</th>      <th>Ticket_WEP</th>      <th>Ticket_XXX</th>      <th>FamilySize</th>      <th>Singleton</th>      <th>SmallFamily</th>      <th>LargeFamily</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>1</td>      <td>22.0</td>      <td>1</td>      <td>0</td>      <td>7.2500</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>2</td>      <td>0</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>1</th>      <td>0</td>      <td>38.0</td>      <td>1</td>      <td>0</td>      <td>71.2833</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>2</td>      <td>0</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>2</th>      <td>0</td>      <td>26.0</td>      <td>0</td>      <td>0</td>      <td>7.9250</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>1</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <th>3</th>      <td>0</td>      <td>35.0</td>      <td>1</td>      <td>0</td>      <td>53.1000</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>2</td>      <td>0</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>4</th>      <td>1</td>      <td>35.0</td>      <td>0</td>      <td>0</td>      <td>8.0500</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td>0</td>      <td>0</td>    </tr>  </tbody></table><h2>III - 模型</h2><p>在这一部分中，我们根据我们创建的特征建立统计模型。您可以将此模型视为一个盒子，它可以处理任何新乘客的信息，并决定他是否能够幸存。</p><p>有各种各样的模型可供使用，从逻辑回归到决策树，以及更复杂的模型，如随机森林和梯度提升树。</p><p>我们将使用随机森林。Random Froests 在 Kaggle 比赛中证明了很高的有效性。</p><p>有关为什么集合方法表现良好的更多详细信息，您可以参考这些帖子：</p><ul><li><a href="http://mlwave.com/kaggle-ensembling-guide/" target="_blank" rel="noopener">http://mlwave.com/kaggle-ensembling-guide/</a></li><li><a href="http://www.overkillanalytics.net/more-is-always-better-the-power-of-simple-ensembles/" target="_blank" rel="noopener">http://www.overkillanalytics.net/more-is-always-better-the-power-of-simple-ensembles/</a></li></ul><p>回到我们的问题，我们现在必须：</p><p>1.将组合数据集分成训练集和测试集。2.使用训练集建立预测模型。3.使用训练集评估模型。4.使用测试集测试模型，并生成并输出提交文件。</p><p>请记住，我们必须重复 2 和 3 直到达到可接受的评估分数。</p><p>让我们首先导入需要用到的函数包。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> make_pipeline</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble.gradient_boosting <span class="keyword">import</span> GradientBoostingClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> StratifiedKFold</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectFromModel</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression, LogisticRegressionCV</span><br></pre></td></tr></table></figure><p>为了评估我们的模型，我们将使用5折交叉验证（5-fold cross validation），因为它是在比赛排行榜中使用的指标。</p><p>为此，我们将定义一个小的评分函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_score</span><span class="params">(clf, X, y, scoring=<span class="string">'accuracy'</span>)</span>:</span></span><br><span class="line">    xval = cross_val_score(clf, X, y, cv = <span class="number">5</span>, scoring=scoring)</span><br><span class="line">    <span class="keyword">return</span> np.mean(xval)</span><br></pre></td></tr></table></figure><p>从组合数据集中恢复训练集和测试集是一项简单的任务。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recover_train_test_target</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> combined</span><br><span class="line"></span><br><span class="line">    targets = pd.read_csv(<span class="string">'./data/train.csv'</span>, usecols=[<span class="string">'Survived'</span>])[<span class="string">'Survived'</span>].values</span><br><span class="line">    train = combined.iloc[:<span class="number">891</span>]</span><br><span class="line">    test = combined.iloc[<span class="number">891</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> train, test, targets</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train, test, targets = recover_train_test_target()</span><br></pre></td></tr></table></figure><h3>特征选择</h3><p>到目前为止，我们已经提出了30多个特征。这个数字非常大。</p><p>在完成特征工程时，我们通常倾向于通过选择捕获基本特征的“正确”数量的特征来减少维度。</p><p>事实上，特征选择带来许多好处：</p><ul><li>它减少了数据之间的冗余</li><li>它加快了训练过程</li><li>它减少过拟合</li></ul><p>基于树的估算器可用于计算特征重要性，而这些重要性又可用于丢弃不相关的特征。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clf = RandomForestClassifier(n_estimators=<span class="number">50</span>, max_features=<span class="string">'sqrt'</span>)</span><br><span class="line">clf = clf.fit(train, targets)</span><br></pre></td></tr></table></figure><p>让我们看看每个特征的重要性。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">features = pd.DataFrame()</span><br><span class="line">features[<span class="string">'feature'</span>] = train.columns</span><br><span class="line">features[<span class="string">'importance'</span>] = clf.feature_importances_</span><br><span class="line">features.sort_values(by=[<span class="string">'importance'</span>], ascending=<span class="literal">True</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">features.set_index(<span class="string">'feature'</span>, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">features.plot(kind=<span class="string">'barh'</span>, figsize=(<span class="number">25</span>, <span class="number">25</span>))</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x117ff2a10&gt;</code></pre><p><img src="https://raw.githubusercontent.com/qiwihui/How-to-score-0.8134-in-Titanic-Kaggle-Challenge/master/images/article_1/8.png" alt="png"></p><p>正如您可能注意到的那样，与 <code>Title_Mr</code>，<code>Age</code>，<code>Fare</code> 和 <code>Sex</code> 相关联非常重要。</p><p>与 <code>Passenger_Id</code> 也有重要的相关性。</p><p>现在让我们将我们的训练集和测试集转换为更紧凑的数据集。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = SelectFromModel(clf, prefit=<span class="literal">True</span>)</span><br><span class="line">train_reduced = model.transform(train)</span><br><span class="line"><span class="keyword">print</span> train_reduced.shape</span><br></pre></td></tr></table></figure><pre><code>(891, 12)</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test_reduced = model.transform(test)</span><br><span class="line"><span class="keyword">print</span> test_reduced.shape</span><br></pre></td></tr></table></figure><pre><code>(418, 12)</code></pre><p>好极了！ 现在我们的特征减少了很多。</p><p>我们将看看我们是否会使用训练集的减少版或完整版。</p><h3>让我们尝试不同的基础模型</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logreg = LogisticRegression()</span><br><span class="line">logreg_cv = LogisticRegressionCV()</span><br><span class="line">rf = RandomForestClassifier()</span><br><span class="line">gboost = GradientBoostingClassifier()</span><br><span class="line"></span><br><span class="line">models = [logreg, logreg_cv, rf, gboost]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> model <span class="keyword">in</span> models:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Cross-validation of : &#123;0&#125;'</span>.format(model.__class__)</span><br><span class="line">    score = compute_score(clf=model, X=train_reduced, y=targets, scoring=<span class="string">'accuracy'</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'CV score = &#123;0&#125;'</span>.format(score)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'****'</span></span><br></pre></td></tr></table></figure><pre><code>Cross-validation of : &lt;class 'sklearn.linear_model.logistic.LogisticRegression'&gt;CV score = 0.818195097715****Cross-validation of : &lt;class 'sklearn.linear_model.logistic.LogisticRegressionCV'&gt;CV score = 0.81818240172****Cross-validation of : &lt;class 'sklearn.ensemble.forest.RandomForestClassifier'&gt;CV score = 0.808183171282****Cross-validation of : &lt;class 'sklearn.ensemble.gradient_boosting.GradientBoostingClassifier'&gt;CV score = 0.824917697684****</code></pre><h3>超参数调整</h3><p>正如建模部分的开头所提到的，我们将使用随机森林模型。它可能不是这项任务的最佳模型，但我们将展示如何调整。这项工作可以应用于不同的模型。</p><p>随机森林非常方便。然而，它们会带有一些参数进行调整，以便为预测任务获得最佳模型。</p><p>要了解有关随机森林的更多信息，请参阅此 <a href="https://www.analyticsvidhya.com/blog/2015/06/tuning-random-forest-model/" target="_blank" rel="noopener">链接</a>。</p><p>此外，我们将使用全部训练集。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># turn run_gs to True if you want to run the gridsearch again.</span></span><br><span class="line">run_gs = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> run_gs:</span><br><span class="line">    parameter_grid = &#123;</span><br><span class="line">                 <span class="string">'max_depth'</span> : [<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>],</span><br><span class="line">                 <span class="string">'n_estimators'</span>: [<span class="number">50</span>, <span class="number">10</span>],</span><br><span class="line">                 <span class="string">'max_features'</span>: [<span class="string">'sqrt'</span>, <span class="string">'auto'</span>, <span class="string">'log2'</span>],</span><br><span class="line">                 <span class="string">'min_samples_split'</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>],</span><br><span class="line">                 <span class="string">'min_samples_leaf'</span>: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>],</span><br><span class="line">                 <span class="string">'bootstrap'</span>: [<span class="literal">True</span>, <span class="literal">False</span>],</span><br><span class="line">                 &#125;</span><br><span class="line">    forest = RandomForestClassifier()</span><br><span class="line">    cross_validation = StratifiedKFold(n_splits=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    grid_search = GridSearchCV(forest,</span><br><span class="line">                               scoring=<span class="string">'accuracy'</span>,</span><br><span class="line">                               param_grid=parameter_grid,</span><br><span class="line">                               cv=cross_validation,</span><br><span class="line">                               verbose=<span class="number">1</span></span><br><span class="line">                              )</span><br><span class="line"></span><br><span class="line">    grid_search.fit(train, targets)</span><br><span class="line">    model = grid_search</span><br><span class="line">    parameters = grid_search.best_params_</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'Best score: &#123;&#125;'</span>.format(grid_search.best_score_))</span><br><span class="line">    print(<span class="string">'Best parameters: &#123;&#125;'</span>.format(grid_search.best_params_))</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    parameters = &#123;<span class="string">'bootstrap'</span>: <span class="literal">False</span>, <span class="string">'min_samples_leaf'</span>: <span class="number">3</span>, <span class="string">'n_estimators'</span>: <span class="number">50</span>,</span><br><span class="line">                  <span class="string">'min_samples_split'</span>: <span class="number">10</span>, <span class="string">'max_features'</span>: <span class="string">'sqrt'</span>, <span class="string">'max_depth'</span>: <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line">    model = RandomForestClassifier(**parameters)</span><br><span class="line">    model.fit(train, targets)</span><br></pre></td></tr></table></figure><p>现在通过扫描超参数的几个组合来构建模型，我们可以生成一个输出文件以在 Kaggle 上提交。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">output = model.predict(test).astype(int)</span><br><span class="line">df_output = pd.DataFrame()</span><br><span class="line">aux = pd.read_csv(<span class="string">'./data/test.csv'</span>)</span><br><span class="line">df_output[<span class="string">'PassengerId'</span>] = aux[<span class="string">'PassengerId'</span>]</span><br><span class="line">df_output[<span class="string">'Survived'</span>] = output</span><br><span class="line">df_output[[<span class="string">'PassengerId'</span>,<span class="string">'Survived'</span>]].to_csv(<span class="string">'./predictions/gridsearch_rf.csv'</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h3>[BONUS] 混合不同模型</h3><p>我没有亲自上传基于模型混合的提交，但这是你可以这么做：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">trained_models = []</span><br><span class="line"><span class="keyword">for</span> model <span class="keyword">in</span> models:</span><br><span class="line">    model.fit(train, targets)</span><br><span class="line">    trained_models.append(model)</span><br><span class="line"></span><br><span class="line">predictions = []</span><br><span class="line"><span class="keyword">for</span> model <span class="keyword">in</span> trained_models:</span><br><span class="line">    predictions.append(model.predict_proba(test)[:, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">predictions_df = pd.DataFrame(predictions).T</span><br><span class="line">predictions_df[<span class="string">'out'</span>] = predictions_df.mean(axis=<span class="number">1</span>)</span><br><span class="line">predictions_df[<span class="string">'PassengerId'</span>] = aux[<span class="string">'PassengerId'</span>]</span><br><span class="line">predictions_df[<span class="string">'out'</span>] = predictions_df[<span class="string">'out'</span>].map(<span class="keyword">lambda</span> s: <span class="number">1</span> <span class="keyword">if</span> s &gt;= <span class="number">0.5</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">predictions_df = predictions_df[[<span class="string">'PassengerId'</span>, <span class="string">'out'</span>]]</span><br><span class="line">predictions_df.columns = [<span class="string">'PassengerId'</span>, <span class="string">'Survived'</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">predictions_df.to_csv(<span class="string">'./predictions/blending_base_models.csv'</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>为了获得良好的混合提交，基本模型应该是不同的，并且它们的相关性是不相关的。</p><h2>IV - 结论</h2><p>在本文中，我们探讨了 <a href="http://kaggle.com" target="_blank" rel="noopener">Kaggle</a> 带给我们的一个有趣的数据集。</p><p>我们浏览了数据科学管道的基本要点：</p><ul><li>数据探索和可视化：制定假设的第一步</li><li>数据清理</li><li>特征工程</li><li>特征选择</li><li>超参数调整</li><li>提交</li><li>混合</li></ul><p>如果您想测试和使用它，可以将此博客下载为笔记本：<a href="https://github.com/ahmedbesbes/How-to-score-0.8134-in-Titanic-Kaggle-Challenge/raw/master/article_1.ipynb" target="_blank" rel="noopener">我的 github repo</a></p><blockquote><p>译者注：此中文翻译地址为： <a href="https://github.com/qiwihui/How-to-score-0.8134-in-Titanic-Kaggle-Challenge/raw/master/article_cn.ipynb" target="_blank" rel="noopener">qiwihui 的 github repo</a></p></blockquote><p>关于这一挑战的文章很多，所以显然还有改进的余地。</p><p>以下是我建议的后续步骤：</p><ul><li>挖掘更多数据并最终构建新特征。</li><li>尝试不同的模型：逻辑回归，Gradient Boosted Tree，XGboost 等。</li><li>尝试集成学习技巧（堆叠）</li><li>运行 auto-ML 框架</li></ul><p>如果你能找到改善我的解决方案的方法，我会非常高兴。这可以让我更新文章，绝对给你信任。所以请随时发表评论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文：&lt;a href=&quot;https://ahmedbesbes.com/how-to-score-08134-in-titanic-kaggle-challenge.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;How to score 0.8134 in Titanic Kaggle Challenge&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由 Kaggle 主持的&lt;a href=&quot;https://www.kaggle.com/c/titanic/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;泰坦尼克号生存挑战赛&lt;/a&gt;是一项竞赛，其目标是基于一组描述乘客的变量，例如他的年龄，性别或乘客在船上的等级，来预测特定乘客是生存或死亡。&lt;/p&gt;
&lt;p&gt;我一直在玩 Titanic 数据集，我最近在公共排行榜上获得了0.8134的准确度分数。当我写这篇文章时，我在所有 Kagglers 中排名前4％。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/qiwihui/How-to-score-0.8134-in-Titanic-Kaggle-Challenge/master/images/article_1/score.png&quot; alt=&quot;png&quot;&gt;&lt;/p&gt;
&lt;p&gt;这篇文章将分享我的解决方案。&lt;/p&gt;
&lt;p&gt;为了使本教程更具“学术性”以便任何人都能从中受益，我将首先从探索性数据分析（EDA）开始，然后我将遵循特征工程并最终呈现我设置的预测模型。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="机器学习" scheme="https://qiwihui.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>重命名本地和远程 Git 分支名称</title>
    <link href="https://qiwihui.com/qiwihui-blog-54/"/>
    <id>https://qiwihui.com/qiwihui-blog-54/</id>
    <published>2019-02-11T22:12:50.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>如果不小心写错了分支名称又将分支推送到了远端，这时可以使用以下步骤进行修正：</p><a id="more"></a><ol><li><p>重命名本地分支：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -m old-name new-name</span><br></pre></td></tr></table></figure><p>若当前在 <code>old-name</code> 分支上，则可以省略 <code>old-name</code>：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -m new-name</span><br></pre></td></tr></table></figure></li><li><p>删除远程老分支：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin :old-name</span><br></pre></td></tr></table></figure></li><li><p>推送新的本地分支，并设置本地新分支追踪远程分支：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin -u new-name</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果不小心写错了分支名称又将分支推送到了远端，这时可以使用以下步骤进行修正：&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>在 Mac OS X 上使用 iodine 配置 DNS 隧道</title>
    <link href="https://qiwihui.com/qiwihui-blog-53/"/>
    <id>https://qiwihui.com/qiwihui-blog-53/</id>
    <published>2019-01-29T23:31:20.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>DNS 隧道，是隐蔽信道的一种，通过将其他协议封装在DNS协议中传输建立通信。</p></blockquote><p>本文是在 Mac OS X 上实践的 DNS 隧道的一个记录，关于这个方法的原理，请具体参考 <a href="https://cloud.tencent.com/developer/article/1040276" target="_blank" rel="noopener">DNS Tunneling及相关实现</a>。</p><a id="more"></a><h2>安装和配置</h2><h3>配置域名</h3><p>准备一台 VPS 以及一个域名（比如 <code>qiwihui.com</code>），在域名的 DNS 配置中添加两条记录：</p><table><thead><tr><th>Name</th><th>Type</th><th>TTL</th><th>Data</th></tr></thead><tbody><tr><td>dns</td><td>A</td><td>1h</td><td><code>vps-ip</code></td></tr><tr><td>dt</td><td>NS</td><td>1h</td><td><a href="http://dns.qiwihui.com" target="_blank" rel="noopener">dns.qiwihui.com</a></td></tr></tbody></table><h3>服务端</h3><p>以 Debian 系统为例，安装：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install iodine</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ iodined -f -c -P password 172.18.0.1 dt.qiwihui.com </span><br><span class="line">Opened dns0</span><br><span class="line">Setting IP of dns0 to 172.18.0.1</span><br><span class="line">Setting MTU of dns0 to 1130</span><br><span class="line">Opened IPv4 UDP socket</span><br><span class="line">Listening to dns <span class="keyword">for</span> domain dt.qiwihui.com</span><br></pre></td></tr></table></figure><p>其中，<code>password</code> 是客户端和服务器之前的密码，<code>172.18.0.1</code> 为虚拟局域网的IP地址，可自行设定，但不要与现有网络重复了。此时，服务端已经就绪。</p><h3>客户端（本地）安装 <code>iodine</code></h3><ol><li>本地安装 <code>tuntap</code></li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew cask install tuntap</span><br></pre></td></tr></table></figure><ol start="2"><li>安装 <code>iodine</code></li></ol><p>因为官方没有提供 Mac OS X 的可执行文件，需要从源码编译，或者使用我已经设置好的 Homebrew tap 进行安装。从源码编译：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -c http://code.kryo.se/iodine/iodine-0.7.0.tar.gz</span><br><span class="line">tar zxvf iodine-0.7.0.tar.gz</span><br><span class="line"><span class="built_in">cd</span> iodine-0.7.0</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>或者使用 Homebrew：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew tap qiwihui/core</span><br><span class="line">brew install qiwihui/core/iodine</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo iodine -f -P password dns.qiwihui.com dt.qiwihui.com</span><br><span class="line">Opened /dev/tun0</span><br><span class="line">Opened IPv4 UDP socket</span><br><span class="line">Sending DNS queries <span class="keyword">for</span> dt.qiwihui.com to &lt;vps-ip&gt;</span><br><span class="line">Autodetecting DNS query <span class="built_in">type</span> (use -T to override).</span><br><span class="line">Using DNS <span class="built_in">type</span> NULL queries</span><br><span class="line">Version ok, both using protocol v 0x00000502. You are user <span class="comment">#1</span></span><br><span class="line">Setting IP of tun0 to 172.18.0.3</span><br><span class="line">Adding route 172.18.0.0/27 to 172.18.0.3</span><br><span class="line">add net 172.18.0.0: gateway 172.18.0.3</span><br><span class="line">Setting MTU of tun0 to 1130</span><br><span class="line">Server tunnel IP is 172.18.0.1</span><br><span class="line">Testing raw UDP data to the server (skip with -r).</span><br><span class="line">Server is at 10.170.0.3, trying raw login: ....failed</span><br><span class="line">Retrying EDNS0 support <span class="built_in">test</span>...</span><br><span class="line">Using EDNS0 extension</span><br><span class="line">Switching upstream to codec Base128</span><br><span class="line">Server switched upstream to codec Base128</span><br><span class="line">No alternative downstream codec available, using default (Raw)</span><br><span class="line">Switching to lazy mode <span class="keyword">for</span> low-latency</span><br><span class="line">Server switched to lazy mode</span><br><span class="line">Autoprobing max downstream fragment size... (skip with -m fragsize)</span><br><span class="line">768 ok.. ...1152 not ok.. 960 ok.. 1056 ok.. 1104 ok.. 1128 ok.. 1140 ok.. will use 1140-2=1138</span><br><span class="line">Setting downstream fragment size to max 1138...</span><br><span class="line">Retrying <span class="built_in">set</span> fragsize...</span><br><span class="line">Retrying <span class="built_in">set</span> fragsize...</span><br><span class="line">Connection setup complete, transmitting data.</span><br></pre></td></tr></table></figure><p>此时，客户端配置完成。</p><h3>测试和使用</h3><p>在本地尝试 ping 172.18.0.1 即可：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ping 172.18.0.1</span><br><span class="line">PING 172.18.0.1 (172.18.0.1): 56 data bytes</span><br><span class="line">64 bytes from 172.18.0.1: icmp_seq=0 ttl=64 time=233.914 ms</span><br><span class="line">64 bytes from 172.18.0.1: icmp_seq=1 ttl=64 time=232.870 ms</span><br><span class="line">64 bytes from 172.18.0.1: icmp_seq=2 ttl=64 time=230.201 ms</span><br><span class="line">64 bytes from 172.18.0.1: icmp_seq=3 ttl=64 time=268.602 ms</span><br><span class="line">64 bytes from 172.18.0.1: icmp_seq=4 ttl=64 time=230.573 ms</span><br><span class="line">^C</span><br><span class="line">--- 172.18.0.1 ping statistics ---</span><br><span class="line">5 packets transmitted, 5 packets received, 0.0% packet loss</span><br><span class="line">round-trip min/avg/max/stddev = 230.201/239.232/268.602/14.751 ms</span><br></pre></td></tr></table></figure><p>这时，只要通过这个 DNS 隧道就可就传递其他数据了。</p><h2>用途</h2><p>当防火墙限制了一些网站的访问，但是能进行 DNS 查询时，可使用这种方法进行绕过，比如在公司，又或者在某些国家，犯罪分子也常用这中方式进行内网数据传出。</p><h2>参考</h2><ul><li><a href="http://code.kryo.se/iodine/%EF%BC%9Aiodine" target="_blank" rel="noopener">http://code.kryo.se/iodine/：iodine</a> 官方网站，<a href="http://kryo.se" target="_blank" rel="noopener">kryo.se</a>: iodine (IP-over-DNS, IPv4 over DNS tunnel)</li><li><a href="https://github.com/yarrick/iodine%EF%BC%9AOfficial" target="_blank" rel="noopener">https://github.com/yarrick/iodine：Official</a> git repo for iodine dns tunnel</li><li><a href="https://cloud.tencent.com/developer/article/1040276" target="_blank" rel="noopener">DNS Tunneling及相关实现</a></li><li><a href="http://jeremy5189.logdown.com/posts/263029-iodine-ip-over-dns" target="_blank" rel="noopener">iodine - IP over DNS</a></li><li><a href="http://wiki.attie.co.uk/wiki/Tunnel_IP_through_DNS" target="_blank" rel="noopener">Tunnel IP through DNS</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;DNS 隧道，是隐蔽信道的一种，通过将其他协议封装在DNS协议中传输建立通信。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文是在 Mac OS X 上实践的 DNS 隧道的一个记录，关于这个方法的原理，请具体参考 &lt;a href=&quot;https://cloud.tencent.com/developer/article/1040276&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;DNS Tunneling及相关实现&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>在 Mac OS X 上使用 hans 配置 ICMP 隧道</title>
    <link href="https://qiwihui.com/qiwihui-blog-52/"/>
    <id>https://qiwihui.com/qiwihui-blog-52/</id>
    <published>2019-01-29T06:41:33.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为电信白名单，高端口基本无法使用，解决办法就是将翻墙服务启动在80，443等可访问端口。但是最近防火墙又一次升级，国外的服务器基本只能 ping 通，TCP 请求无法完成，能访问世界的方式越来越困难。本文介绍一种方法，将数据包封装在 ping 包中进行传输。本方法中使用 <a href="http://code.gerade.org/hans/" target="_blank" rel="noopener">hans</a> 这个项目结合 shadowsocks-libev 翻墙。</p><a id="more"></a><h2>安装</h2><h3>服务器端</h3><p>同样，需要在服务器端编译安装 <code>hans</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -c https://github.com/friedrich/hans/archive/v1.0.tar.gz</span><br><span class="line">tar zxvf v1.0.tar.gz</span><br><span class="line"><span class="built_in">cd</span> hans-1.0/</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>编译完成后会产生 <code>hans</code> 执行程序，按以下命令以 <code>root</code> 启动，程序会进入 Deamon 模式。如果要看到输出，可以加上 <code>-f</code> 参数。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./hans -s 10.1.2.0 -p password</span><br></pre></td></tr></table></figure><p>其中，<code>password</code> 为设置的密码。然后使用 <code>netstat -rn</code> 可以看到多了一个 <code>tun0</code> 设备</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ netstat -rn</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface</span><br><span class="line">(省略其他的)</span><br><span class="line">10.1.2.0        0.0.0.0         255.255.255.0   U         0 0          0 tun0</span><br></pre></td></tr></table></figure><h3>客户端</h3><p>在 Mac OS X 上，先安装 <code>tuntap</code> 内核扩展来允许创建虚拟网卡，可以直接使用 Homebrew-Cask 安装，安装过程中需要按照指示给程序权限。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew cask install tuntap</span><br></pre></td></tr></table></figure><p>下载 Mac 版本程序并解压：<a href="https://sourceforge.net/projects/hanstunnel/files/osx/" target="_blank" rel="noopener">hans</a></p><p>运行程序：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ./hans -c &lt;server-ip&gt; -p password -d tun0</span><br></pre></td></tr></table></figure><p>其中 <code>server-ip</code> 是你服务器的 IP，<code>-d</code> 指定Mac上新启设备的名称。Mac 上停止 <code>hans</code> 程序请使用 <code>kill -9</code>。如果启动正常，这时在Mac上也同样可以观察到tun0设备：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ifconfig</span><br><span class="line"></span><br><span class="line">(省略其他)</span><br><span class="line">tun0: flags=8851&lt;UP,POINTOPOINT,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1467</span><br><span class="line">        inet 10.1.2.100 --&gt; 10.1.2.1 netmask 0xffffffff </span><br><span class="line">        open (pid 74236)</span><br></pre></td></tr></table></figure><p>理论上这时服务器 IP 是无法 ping 通了：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ping &lt;server-ip&gt;</span><br><span class="line">PING &lt;server-ip&gt;: 56 data bytes</span><br><span class="line">Request timeout <span class="keyword">for</span> icmp_seq 0</span><br><span class="line">Request timeout <span class="keyword">for</span> icmp_seq 1</span><br><span class="line">Request timeout <span class="keyword">for</span> icmp_seq 2</span><br><span class="line">Request timeout <span class="keyword">for</span> icmp_seq 3</span><br><span class="line">^C</span><br><span class="line">--- &lt;server-ip&gt; ping statistics ---</span><br><span class="line">5 packets transmitted, 0 packets received, 100.0% packet loss</span><br></pre></td></tr></table></figure><p>此时，就建立了一条从本地到服务器的 hanstunnel tunnel 了。</p><p>现在只需要将本地 <code>ss-local</code> 的配置中的 <code>server</code> 参数改为 <code>tun0</code> 的 gateway 地址（本例为<code>10.1.2.1</code>）即可，其他不需要做任何修改。</p><h3>检查流量</h3><p>在服务器网卡上抓包可以不断看到 ICMP 的 ｀echo request｀ 和 ｀echo reply｀ 包，在 <code>tun0</code> 上可以看到实际的数据包。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump -ni ens3</span><br><span class="line"></span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv <span class="keyword">for</span> full protocol decode</span><br><span class="line">listening on ens3, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">02:16:29.146644 IP &lt;<span class="built_in">local</span>-ip&gt; &gt; &lt;server-ip&gt;: ICMP <span class="built_in">echo</span> request, id 38174, seq 7330, length 93</span><br><span class="line">02:16:29.146647 IP &lt;<span class="built_in">local</span>-ip&gt; &gt; &lt;server-ip&gt;: ICMP <span class="built_in">echo</span> request, id 38174, seq 7330, length 13</span><br><span class="line">02:16:29.146652 IP &lt;<span class="built_in">local</span>-ip&gt; &gt; &lt;server-ip&gt;: ICMP <span class="built_in">echo</span> request, id 38174, seq 7330, length 13</span><br><span class="line">02:16:29.146684 IP &lt;<span class="built_in">local</span>-ip&gt; &gt; &lt;server-ip&gt;: ICMP <span class="built_in">echo</span> request, id 38174, seq 7330, length 93</span><br><span class="line">02:16:29.146704 IP &lt;server-ip&gt; &gt; &lt;<span class="built_in">local</span>-ip&gt;: ICMP <span class="built_in">echo</span> reply, id 38174, seq 7330, length 257</span><br><span class="line">02:16:29.146858 IP &lt;server-ip&gt; &gt; &lt;<span class="built_in">local</span>-ip&gt;: ICMP <span class="built_in">echo</span> reply, id 38174, seq 7330, length 833</span><br><span class="line">02:16:29.146942 IP &lt;server-ip&gt; &gt; &lt;<span class="built_in">local</span>-ip&gt;: ICMP <span class="built_in">echo</span> reply, id 38174, seq 7330, length 257</span><br><span class="line"></span><br><span class="line">(略去一堆)</span><br></pre></td></tr></table></figure><p>以上就是使用 TCP over ICMP 的方法进行数据传输的配置过程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近因为电信白名单，高端口基本无法使用，解决办法就是将翻墙服务启动在80，443等可访问端口。但是最近防火墙又一次升级，国外的服务器基本只能 ping 通，TCP 请求无法完成，能访问世界的方式越来越困难。本文介绍一种方法，将数据包封装在 ping 包中进行传输。本方法中使用 &lt;a href=&quot;http://code.gerade.org/hans/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hans&lt;/a&gt; 这个项目结合 shadowsocks-libev 翻墙。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Hexo git deployer 删除了提交历史记录该怎么整？</title>
    <link href="https://qiwihui.com/qiwihui-blog-50/"/>
    <id>https://qiwihui.com/qiwihui-blog-50/</id>
    <published>2019-01-24T23:36:47.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://e.printstacktrace.blog/hexo-git-deployer-removes-commits-history-lets-do-something-about-that/" target="_blank" rel="noopener">Hexo git deployer removes commits history? Let’s do something about that!</a></p><p>我发现 <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 是构建博客和应用许多知名的软件开发原则的好工具，其中之一是自动化。这就是我决定将此博客与 <a href="https://travis-ci.org/wololock/wololock.github.io" target="_blank" rel="noopener">Travis CI</a> 集成以执行 GitHub pages 部署的原因。但几天之后我注意到一个重要问题 - 从 CI 服务器部署新版本的博客导致从 <code>master</code> 分支中删除所有提交并从一次又一次地初始化提交开始。我花了一段时间才找到解决这个问题的工作方案。这篇博文解释了这个问题的简单解决方案。</p><a id="more"></a><h3>为什么 <code>hexo deploy</code> 会首先删除历史记录？</h3><p>让我们从了解实际发生的事情开始。当你为 git 部署选项运行 <code>hexo deploy</code> [1]命令时，Hexo 会创建一个名为 <code>.deploy_git</code> 的隐藏文件夹，并将生成的文件从 <code>public</code> 文件夹复制到该文件夹。接下来，它初始化目标为 Hexo 远程部署分支的git存储库（如果它尚不存在），并从该文件夹执行 <code>git push --force</code> 到仓库和你在 <code>_config.yml</code> [2]文件中定义的分支。</p><p>清单1. 博客的部署配置</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:wololock/wololock.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>如果你从本地计算机构建和部署博客，并且永远不会删除（或意外丢失）你的博客源代码，你可能永远不会遇到此问题。当你从未被擦除的工作空间执行此操作时，则存在具有完整历史记录的文件夹 <code>.deploy_git</code>，并且 <code>hexo deploy</code> 仅推送实际修改的那些文件。当你迁移到像 <code>Travis CI</code> 这样的 CI 服务器时，这就变了，因为它使用干净的工作区和仓库的新克隆执行构建。在这种情况下，<code>.deploy_git</code> 文件夹根本不存在，将从头开始重新创建。</p><h3>那么如何部署和保存历史呢？</h3><p>我发现解决方案非常简单。以前我负责部署的 <code>.travis.yml</code> 文件部分看起来像这样：</p><p>清单2. 以前的 <code>Travis CI</code> 部署配置</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">skip_cleanup:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">script</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">hexo</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">on:</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">develop</span></span><br></pre></td></tr></table></figure><p>只要我将更改推送到 <code>develop</code> 分支，它就会触发 <code>hexo deploy</code>。在这种情况下，它最终创建了一个新的 <code>.deploy_git</code> 文件夹并强制将初始提交推送到 GitHub 仓库。然后，我做了一个小改进 - 我创建了一个简短的 bash 脚本。</p><p>清单3. 部署博客使用的脚本</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用已部署文件初始化目标</span></span><br><span class="line"><span class="string">git</span> <span class="string">clone</span> <span class="string">--depth</span> <span class="number">1</span> <span class="string">--branch=master</span> <span class="string">https://github.com/wololock/wololock.github.io.git</span> <span class="string">.deploy_git</span></span><br><span class="line"></span><br><span class="line"><span class="string">cd</span> <span class="string">.deploy_git</span></span><br><span class="line"></span><br><span class="line"><span class="string">＃从</span> <span class="string">../public/</span> <span class="string">复制之前删除所有文件</span></span><br><span class="line"><span class="comment"># 这样 git 可以跟踪上次提交中删除的文件</span></span><br><span class="line"><span class="string">find</span> <span class="string">.</span> <span class="string">-path</span> <span class="string">./.git</span> <span class="string">-prune</span> <span class="string">-o</span> <span class="string">-exec</span> <span class="string">rm</span> <span class="string">-rf</span> <span class="string">&#123;&#125;</span> <span class="string">\;</span> <span class="number">2</span><span class="string">&gt;</span> <span class="string">/dev/null</span></span><br><span class="line"></span><br><span class="line"><span class="string">cd</span> <span class="string">../</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure><p>这个脚本完全按照它在注释中所说的那样做：</p><ul><li>它将 <code>master</code> 分支从远程存储库克隆到 <code>.deploy_git</code> 以获取现有提交历史记录。</li><li>然后它从 <code>.deploy_git</code> 中删除所有非 git 对象存储库文件，因此从 <code>public</code> 文件夹复制文件将跟踪已删除的文件。</li><li>最后 - 它执行常规部署的 <code>hexo deploy</code> 命令。</li></ul><p>最后，这是在引入部署bash脚本后的部署配置部分：</p><p>清单4. 当前的 <code>Travis CI</code> 部署配置</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">skip_cleanup:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">script</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">sh</span> <span class="string">deploy.sh</span></span><br><span class="line">  <span class="attr">on:</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">develop</span></span><br></pre></td></tr></table></figure><p>由于这个解决方案，我能够保留站点更新的历史记录，并跟踪使用给定站点更新实际修改的文件的更改。</p><p><img src="https://e.printstacktrace.blog/images/github-hexo-history.png" alt="github hexo history"></p><h3>最后的话</h3><p>我希望你发现这篇文章很有用。它描述了 Hexo + Travis CI + GitHub 用例的解决方案，但它可以解决从 CI 服务器环境运行时其他类似静态站点生成器可能遇到的问题。</p><h3>参考</h3><ol><li>Documentation: <a href="https://hexo.io/docs/deployment" target="_blank" rel="noopener">https://hexo.io/docs/deployment</a></li><li><a href="https://github.com/wololock/wololock.github.io/blob/develop/_config.yml#L88-L93" target="_blank" rel="noopener">https://github.com/wololock/wololock.github.io/blob/develop/_config.yml#L88-L93</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文：&lt;a href=&quot;https://e.printstacktrace.blog/hexo-git-deployer-removes-commits-history-lets-do-something-about-that/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo git deployer removes commits history? Let’s do something about that!&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我发现 &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt; 是构建博客和应用许多知名的软件开发原则的好工具，其中之一是自动化。这就是我决定将此博客与 &lt;a href=&quot;https://travis-ci.org/wololock/wololock.github.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Travis CI&lt;/a&gt; 集成以执行 GitHub pages 部署的原因。但几天之后我注意到一个重要问题 - 从 CI 服务器部署新版本的博客导致从 &lt;code&gt;master&lt;/code&gt; 分支中删除所有提交并从一次又一次地初始化提交开始。我花了一段时间才找到解决这个问题的工作方案。这篇博文解释了这个问题的简单解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>在 OS X 上使用 sed 命令的一些注意</title>
    <link href="https://qiwihui.com/qiwihui-blog-48/"/>
    <id>https://qiwihui.com/qiwihui-blog-48/</id>
    <published>2019-01-24T00:32:51.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>在 OS X 上使用 <code>sed</code> 会和 GNU 上不太一致，在此记录。</p><ol><li>OS X <code>sed</code> 不可忽略备份扩展</li></ol><a id="more"></a><h3>不可忽略备份扩展</h3><p>在 OS X 上进行文本替换时，必须要指定备份扩展，即使扩展可以为空。比如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i  <span class="string">'s/foo/bar/g'</span> target</span><br></pre></td></tr></table></figure><p>上面这行代码，可以在 GNU 上运行，作用是将 <code>foo</code> 替换为 <code>bar</code>，并且直接修改目标文件（<code>-i</code>）。但是如果在 OS X 上，这行命令会报错：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sed -i <span class="string">'s/foo/bar/g'</span> target </span><br><span class="line">sed: 1: <span class="string">"target"</span>: undefined label <span class="string">'arget'</span></span><br></pre></td></tr></table></figure><p>原因是在 OS X 上，sed 命令必须指定备份的扩展格式：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ man sed</span><br><span class="line"></span><br><span class="line">     -i extension</span><br><span class="line">             Edit files <span class="keyword">in</span>-place, saving backups with the specified extension.  If a zero-length extension is given, no backup will be saved.  It is not recommended to give a</span><br><span class="line">             zero-length extension when <span class="keyword">in</span>-place editing files, as you risk corruption or partial content <span class="keyword">in</span> situations <span class="built_in">where</span> disk space is exhausted, etc.</span><br></pre></td></tr></table></figure><p>所以需要修改为</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">''</span> <span class="string">'s/foo/bar/g'</span> target</span><br></pre></td></tr></table></figure><p>没有好的方法避免创建备份文件问题，以下的方法都做不到兼容：</p><ul><li><code>sed -i -e ...</code> - 在 OS X 上不起作用，会创建 <code>-e</code> 备份</li><li><code>sed -i'' -e ...</code> - 在 OS X 10.6 不起作用，但在 10.9+ 可行</li><li><code>sed -i '' -e ...</code> - 在 GNU 上不起作用</li></ul><p>或者，在 OS X 使用 <code>gnu-sed</code> 代替 sed：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install gnu-sed</span><br><span class="line"><span class="built_in">alias</span> sed=gsed</span><br></pre></td></tr></table></figure><p>又或者，使用其他命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">perl -i -pe<span class="string">'s/foo/bar/g'</span> target</span><br></pre></td></tr></table></figure><h3>参考</h3><ul><li><a href="https://stackoverflow.com/a/4247319/3218128" target="_blank" rel="noopener">sed command with -i option failing on Mac, but works on Linux</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 OS X 上使用 &lt;code&gt;sed&lt;/code&gt; 会和 GNU 上不太一致，在此记录。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;OS X &lt;code&gt;sed&lt;/code&gt; 不可忽略备份扩展&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Pages 自定义域名实践整理</title>
    <link href="https://qiwihui.com/qiwihui-blog-47/"/>
    <id>https://qiwihui.com/qiwihui-blog-47/</id>
    <published>2019-01-23T23:12:41.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客将整理在配置博客以及项目 Pages 的自定义域名过程，遇到的问题以及解决方法。<a href="https://help.github.com/articles/using-a-custom-domain-with-github-pages/" target="_blank" rel="noopener">Github 的文档</a>对于如何配置自定义域名有详细的介绍，这里不会全部翻译，只重点记录实践的过程，内容涉及为用户网站，公司网站，以及项目网站添加 <code>Apex</code> 域名（<a href="http://qiwihui.com">qiwihui.com</a>），二级域名（<a href="http://www.qiwihui.com" target="_blank" rel="noopener">www.qiwihui.com</a>）以及开启 HTTPS。最后，所有指向 <code>www.qiwihui.com</code> 的请求将会被重定向至 <code>https://qiwihui.com</code>。</p><a id="more"></a><h2>一些注意</h2><h3>Github 支持的自定义域名类型</h3><table><thead><tr><th>支持的自定义域名类型</th><th>域名例子</th></tr></thead><tbody><tr><td>www subdomain</td><td><code>www.example.com</code></td></tr><tr><td><strong>one apex domain &amp; one www subdomain</strong></td><td><code>example.com</code> &amp; <code>www.example.com</code></td></tr><tr><td>apex domain</td><td><code>example.com</code></td></tr><tr><td>custom subdomain</td><td><code>blog.example.com</code></td></tr></tbody></table><h3>GitHub Pages 站支持的域名</h3><table><thead><tr><th>GitHub Pages 站类型</th><th>在 Github 上 Pages 的默认域名和主机地址</th><th>页面被如何重定向</th><th>自定义域名举例</th></tr></thead><tbody><tr><td>User Pages 站</td><td><code>username.github.io</code></td><td>自动重定向到设置的自定义域名</td><td><code>user.example.com</code></td></tr><tr><td>Organization Pages 站</td><td><code>orgname.github.io</code></td><td>自动重定向到设置的自定义域名</td><td><code>org.example.com</code></td></tr><tr><td>用户拥有的 Project Pages 站</td><td><code>username.github.io/projectname</code></td><td>自动重定向到 User Pages 站自定义域名的子目录（<code>user.example.com/projectname</code>）</td><td><code>project.example.com</code></td></tr><tr><td>公司拥有的 Project Pages 站</td><td><code>orgname.github.io/projectname</code></td><td>自动重定向到 Organization Pages 站自定义域名的子目录（<code>org.example.com/projectname</code>）</td><td><code>project.example.com</code></td></tr></tbody></table><h2>以个人 Pages 项目为例子</h2><h3>开启 Github Pages 功能</h3><p>在项目 <code>Settings</code> 中，找到 <code>GitHub Pages</code> 这一区域，选择 <code>Source</code> 为对应的要部署的分支，这里我选择 <code>gh-pages branch</code>：</p><p><img src="https://user-images.githubusercontent.com/3297411/51802835-b4756580-2288-11e9-8aab-b5add026d737.png" alt="gh-pages"></p><p>其中，选择 <code>master branch</code> 会视 <code>/README.md</code> 为 web 的 <code>index.html</code>，选择 <code>master branch /docs folder</code> 会视 <code>/docs/README.md</code> 为 web 的 <code>index.html</code>。</p><h3>在项目配置中自定义域名</h3><p>在 <code>Custom domain</code> 中添加自己的域名并保存：</p><p><img src="https://user-images.githubusercontent.com/3297411/51802765-141f4100-2288-11e9-8e8d-8980ed3e63b3.png" alt="custom-domain"></p><p>或者，在项目分支中添加 <code>CNAME</code> 文件，<code>CNAME</code> 文件的内容为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qiwihui.com</span><br></pre></td></tr></table></figure><p>这里推荐第二种，尤其对于有设置 CI 的项目，因为 CI 上将第一种设置覆盖。这一步是比较重要却又容易忽视的一步：</p><ul><li>如果添加到 GitHub Pages 中的是 <code>qiwihui.com</code>，那么 <code>www.qiwihui.com</code> 会被重定向到 <code>qiwihui.com</code>；</li><li>如果添加到 GitHub Pages 中的是 <code>www.qiwihui.com</code>，那么 <code>qiwihui.com</code> 会被重定向到 <code>www.qiwihui.com</code>；</li></ul><p>这里我选择重定向到 <code>www.qiwihui.com</code>，所以设置为 <code>qiwihui.com</code></p><h3>添加 DNS 记录</h3><p>为了能设置<code>Apex</code> 域名，需要在 DNS 中配置 A 记录指向 github 的 IP：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">185.199.108.153</span><br><span class="line">185.199.109.153</span><br><span class="line">185.199.110.153</span><br><span class="line">185.199.111.153</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/3297411/51803023-1040ee00-228b-11e9-90f7-20a4a99d9069.png" alt="a-record"></p><p>同时，设置 <code>CNAME</code>  记录将 <code>www.qiwihui.com</code> 指向 <code>qiwihui.github.io</code>，即 <code>&lt;你的 github 用户名&gt;.github.io</code>。对于公司来说，这个地址是 <code>&lt;公司名称&gt;.github.io</code>。</p><p><img src="https://user-images.githubusercontent.com/3297411/51803045-539b5c80-228b-11e9-8e60-03c854f7097b.png" alt="www-record"></p><h3>确认 DNS 记录</h3><p>以下是设置好之后的 DNS 记录情况：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dig +noall +answer qiwihui.com</span><br><span class="line">qiwihui.com.            60      IN      A       185.199.111.153</span><br><span class="line">qiwihui.com.            60      IN      A       185.199.110.153</span><br><span class="line">qiwihui.com.            60      IN      A       185.199.108.153</span><br><span class="line">qiwihui.com.            60      IN      A       185.199.109.153</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dig www.qiwihui.com +nostats +nocomments +nocmd </span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; www.qiwihui.com +nostats +nocomments +nocmd</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;www.qiwihui.com.               IN      A</span><br><span class="line">www.qiwihui.com.        28      IN      CNAME   qiwihui.github.io.</span><br><span class="line">qiwihui.github.io.      28      IN      A       185.199.110.153</span><br><span class="line">qiwihui.github.io.      28      IN      A       185.199.108.153</span><br><span class="line">qiwihui.github.io.      28      IN      A       185.199.111.153</span><br><span class="line">qiwihui.github.io.      28      IN      A       185.199.109.153</span><br></pre></td></tr></table></figure><h3>SSL（HTTPS）配置，强烈推荐开启</h3><p>勾选 <code>Enforce HTTPS</code></p><p><img src="https://user-images.githubusercontent.com/3297411/51798435-2760eb00-224d-11e9-917c-a4942a652d35.png" alt="enfore_https"></p><p>Github 会自动保持 HTTPS 证书的有效。</p><h2>项目 Pages</h2><p>当给项目设置 Pages 时，一般都已经有一个个人或者公司的 Pages 了，如果没有，就可以按以上的过程添加。如果已经设置了，则只需要很简单的两步即可：</p><p>以下以个人项目 <code>[qiwihui/fullstackpython.com](https://github.com/qiwihui/fullstackpython.com)</code>，设置地址为 <code>fullstackpython.qiwihui.com</code></p><ol><li>在项目中开启 Github Pages，并添加 <code>CNAME</code> 文件指向 <code>fullstackpython.qiwihui.com</code>：</li></ol><p><img src="https://user-images.githubusercontent.com/3297411/51803267-2dc38700-228e-11e9-8ee8-03e80ec711c9.png" alt="fullstackpython"></p><ol start="2"><li>在 DNS 记录中添加 CNAME 记录将 <code>fullstackpython.qiwihui.com</code> 指向 <code>qiwihui.github.io</code>，即 <code>&lt;你的 github 用户名&gt;.github.io</code>。对于公司来说，这个地址是 <code>&lt;公司名称&gt;.github.io</code>。</li></ol><p><img src="https://user-images.githubusercontent.com/3297411/51803299-8004a800-228e-11e9-8721-e640e4377df1.png" alt="fullstackpython-record"></p><p>一段时间后即可。</p><h2>参考</h2><ul><li><a href="https://help.github.com/articles/using-a-custom-domain-with-github-pages/" target="_blank" rel="noopener">Using a custom domain with GitHub Pages</a></li><li><a href="https://help.github.com/articles/custom-domain-redirects-for-github-pages-sites/" target="_blank" rel="noopener">Custom domain redirects for GitHub Pages sites</a></li><li><a href="https://stackoverflow.com/a/9123911/3218128" target="_blank" rel="noopener">Custom domain for GitHub project pages 的回答</a></li><li><a href="https://anmonteiro.com/2015/08/custom-subdomains-in-github-project-pages/" target="_blank" rel="noopener">Custom subdomains in GitHub project pages</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博客将整理在配置博客以及项目 Pages 的自定义域名过程，遇到的问题以及解决方法。&lt;a href=&quot;https://help.github.com/articles/using-a-custom-domain-with-github-pages/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github 的文档&lt;/a&gt;对于如何配置自定义域名有详细的介绍，这里不会全部翻译，只重点记录实践的过程，内容涉及为用户网站，公司网站，以及项目网站添加 &lt;code&gt;Apex&lt;/code&gt; 域名（&lt;a href=&quot;http://qiwihui.com&quot;&gt;qiwihui.com&lt;/a&gt;），二级域名（&lt;a href=&quot;http://www.qiwihui.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.qiwihui.com&lt;/a&gt;）以及开启 HTTPS。最后，所有指向 &lt;code&gt;www.qiwihui.com&lt;/code&gt; 的请求将会被重定向至 &lt;code&gt;https://qiwihui.com&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>如何阅读苹果开发文档</title>
    <link href="https://qiwihui.com/qiwihui-blog-46/"/>
    <id>https://qiwihui.com/qiwihui-blog-46/</id>
    <published>2019-01-14T17:59:58.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/3297411/51306754-16f48780-1a79-11e9-9959-b6f94a4cae45.jpg" alt="coding-woman-5"></p><p>原文：<a href="https://www.hackingwithswift.com/articles/167/how-to-read-apples-developer-documentation" target="_blank" rel="noopener">How to read Apple’s developer documentation</a></p><p>对于很多人来说，这篇文章听起来很奇怪，因为我们已经习惯了 Apple 的 API 文档的工作方式，因此我们精神上已经经过调整以快速找到我们想要的东西。</p><p>但这是一个有趣的事实：去年我最热门的文章请求之一是帮助人们真正阅读 Apple 的代码文档。您如何找到您需要的 iOS API，如何浏览所有材料以找到您真正想要的内容，以及您如何深入了解为什么事情按照他们的方式工作？</p><p>所以，如果你曾经寻求帮助来理解 Apple 的开发者文档，首先我要让你知道你并不孤单 - 许多人都在努力解决这个问题。但其次，我希望这篇文章会有所帮助：我会尽力解释它的结构，它有什么好处（以及不好的地方），以及如何使用它。</p><p>更重要的是，我将向您展示经验丰富的开发人员寻找额外信息的位置，这些信息通常比Apple的在线文档更有价值。</p><a id="more"></a><h2>“这是什么？” vs “你怎么用它？”</h2><p>任何书面的 API 文档通常采用以下五种形式之一：</p><ol><li>接口代码，显示了什么是方法名称和参数，属性名称和类型，以及类似的，带有一些描述它应该做什么的文本。</li><li>API 的文本描述了它应该做什么以及一般指导用例。</li><li>广泛使用的有用的 API 示例代码。</li><li>如何使用 API 代码段。</li><li>解决常见问题的简单教程：如何做 X，如何做 Y，以及如何做 Z 等等。</li></ol><p>粗略地说，苹果公司第一点做了很多，其次是第二点和第三点，第四点很少，第五点几乎没有。</p><p>所以，如果你正在寻找“如何用 Y 做 X ”的具体例子，你最好从我的 <a href="https://www.hackingwithswift.com/example-code" target="_blank" rel="noopener">Swift 知识库</a>开始 - 这正是它的用途。</p><p>了解 Apple 的文档解决的问题，可以帮助您从中获得最大收益。它并不是一个结构化的教程，它不会向您介绍一系列概念来帮助您实现目标，而是作为 Apple 支持的数千个 API 的参考指南。</p><h2>寻找一个类</h2><p>Apple的在线文档位于 <a href="https://developer.apple.com/documentation/" target="_blank" rel="noopener">https://developer.apple.com/documentation/</a> ，虽然您能在 Xcode 中使用本地副本，但我会说大多数人使用在线版本只是因为他们可以更容易地找到内容。</p><p>绝大多数 Apple 的文档都描述了接口，而这正是大多数时候你会看到的。我想使用一个实际的例子，所以请先在您的网络浏览器中打开https://developer.apple.com/documentation/ ，这是所有Apple开发者文档的主页。</p><p><img src="https://user-images.githubusercontent.com/3297411/51331392-9f444e00-1ab4-11e9-94df-48407c8102c3.png" alt="apple-developer-documentation"></p><p>您会看到所有 Apple 的 API 分为 <code>App Frameworks</code> 或 <code>Graphics and Games</code> 等类别，您已经看到了一件重要的事情：所有深蓝色文本都是可点击的，并会带您进入特定框架的API文档。是的，它使用相同的字体和大小，没有下划线，说实话，深蓝色链接和黑色文本之间没有太大区别，但你仍然需要留意这些链接 - 有很多他们，你会用它们来深入挖掘主题。</p><p>现在请从 <code>App Frameworks</code> 类别中选择 <code>UIKit</code>，您将看到它的功能（为iOS创建用户界面）的简要概述，标有“<code>重要</code>”（<code>Important</code>）的大黄色框，然后是类别列表。那些黄色的盒子确实值得关注：虽然它们经常被使用，它们几乎总能阻止你犯下根本错误，这些错误导致出现奇怪的问题。</p><p><img src="https://user-images.githubusercontent.com/3297411/51331416-aa977980-1ab4-11e9-886a-9dc54dae0189.png" alt="uikit-overview"></p><p>此页面上重要的是共同描述 <code>UIKit</code> 的类别列表。这是人们经常迷路的地方：他们想要了解像 <code>UIImage</code> 这样的东西，所以他们必须仔细查看该列表以找到它可能出现的合适位置。</p><p><img src="https://user-images.githubusercontent.com/3297411/51331432-b4b97800-1ab4-11e9-8d70-de35c34d58d4.png" alt="uikit-topics"></p><p>在这种情况下，您可能会查看“资源管理”（<code>Resource Management</code>），因为它的副标题“管理存储在主可执行文件之外的图像，字符串，故事板和 nib 文件”听起来很有希望。但是，您会感到失望 - 您需要向下滚动到 “图像和 PDF”（<code>Images and PDF</code>）部分才能找到 <code>UIImage</code>。</p><p>这就是为什么我谈过的大多数人只是使用自己喜欢的搜索引擎。他们输入他们关心的类，并且 - 只要它有“UI”，“SK”或类似的前缀 - 它可能是第一个结果。</p><p>不要误会我的意思：我知道这种做法并不理想。但是面对搜索一个类或者去 <a href="https://developer.apple.com/documentation/" target="_blank" rel="noopener">https://developer.apple.com/documentation/</a> ，选择一个框架，选择一个类别，然后选择一个类，第一个就是更快。</p><p>重要提示：无论您选择哪种方法，最终都会在同一个地方，所以只做最适合您的方法。现在，请找到并选择 <code>UIImage</code>。</p><h2>阅读类的接口</h2><p>一旦选择了您关心的类，该页面就有四个主要组件：概述，版本摘要，接口和关系。</p><p><img src="https://user-images.githubusercontent.com/3297411/51334152-32cc4d80-1aba-11e9-9748-3ffdab35aafc.png" alt="uiimage-overview"></p><p>概述是“API的文本描述，描述了它应该做什么以及一般指导用例”，我之前提到过 - 我要求你选择 <code>UIImage</code>，因为它是文本描述何时运行良好的一个很好的例子。</p><p>当它是我第一次使用的类时，特别是如果它刚刚推出时，我通常会阅读概述文本。但是对于其他一切 - 我之前至少使用过一次的任何类 - 我跳过它并尝试找到我所得到的具体细节。请记住，Apple 文档确实不是一种学习工具：当您考虑到特定目的时，它最有效。</p><p>如果您不总是为所选 Apple 平台的最新版本开发，则版本摘要 - 页面右侧的侧栏 - 非常重要。在这种情况下，您将看到 <code>iOS 2.0 +</code>，<code>tvOS 9.0+</code> 和 <code>watchOS 2.0+</code>，它告诉我们何时 <code>UIImage</code> 类首次在这三个操作系统上可用，并且它仍然可用 - 如果它已被弃用（不再可用）你会看到像 <code>iOS 2.0-9.0</code> 这样的东西。</p><p>此页面上的实际内容 - 以及作为 Apple 框架中特定类的主页的所有页面 - 都列在“主题”标题下。这将列出该类支持的所有属性和方法，再次分解为使用类别：“获取图像数据”，“获取图像大小和比例”等。</p><p><img src="https://user-images.githubusercontent.com/3297411/51334198-44adf080-1aba-11e9-8d86-2eac5e0191d2.png" alt="uiimage-topics"></p><p>如果您选择的类具有任何自定义初始化方法，则始终会首先显示它们。 <code>UIImage</code> 有很多自定义初始化方法，你会看到它们都被列为签名 - 只是描述它所期望的参数的部分。所以，你会看到这样的代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init</span>?(named: <span class="type">String</span>)</span><br><span class="line"><span class="keyword">init</span>(imageLiteralResourceName: <span class="type">String</span>)</span><br></pre></td></tr></table></figure><p>**提示：**如果您看到 <code>Objective-C</code> 代码，请确保将语言更改为 <code>Swift</code>。您可以在页面的右上角执行此操作，也可以在重要的 iOS 测试版引入更改时启用 API 更改选项。</p><p><img src="https://user-images.githubusercontent.com/3297411/51334211-4aa3d180-1aba-11e9-8d34-33f922b01733.png" alt="switch-swift"></p><p>记住，初始化方法写成 <code>init?</code> 而不是 <code>init</code> 的是容易出错的 - 它们返回一个可选项，以便在初始化失败时它们可以返回 <code>nil</code>。</p><p>在初始化器的正下方，您有时会看到一些用于创建类的高度专业化实例的方法。这些不是 Swift 意义上的初始化器，但它们确实创建了类的实例。对于 <code>UIImage</code>，你会看到这样的事情：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">animatedImageNamed</span>(<span class="title">String</span>, <span class="title">duration</span>: <span class="title">TimeInterval</span>) -&gt; <span class="title">UIImage</span>?</span></span><br></pre></td></tr></table></figure><p><code>class func</code> 部分意味着你将使用 <code>UIImage.animatedImageNamed()</code> 方式调用。</p><p>在初始化程序之后，事情变得有点不那么有条理：你会发现属性方法和枚举自由混合在一起。虽然您可以滚动查找您要查找的内容，但我可以认为大多数人只需要 <code>Cmd + F</code> 在页面上查找文字就可以了！</p><p>有三点需要注意：</p><ul><li>嵌套类型 - 类，结构和枚举 - 与属性和方法一起列出，这需要一点时间习惯。例如，<code>UIImage</code> 包含嵌套的枚举 <code>ResizingMode</code>。</li><li>任何带有直线穿过的东西都是不推荐使用的。这意味着 Apple 打算在某些时候将其删除，因此您不应将其用于将来的代码，并建议开始重写任何现有代码。（在实践中，大多数API长期以来都被“弃用” - 许多许多年。）</li><li>一些非常复杂的类 - 例如，<code>UIViewController</code> - 会将额外的文档页面与其方法和属性混合在一起。查找它们旁边的页面图标，以及一个简单的英文标题，如“相对于安全区域定位内容”（<code>Positioning Content Relative to the Safe Area</code>）。</li></ul><p>在页面的底部你会找到 <code>Relationships</code>，它告诉你它继承了哪个类（在这种情况下它直接来自 <code>NSObject</code>），以及它符合的所有协议。当您查看 Swift 类型时，本节更有用，其中协议关系更复杂。</p><h2>阅读属性或方法页面</h2><p>您已经选择了一个框架和类，现在是时候查看特定的属性或方法了。查找并选择此方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">animatedResizableImageNamed</span>(<span class="title">String</span>, <span class="title">capInsets</span>: <span class="title">UIEdgeInsets</span>, <span class="title">resizingMode</span>: <span class="title">UIImage</span>.<span class="title">ResizingMode</span>, <span class="title">duration</span>: <span class="title">TimeInterval</span>) -&gt; <span class="title">UIImage</span>?</span></span><br></pre></td></tr></table></figure><p>您应该在 <code>Creating Specialized Image Objects</code> 类别中找到它。</p><p><img src="https://user-images.githubusercontent.com/3297411/51361359-6f279a00-1b0a-11e9-8126-7c3318d701f0.png" alt="animatedresizableimagenamed-1"><img src="https://user-images.githubusercontent.com/3297411/51361364-72bb2100-1b0a-11e9-9099-1c3c17356ae9.png" alt="animatedresizableimagenamed-2"></p><p>这不是一个复杂的方法，但它确实展示了这些页面的重要部分：</p><ul><li>Apple 有几种不同的方法来编写方法名称。之前的那个 - 长 <code>class func animatedResizableImageNamed</code> - 然后是方法页面标题中显示的形式（<code>animatedResizableImageNamed(_:capInsets:resizingMode:duration:)</code>），以及方法页面的声明部分中的形式。</li><li>正如您在版本摘要中所看到的（在右侧），此方法在 <code>iOS 6.0</code> 中引入。因此，虽然主要的 <code>UIImage</code> 类从第1天开始就已存在，但这种方法是在几年后推出的。</li><li>方法声明的各个部分都是可点击的，都是紫色的。但是要小心：如果你单击 <code>UIImage.ResizingMode</code>，你将去哪里取决于你是否点击了“UIImage”或“ResizingMode”。 （提示：您通常需要单击右侧的那个。）</li><li>您将看到每个参数含义和返回值的简要说明。</li><li>“讨论”（<code>Discussion</code>）部分详细介绍了此方法的具体使用说明。这几乎总是 - 每个页面中最有用的部分，因为在这里您可以看到“不要调用此方法”或“小心…”</li><li>你可能会找到一个 <code>See Also</code> 部分，但这有点受欢迎 - 这里只是我们在上一页的方法列表。</li></ul><p>现在，<code>UIImage</code> 是一个老类，并没有太大变化，因此它的文档处于良好状态。但是一些较新的 API - 以及许多没有像 <code>UIKit</code> 那样被喜欢的旧 API - 仍然记录不足。例如，来自 <code>SceneKit</code> 的 <code>SCNAnimation</code> 或来自 <code>UIKit</code> 的 <code>UITextDragPreviewRenderer</code>：两者都是在 iOS 11 中引入的，并且在它们发布18个月后仍然包含“无可用概述（No overview available）”作为其文档。</p><p>当你看到“没有可用的概述（No overview available）”时，你会失望，但不要放弃：让我告诉你接下来要做什么…</p><h2>查看代码</h2><p>尽管 Apple 的在线文档相当不错，但您经常会遇到“无可用概述（No overview available）”，或者您发现没有足够的信息来回答您的问题。</p><p><a href="https://en.wikipedia.org/wiki/Conway%27s_law" target="_blank" rel="noopener">康威定律（Conway’s law）</a>指出，设计系统的组织受制于设计，这些设计是这些组织的通信结构的副本。“也就是说，如果你以某种方式工作，你将以类似的方式设计事物。</p><p>Apple 在我们行业中的独特地位使他们以一种相当不寻常的方式工作 - 几乎可以肯定它与您自己公司的工作方式完全不同。是的，他们有 API 审核讨论，他们试图讨论API应该如何用两种语言看待，是的，他们有专门的团队来制作文档和示例代码。</p><p>但是他们获取示例代码的门槛非常高：通常需要一些非常好的东西才能拿出来，并且通过多层检查来处理法律问题。因此，虽然我可以在一小时内输入一个项目并立即将其发布为文章，但 Apple 需要花费更长的时间才能完成同样的工作 - 他们非常认真地对待他们的形象，而且非常正确。如果你曾经想过为什么文章很少出现在官方 Swift 博客上，现在你知道了！</p><p>现在，我说这一切的原因是 Apple 有一个快速使用的捷径：他们的工程师在他们的代码中留下评论的门槛似乎显着降低，这意味着你经常会在 Xcode 中找到有价值的信息。这些评论就像细小的金子（gold dust）一样：它们直接来自 Apple 的开发者，而不是他们的开发者出版（developer publications）团队，而且我对 devpubs 非常热爱，很高兴直接听到来自源头的声音。</p><p>还记得我提到过 SceneKit 的 <code>SCNAnimation</code> 在 Apple 的开发者网站上没有记录吗？好吧，让我们来看看Xcode可以向我们展示的内容：按 <code>Cmd + O</code> 打开“快速打开（Open Quickly）”菜单，确保右侧的 Swift 图标为彩色而不是空心，然后键入“SCNAnimation”。</p><p>您将看到列出的一些选项，但您正在寻找 <code>SCNAnimation.h</code> 中定义的选项。如果您不确定，选择 <code>YourClassName.h</code> 文件是您最好的选择。</p><p>无论如何，如果你打开 <code>SCNAnimation.h</code> Xcode 将显示生成的 SCNAnimation 头文件版本。它的生成是因为原始版本是Objective-C，因此 Xcode 为 Swift 进行了实时翻译 - 这就是 <code>Swift Quickly</code> 框中的彩色 Swift 徽标的含义。</p><p>现在，如果你按 <code>Cmd + F</code> 并搜索“class SCNAnimation”，你会发现：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> SCNAnimation represents an animation that targets a specific key path.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">11.0</span>, *)</span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">SCNAnimation</span> : <span class="title">NSObject</span>, <span class="title">SCNAnimationProtocol</span>, <span class="title">NSCopying</span>, <span class="title">NSSecureCoding</span> </span>&#123;  </span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">     Initializers</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     Loads and returns an animation loaded from the specified URL.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     @param animationUrl The url to load.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*not inherited*/</span> <span class="keyword">init</span>(contentsOf animationUrl: <span class="type">URL</span>)</span><br></pre></td></tr></table></figure><p>这只是一个开始。 是的，该类及其所有内部都有文档，包括用法说明，默认值等。 所有这一切都应该在在线文档中，但无论出于什么原因它仍然没有，所以要准备好查找代码作为一个有用的补充。</p><h2>最后的提示</h2><p>此时，您应该能够查找在线文档以获取您喜欢的任何代码，并查找头文件注释以获取额外的使用说明。</p><p>但是，在准备好面对全部 Apple 文档之前，还有两件事需要了解。</p><p>首先，您经常会遇到标记为“已归档（archived”）”，“遗留（“legacy”）”或“已退休（“retired）”的文档 - 即使对于相对较新的事物也是如此。当它真的老了，你会看到诸如“这篇文章可能不代表当前发展的最佳实践”之类的消息。下载和其他资源的链接可能不再有效。“</p><p>尽管 Apple 是世界上最大的公司之一，但 Apple 的工程和 devpubs 团队几乎没有人员 - 他们不可能在保留所有内容的同时覆盖新的 API。因此，当你看到“存档”文档或类似文件时，请运用你的判断：如果它在某个版本的 Swift 中至少你知道它最近是模糊的，但即使不是，你仍然可能会发现那里有很多有价值的信息。</p><p>其次，Apple 拥有一些特别有价值的出色文档。这些都列在 <a href="https://developer.apple.com" target="_blank" rel="noopener">https://developer.apple.com</a> 的页脚中，但主要是<a href="https://developer.apple.com/design/human-interface-guidelines/" target="_blank" rel="noopener">人机界面指南</a>。这将引导您完整地为 Apple 平台设计应用程序的所有部分，包括说明关键点的图片，并提供大量具体建议。即使这个文档是构建 iOS 应用程序时最重要的一个，但很少有开发人员似乎已经阅读过它！</p><h2>接下来做什么？</h2><p>我之前曾写过<a href="https://www.hackingwithswift.com/articles/42/apple-can-we-please-talk-about-your-documentation" target="_blank" rel="noopener">关于 Apple 文档的问题</a> - 我担心那里没有鼓励，但至少如果你在努力，它可能会让你觉得不那么孤单。</p><p>幸运的是，我有很多可能更有用的材料：</p><ul><li>我的<a href="https://www.hackingwithswift.com/example-code" target="_blank" rel="noopener">Swift知识库（Swift Knowledge Base）</a>包含针对 Swift 和 iOS 开发人员的600多个问答，技巧和技术点 - 它可以帮助您更快地解决问题。</li><li>我的<a href="https://www.hackingwithswift.com/glossary" target="_blank" rel="noopener">Swift术语表（Glossary of Common Swift Terms）</a>在 Swift 开发中定义了100多个常用术语，所有术语都在一页上。</li><li><a href="https://www.hackingwithswift.com/read" target="_blank" rel="noopener">我有一本全书使用项目教授 Swift 和 iOS</a>，它专门用于在逻辑流程中引入概念。</li></ul><p>您认为阅读Apple文档最有效的方法是什么？ 在Twitter上发送你的提示：<a href="https://twitter.com/twostraws" target="_blank" rel="noopener">@twostraws</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3297411/51306754-16f48780-1a79-11e9-9959-b6f94a4cae45.jpg&quot; alt=&quot;coding-woman-5&quot;&gt;&lt;/p&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://www.hackingwithswift.com/articles/167/how-to-read-apples-developer-documentation&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;How to read Apple’s developer documentation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于很多人来说，这篇文章听起来很奇怪，因为我们已经习惯了 Apple 的 API 文档的工作方式，因此我们精神上已经经过调整以快速找到我们想要的东西。&lt;/p&gt;
&lt;p&gt;但这是一个有趣的事实：去年我最热门的文章请求之一是帮助人们真正阅读 Apple 的代码文档。您如何找到您需要的 iOS API，如何浏览所有材料以找到您真正想要的内容，以及您如何深入了解为什么事情按照他们的方式工作？&lt;/p&gt;
&lt;p&gt;所以，如果你曾经寻求帮助来理解 Apple 的开发者文档，首先我要让你知道你并不孤单 - 许多人都在努力解决这个问题。但其次，我希望这篇文章会有所帮助：我会尽力解释它的结构，它有什么好处（以及不好的地方），以及如何使用它。&lt;/p&gt;
&lt;p&gt;更重要的是，我将向您展示经验丰富的开发人员寻找额外信息的位置，这些信息通常比Apple的在线文档更有价值。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="iOS" scheme="https://qiwihui.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>在iOS-Swift项目中集成CppJieba分词</title>
    <link href="https://qiwihui.com/qiwihui-blog-45/"/>
    <id>https://qiwihui.com/qiwihui-blog-45/</id>
    <published>2019-01-14T01:21:31.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>在垃圾短信过滤应用 <code>SMSFilters</code> 中，需要使用 <code>Jieba</code> 分词库来対短信进行分词，然后使用 <code>TF-IDF</code> 来进行处理` 分词库是 C++ 写的，这就意味着需要在Swift中集成 C++ 库。在官方文档 “<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html" target="_blank" rel="noopener">Using Swift with Cocoa and Objective-C</a>” 中，Apple只是介绍了怎么将 Swift 代码跟 Objective-C 代码做整合，但是没有提C++，后来在官方文档中看到了这样一段话：</p><blockquote><p>You cannot import C++ code directly into Swift. Instead, create an Objective-C or C wrapper for C++ code.</p></blockquote><p>也就是不能直接导入 C++ 代码，但是可以使用 Objective-C 或者 C 对 C++ 进行封装。所以项目中使用 Objective-C 做封装，然后在 Swift 中调用，下面就是这个过程的实践，Demo 代码见 <a href="https://github.com/qiwihui/SwiftJiebaDemo" target="_blank" rel="noopener">SwiftJiebaDemo</a>。</p><a id="more"></a><h2>整合过程</h2><p>分成三步：</p><ol><li>引入C++文件；</li><li>用 Objective-C 封装；</li><li>在 Swift 中 调用 Objective-C；</li></ol><h3>引入C++文件</h3><p>Demo中使用的是&quot;结巴&quot;中文分词的 C++ 版本 <a href="https://github.com/yanyiwu/cppjieba" target="_blank" rel="noopener">yanyiwu/cppjieba</a>。将其中的 <code>include/cppjieba</code> 和依赖 <code>limonp</code> 合并，并加入 <code>dict</code> 中的 <code>hmm_model</code> 和 <code>jiaba.dict</code> 作为基础数据，并暴露 <code>JiebaInit</code> 和  <code>JiebaCut</code> 接口：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Segmentor.cpp</span></span><br><span class="line"><span class="comment">//  iosjieba</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by yanyiwu on 14/12/24.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 yanyiwu. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Segmentor.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cppjieba;</span><br><span class="line"></span><br><span class="line">cppjieba::MixSegment * globalSegmentor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JiebaInit</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; dictPath, <span class="keyword">const</span> <span class="built_in">string</span>&amp; hmmPath, <span class="keyword">const</span> <span class="built_in">string</span>&amp; userDictPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(globalSegmentor == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        globalSegmentor = <span class="keyword">new</span> MixSegment(dictPath, hmmPath, userDictPath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; __FILE__ &lt;&lt; __LINE__ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JiebaCut</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; sentence, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(globalSegmentor);</span><br><span class="line">    globalSegmentor-&gt;Cut(sentence, words);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; __FILE__ &lt;&lt; __LINE__ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; words &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Segmentor.h</span></span><br><span class="line"><span class="comment">//  iosjieba</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by yanyiwu on 14/12/24.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 yanyiwu. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __iosjieba__Segmentor__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __iosjieba__Segmentor__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cppjieba/MixSegment.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> cppjieba::MixSegment * globalSegmentor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JiebaInit</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dictPath, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; hmmPath, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; userDictPath)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JiebaCut</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; sentence, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; words)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* defined(__iosjieba__Segmentor__) */</span></span></span><br></pre></td></tr></table></figure><p>目录如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tree iosjieba</span><br><span class="line">iosjieba</span><br><span class="line">├── Segmentor.cpp</span><br><span class="line">├── Segmentor.h</span><br><span class="line">├── cppjieba</span><br><span class="line">│   ├── DictTrie.hpp</span><br><span class="line">│   ├── FullSegment.hpp</span><br><span class="line">│   ├── HMMModel.hpp</span><br><span class="line">│   ├── HMMSegment.hpp</span><br><span class="line">│   ├── Jieba.hpp</span><br><span class="line">│   ├── KeywordExtractor.hpp</span><br><span class="line">│   ├── MPSegment.hpp</span><br><span class="line">│   ├── MixSegment.hpp</span><br><span class="line">│   ├── PosTagger.hpp</span><br><span class="line">│   ├── PreFilter.hpp</span><br><span class="line">│   ├── QuerySegment.hpp</span><br><span class="line">│   ├── SegmentBase.hpp</span><br><span class="line">│   ├── SegmentTagged.hpp</span><br><span class="line">│   ├── TextRankExtractor.hpp</span><br><span class="line">│   ├── Trie.hpp</span><br><span class="line">│   ├── Unicode.hpp</span><br><span class="line">│   └── limonp</span><br><span class="line">│       ├── ArgvContext.hpp</span><br><span class="line">│       ├── BlockingQueue.hpp</span><br><span class="line">│       ├── BoundedBlockingQueue.hpp</span><br><span class="line">│       ├── BoundedQueue.hpp</span><br><span class="line">│       ├── Closure.hpp</span><br><span class="line">│       ├── Colors.hpp</span><br><span class="line">│       ├── Condition.hpp</span><br><span class="line">│       ├── Config.hpp</span><br><span class="line">│       ├── FileLock.hpp</span><br><span class="line">│       ├── ForcePublic.hpp</span><br><span class="line">│       ├── LocalVector.hpp</span><br><span class="line">│       ├── Logging.hpp</span><br><span class="line">│       ├── Md5.hpp</span><br><span class="line">│       ├── MutexLock.hpp</span><br><span class="line">│       ├── NonCopyable.hpp</span><br><span class="line">│       ├── StdExtension.hpp</span><br><span class="line">│       ├── StringUtil.hpp</span><br><span class="line">│       ├── Thread.hpp</span><br><span class="line">│       └── ThreadPool.hpp</span><br><span class="line">└── iosjieba.bundle</span><br><span class="line">    └── dict</span><br><span class="line">        ├── hmm_model.utf8</span><br><span class="line">        ├── jieba.dict.small.utf8</span><br><span class="line">        └── user.dict.utf8</span><br></pre></td></tr></table></figure><p>接下来开始在项目中集成。首先创建一个空项目 <code>iOSJiebaDemo</code>，将 <code>iosjieba</code> 加入项目中。</p><table><thead><tr><th style="text-align:center">单页应用</th><th style="text-align:center">SwiftJiebaDemo</th><th style="text-align:center">添加 SwiftJiebaDemo</th></tr></thead><tbody><tr><td style="text-align:center"><img src="https://user-images.githubusercontent.com/3297411/51162445-26d16780-18d1-11e9-9385-123b8b64fbb9.png" alt="create-single-view-app"></td><td style="text-align:center"><img src="https://user-images.githubusercontent.com/3297411/51162258-8713d980-18d0-11e9-9c9e-ffec10c8d2dc.png" alt="swift-jieba-demo-1"></td><td style="text-align:center"><img src="https://user-images.githubusercontent.com/3297411/51162266-8f6c1480-18d0-11e9-922e-a5b728e85eb9.png" alt="swift-jieba-demo-2"></td></tr></tbody></table><p>添加 iosjieba:</p><p><img src="https://user-images.githubusercontent.com/3297411/51162030-ae1ddb80-18cf-11e9-8e2f-8692e2e7f915.png" alt="iosjieba-1"></p><p>见代码： <a href="https://github.com/qiwihui/SwiftJiebaDemo/commit/caeb6c2f9fb005a9bc518ee67890814481676807" target="_blank" rel="noopener">https://github.com/qiwihui/SwiftJiebaDemo/commit/caeb6c2f9fb005a9bc518ee67890814481676807</a></p><h3>C++ 到 Objective-C 封装</h3><p>这个过程是将 C++ 的接口进行 Objective-C 封装，向 Swift 暴露。这个封装只暴露了 <code>objcJiebaInit</code> 和 <code>objcJiebaCut</code> 两个接口。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//</span><br><span class="line">//  iosjiebaWrapper.h</span><br><span class="line">//  SMSFilters</span><br><span class="line">//</span><br><span class="line">//  Created by Qiwihui on 1/14/19.</span><br><span class="line">//  Copyright © 2019 qiwihui. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface JiebaWrapper : NSObject</span><br><span class="line"></span><br><span class="line">- (void) objcJiebaInit: (NSString *) dictPath forPath: (NSString *) hmmPath forDictPath: (NSString *) userDictPath;</span><br><span class="line">- (void) objcJiebaCut: (NSString *) sentence toWords: (NSMutableArray *) words;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//</span><br><span class="line">//  iosjiebaWrapper.mm</span><br><span class="line">//  iOSJiebaTest</span><br><span class="line">//</span><br><span class="line">//  Created by Qiwihui on 1/14/19.</span><br><span class="line">//  Copyright © 2019 Qiwihui. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;iosjiebaWrapper.h&quot;</span><br><span class="line">#include &quot;Segmentor.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation JiebaWrapper</span><br><span class="line"></span><br><span class="line">- (void) objcJiebaInit: (NSString *) dictPath forPath: (NSString *) hmmPath forDictPath: (NSString *) userDictPath &#123;</span><br><span class="line"></span><br><span class="line">    const char *cDictPath = [dictPath UTF8String];</span><br><span class="line">    const char *cHmmPath = [hmmPath UTF8String];</span><br><span class="line">    const char *cUserDictPath = [userDictPath UTF8String];</span><br><span class="line">    </span><br><span class="line">    JiebaInit(cDictPath, cHmmPath, cUserDictPath);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) objcJiebaCut: (NSString *) sentence toWords: (NSMutableArray *) words &#123;</span><br><span class="line">    </span><br><span class="line">    const char* cSentence = [sentence UTF8String];</span><br><span class="line">    </span><br><span class="line">    std::vector&lt;std::string&gt; wordsList;</span><br><span class="line">    for (int i = 0; i &lt; [words count];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        wordsList.push_back(wordsList[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    JiebaCut(cSentence, wordsList);</span><br><span class="line">    </span><br><span class="line">    [words removeAllObjects];</span><br><span class="line">    std::for_each(wordsList.begin(), wordsList.end(), [&amp;words](std::string str) &#123;</span><br><span class="line">        id nsstr = [NSString stringWithUTF8String:str.c_str()];</span><br><span class="line">        [words addObject:nsstr];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>见代码： <a href="https://github.com/qiwihui/SwiftJiebaDemo/commit/7d196bb2c33280a4f419be21b47961a521618221" target="_blank" rel="noopener">https://github.com/qiwihui/SwiftJiebaDemo/commit/7d196bb2c33280a4f419be21b47961a521618221</a></p><h3>Objective-C 到 Swift</h3><p>在 Swift 中调用 Objecttive-C 的接口，这个在官方文档和许多博客中都有详细介绍。</p><ol><li>加入 <code>{project_name}-Bridging-Header.h</code> 头文件，即 <code>SwiftJiebaDemo_Bridging_Header_h</code>，引入之前封装的头文件，并在 <code>Targets -&gt; Build Settings -&gt; Objective-C Bridging Header</code> 中设置头文件路径 <code>SwiftJiebaDemo/SwiftJiebaDemo_Bridging_Header_h</code>。</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//</span><br><span class="line">//  SwiftJiebaDemo-Bridging-Header.h</span><br><span class="line">//  SwiftJiebaDemo</span><br><span class="line">//</span><br><span class="line">//  Created by Qiwihui on 1/15/19.</span><br><span class="line">//  Copyright © 2019 Qiwihui. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#ifndef SwiftJiebaDemo_Bridging_Header_h</span><br><span class="line">#define SwiftJiebaDemo_Bridging_Header_h</span><br><span class="line"></span><br><span class="line">#import &quot;iosjiebaWrapper.h&quot;</span><br><span class="line"></span><br><span class="line">#endif /* SwiftJiebaDemo_Bridging_Header_h */</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/3297411/51162068-d60d3f00-18cf-11e9-951f-ec5c20e984dc.png" alt="bridging-header-2"></p><ol start="2"><li>将使用到 C++ 的 Objective-C 文件修改为 Objective-C++ 文件，即 将 <code>.m</code> 改为 <code>.mm</code>: <code>iosjiebaWrapper.m</code> 改为 <code>iosjiebaWrapper.mm</code>。</li></ol><p>见代码：<a href="https://github.com/qiwihui/SwiftJiebaDemo/commit/94852b1357b0a0a4b2e8b92384fbdb1b16c80ed8" target="_blank" rel="noopener">https://github.com/qiwihui/SwiftJiebaDemo/commit/94852b1357b0a0a4b2e8b92384fbdb1b16c80ed8</a></p><h3>使用</h3><p>使用时需要先初始化 <code>Jiaba</code>分词，然后再进行分词。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Classifier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> dictPath = <span class="type">Bundle</span>.main.resourcePath!+<span class="string">"/iosjieba.bundle/dict/jieba.dict.small.utf8"</span></span><br><span class="line">        <span class="keyword">let</span> hmmPath = <span class="type">Bundle</span>.main.resourcePath!+<span class="string">"/iosjieba.bundle/dict/hmm_model.utf8"</span></span><br><span class="line">        <span class="keyword">let</span> userDictPath = <span class="type">Bundle</span>.main.resourcePath!+<span class="string">"/iosjieba.bundle/dict/user.dict.utf8"</span></span><br><span class="line"></span><br><span class="line">        <span class="type">JiebaWrapper</span>().objcJiebaInit(dictPath, forPath: hmmPath, forDictPath: userDictPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tokenize</span><span class="params">(<span class="number">_</span> message:String)</span></span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"tokenize..."</span>)</span><br><span class="line">        <span class="keyword">let</span> words = <span class="type">NSMutableArray</span>()</span><br><span class="line">        <span class="type">JiebaWrapper</span>().objcJiebaCut(message, toWords: words)</span><br><span class="line">        <span class="keyword">return</span> words <span class="keyword">as</span>! [<span class="type">String</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出结果：</p><p><img src="https://user-images.githubusercontent.com/3297411/51162211-5a5fc200-18d0-11e9-9849-c86d2fbf683d.png" alt="result"></p><p>可以看到，测试用例 <code>小明硕士毕业于中国科学院计算所，后在日本京都大学深造</code> 经过分词后为<code>〔拼音〕[&quot;小明&quot;, &quot;硕士&quot;, &quot;毕业&quot;, &quot;于&quot;, &quot;中国科学院&quot;, &quot;计算所&quot;, &quot;，&quot;, &quot;后&quot;, &quot;在&quot;, &quot;日本&quot;, &quot;京都大学&quot;, &quot;深造&quot;]</code>，完成集成。</p><p>见代码： <a href="https://github.com/qiwihui/SwiftJiebaDemo/commit/bc42e1312dff6a9f7171cc69403136bc8a82204c" target="_blank" rel="noopener">https://github.com/qiwihui/SwiftJiebaDemo/commit/bc42e1312dff6a9f7171cc69403136bc8a82204c</a></p><h2>遇到的问题</h2><p>由于自己对于编译链接原理不了解，以及是 iOS 开发初学，因此上面的这个过程中遇到了很多问题，耗时两周才解决，故将遇到的一些问题记录于此，以便日后。</p><ol start="0"><li><code>&quot;cassert&quot; file not found</code></li></ol><p>将 <code>.m</code> 改为 <code>.mm</code> 即可。</p><ol><li><code>compiler not finding &lt;tr1/unordered_map&gt;</code></li></ol><p>设置 <code>C++ Standard Library</code> 为 <code>LLVM libc++</code></p><p><img src="https://user-images.githubusercontent.com/3297411/51225371-3f02be80-1985-11e9-9705-32de84b5dfad.png" alt="llvm"></p><p>参考： <a href="https://stackoverflow.com/questions/42030598/mac-c-compiler-not-finding-tr1-unordered-map" target="_blank" rel="noopener">mac c++ compiler not finding &lt;tr1/unordered_map&gt;</a></p><ol start="2"><li><code>warning: include path for stdlibc++ headers not found; pass '-std=libc++' on the command line to use the libc++ standard library instead [-Wstdlibcxx-not-found]</code></li></ol><p><code>Build Setting -&gt; C++ Standard Library -&gt; libstdc++</code> 修改为 <code>Build Setting -&gt; C++ Standard Library -&gt; libc++</code></p><ol start="3"><li><code>use of unresolved identifier</code></li></ol><p>这个问题在于向项目中加入文件时，<code>Target Membership</code> 设置不正确导致。需要将对于使用到的 Target 都勾上。</p><p>相关参考： <a href="https://learnappmaking.com/unresolved-identifier-understanding-xcode/" target="_blank" rel="noopener">Understanding The “Use of Unresolved Identifier” Error In Xcode</a></p><h2>参考</h2><ul><li><a href="https://stackoverflow.com/users/218152/swiftarchitect" target="_blank" rel="noopener">SwiftArchitect</a> 对问题 “Can I have Swift, Objective-C, C and C++ files in the same Xcode project?” 的<a href="https://stackoverflow.com/a/32546879/3218128" target="_blank" rel="noopener">回答</a></li><li><a href="https://stackoverflow.com/users/218152/swiftarchitect" target="_blank" rel="noopener">SwiftArchitect</a> 对问题 “Can I mix Swift with C++? Like the Objective - C .mm files” 的<a href="https://stackoverflow.com/a/32554229/3218128" target="_blank" rel="noopener">回答</a></li><li><a href="https://blog.voidmain.guru/2014/07/01/integrating-swift-with-c-plus-plus/" target="_blank" rel="noopener">在Swift代码中整合C++类库</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在垃圾短信过滤应用 &lt;code&gt;SMSFilters&lt;/code&gt; 中，需要使用 &lt;code&gt;Jieba&lt;/code&gt; 分词库来対短信进行分词，然后使用 &lt;code&gt;TF-IDF&lt;/code&gt; 来进行处理` 分词库是 C++ 写的，这就意味着需要在Swift中集成 C++ 库。
在官方文档 “&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Using Swift with Cocoa and Objective-C&lt;/a&gt;” 中，Apple只是介绍了怎么将 Swift 代码跟 Objective-C 代码做整合，但是没有提C++，后来在官方文档中看到了这样一段话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You cannot import C++ code directly into Swift. Instead, create an Objective-C or C wrapper for C++ code.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是不能直接导入 C++ 代码，但是可以使用 Objective-C 或者 C 对 C++ 进行封装。所以项目中使用 Objective-C 做封装，然后在 Swift 中调用，下面就是这个过程的实践，Demo 代码见 &lt;a href=&quot;https://github.com/qiwihui/SwiftJiebaDemo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SwiftJiebaDemo&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="iOS" scheme="https://qiwihui.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Cocoapods 和 Carthage 使用笔记</title>
    <link href="https://qiwihui.com/qiwihui-blog-44/"/>
    <id>https://qiwihui.com/qiwihui-blog-44/</id>
    <published>2018-12-25T19:04:31.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<h2>Carthage 和 CoaoaPods 的区别</h2><p><code>CoaoaPods</code> 是一套整体解决方案，我们在 <code>Podfile</code> 中指定好我们需要的第三方库。然后 <code>CocoaPods</code> 就会进行下载，集成，然后修改或者创建我们项目的 <code>workspace</code> 文件，这一系列整体操作。</p><p>相比之下，<code>Carthage</code> 就要轻量很多，它也会一个叫做 <code>Cartfile</code> 描述文件，但 <code>Carthage</code> 不会对我们的项目结构进行任何修改，更不多创建 <code>workspace</code>。它只是根据我们描述文件中配置的第三方库，将他们下载到本地，然后使用 <code>xcodebuild</code> 构建成 <code>framework</code> 文件。然后由我们自己将这些库集成到项目中。<code>Carthage</code> 使用的是一种<strong>非侵入性</strong>的哲学。</p><p>另外 <code>Carthage</code> 除了非侵入性，它还是去中心化的，它的包管理不像 <code>CocoaPods</code> 那样，有一个中心服务器(<a href="http://cocoapods.org" target="_blank" rel="noopener">cocoapods.org</a>)，来管理各个包的元信息，而是依赖于每个第三方库自己的源地址，比如 Github。</p><a id="more"></a><h2>Cocoapods</h2><h3>安装</h3><ol><li><p>（可选）使用 <del>taobao</del> ruby-china 源替换默认 gem 源: <code>gem source blabla..</code></p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gem sources -l</span><br><span class="line">*** CURRENT SOURCES ***</span><br><span class="line"></span><br><span class="line">https://rubygems.org/</span><br><span class="line"></span><br><span class="line">$ gem sources --remove https://rubygems.org/</span><br><span class="line">https://ruby.taobao.org/ removed from sources</span><br><span class="line"></span><br><span class="line">$ gem <span class="built_in">source</span> -a https://gems.ruby-china.com/</span><br><span class="line">https://gems.ruby-china.com/ added to sources</span><br><span class="line"></span><br><span class="line">$ gem <span class="built_in">source</span> -c</span><br><span class="line">*** Removed specs cache ***</span><br><span class="line"></span><br><span class="line">$ gem <span class="built_in">source</span> -u</span><br><span class="line"><span class="built_in">source</span> cache successfully updated</span><br><span class="line"></span><br><span class="line">$ gem sources -l</span><br><span class="line">*** CURRENT SOURCES ***</span><br><span class="line"></span><br><span class="line">https://gems.ruby-china.com/</span><br></pre></td></tr></table></figure></li><li><p><code>sudo gem install cocoapods</code></p></li><li><p>（可选）切换 pod 源</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pod repo</span><br><span class="line"></span><br><span class="line">master</span><br><span class="line">- Type: git (master)</span><br><span class="line">- URL:  https://github.com/CocoaPods/Specs.git</span><br><span class="line">- Path: /Users/qiwihui/.cocoapods/repos/master</span><br><span class="line"></span><br><span class="line">$ pod repo remove master</span><br><span class="line"></span><br><span class="line">$ pod repo add master https://git.coding.net/CocoaPods/Specs.git</span><br><span class="line"></span><br><span class="line">$ pod repo update</span><br><span class="line"></span><br><span class="line">$ pod setup</span><br></pre></td></tr></table></figure></li></ol><pre><code>或者<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://git.coding.net/CocoaPods/Specs.git ~/.cocoapods/repos/master</span><br><span class="line">$ pod repo update</span><br></pre></td></tr></table></figure>切换回官方镜像<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pod repo remove master</span><br><span class="line"></span><br><span class="line">$ pod repo add master https://github.com/CocoaPods/Specs.git</span><br><span class="line"></span><br><span class="line">$ pod repo update</span><br><span class="line">Updating spec repo `master`</span><br><span class="line">  $ /usr/<span class="built_in">local</span>/bin/git -C /Users/qiwihui/.cocoapods/repos/master fetch origin --progress</span><br><span class="line">  remote: Enumerating objects: 511, <span class="keyword">done</span>.        </span><br><span class="line">  remote: Counting objects: 100% (511/511), <span class="keyword">done</span>.        </span><br><span class="line">  remote: Compressing objects: 100% (134/134), <span class="keyword">done</span>.        </span><br><span class="line">  remote: Total 820 (delta 399), reused 449 (delta 367), pack-reused 309        </span><br><span class="line">  Receiving objects: 100% (820/820), 99.24 KiB | 401.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">  Resolving deltas: 100% (501/501), completed with 194 <span class="built_in">local</span> objects.</span><br><span class="line">  From https://github.com/CocoaPods/Specs</span><br><span class="line">     5b04790953c..e3ba7ee3a29  master     -&gt; origin/master</span><br><span class="line">  $ /usr/<span class="built_in">local</span>/bin/git -C /Users/qiwihui/.cocoapods/repos/master rev-parse --abbrev-ref HEAD</span><br><span class="line">  master</span><br><span class="line">  $ /usr/<span class="built_in">local</span>/bin/git -C /Users/qiwihui/.cocoapods/repos/master reset --hard origin/master</span><br><span class="line">  HEAD is now at e3ba7ee3a29 [Add] IOS_OC_BASIC 6.3</span><br><span class="line"></span><br><span class="line">CocoaPods 1.6.0.beta.2 is available.</span><br><span class="line">To update use: `sudo gem install cocoapods --pre`</span><br><span class="line">[!] This is a <span class="built_in">test</span> version we<span class="string">'d love you to try.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">For more information, see https://blog.cocoapods.org and the CHANGELOG for this version at https://github.com/CocoaPods/CocoaPods/releases/tag/1.6.0.beta.2</span></span><br></pre></td></tr></table></figure></code></pre><ol start="4"><li><p>如果Podfile文件中有</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &apos;https://github.com/CocoaPods/Specs.git&apos;</span><br></pre></td></tr></table></figure><p>也需要把它换成repo的源，否则依然是使用GitHub源</p></li></ol><h3>基础用法</h3><ol start="0"><li><p><code>cd &lt;project_folder&gt;</code></p></li><li><p><code>pod init</code></p></li><li><p>编辑 Podfile, example</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 平台，必需</span><br><span class="line">platform :ios, &apos;9.0&apos;</span><br><span class="line"># 隐藏警告</span><br><span class="line">inhibit_all_warnings!</span><br><span class="line"></span><br><span class="line">target &apos;AlamofireDemo&apos; do</span><br><span class="line">    # Using Swift and want to use dynamic frameworks</span><br><span class="line">    use_frameworks!</span><br><span class="line"></span><br><span class="line">    # 项目 Pods</span><br><span class="line">    pod &apos;Alamofire&apos;, &apos;~&gt; 4.5&apos;</span><br><span class="line"></span><br><span class="line">    target &apos;AlamofireDemoTests&apos; do</span><br><span class="line">        inherit! :search_paths</span><br><span class="line">        # 测试 Pods</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure></li></ol><pre><code>版本支持：    - `&gt;`, `&gt;=`, `&lt;`, `&lt;=`    - `~&gt;`: **up to** next major | minor | patch    - `:path` 本地绝对路径    - `:git` git项目地址，还可使用 `:branch`, `:tag`, `:commit`</code></pre><ol start="3"><li><code>pod install</code></li><li><strong>Always</strong> 打开项目下 *.xcworkspace 文件作为项目入口</li></ol><h3>pod install 和 pod update 区别</h3><ul><li><code>pod install [package_name]</code>: 安装特定版本的 pods</li><li><code>pod update [package_name]</code>: 升级 pods 到最新版本</li></ul><h2>Carthage</h2><h3>安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install carthage</span><br></pre></td></tr></table></figure><h3>使用</h3><ol><li><p>编辑 <code>Cartfile</code>，比如 <code>SwiftyJSON</code></p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">github <span class="string">"SwiftyJSON/SwiftyJSON"</span></span><br></pre></td></tr></table></figure></li><li><p>carthage update [–platform ios]</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ carthage update</span><br><span class="line">*** Fetching SwiftyJSON</span><br><span class="line">*** Checking out SwiftyJSON at <span class="string">"4.2.0"</span></span><br><span class="line">*** xcodebuild output can be found <span class="keyword">in</span> /var/folders/kl/g94q0k_571vdjtcwzzcv20s40000gn/T/carthage-xcodebuild.nN22hg.log</span><br><span class="line">*** Building scheme <span class="string">"SwiftyJSON iOS"</span> <span class="keyword">in</span> SwiftyJSON.xcworkspace</span><br><span class="line">*** Building scheme <span class="string">"SwiftyJSON watchOS"</span> <span class="keyword">in</span> SwiftyJSON.xcworkspace</span><br><span class="line">*** Building scheme <span class="string">"SwiftyJSON tvOS"</span> <span class="keyword">in</span> SwiftyJSON.xcworkspace</span><br><span class="line">*** Building scheme <span class="string">"SwiftyJSON macOS"</span> <span class="keyword">in</span> SwiftyJSON.xcworkspace</span><br></pre></td></tr></table></figure></li><li><p><code>Carthage</code> 目录下：</p><ul><li>Build(编译出来的.framework二进制代码库)</li><li>Checkouts(源码)</li></ul> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tree -L 3 Carthage/</span><br><span class="line">Carthage/</span><br><span class="line">├── Build</span><br><span class="line">│   ├── Mac</span><br><span class="line">│   │   ├── SwiftyJSON.framework</span><br><span class="line">│   │   └── SwiftyJSON.framework.dSYM</span><br><span class="line">│   ├── iOS</span><br><span class="line">│   │   ├── 22BD4B6C-0B26-35E1-AF5F-8FB6AEBFD2FD.bcsymbolmap</span><br><span class="line">│   │   ├── C862E8A1-24ED-398A-A8E9-A7384E34EDB1.bcsymbolmap</span><br><span class="line">│   │   ├── SwiftyJSON.framework</span><br><span class="line">│   │   └── SwiftyJSON.framework.dSYM</span><br><span class="line">│   ├── tvOS</span><br><span class="line">│   │   ├── 1ADB9C1F-36CA-3386-BF07-6EE29B5F8081.bcsymbolmap</span><br><span class="line">│   │   ├── SwiftyJSON.framework</span><br><span class="line">│   │   └── SwiftyJSON.framework.dSYM</span><br><span class="line">│   └── watchOS</span><br><span class="line">│       ├── A8A151AB-D15E-3A0B-8A17-BF1A39EC6AB4.bcsymbolmap</span><br><span class="line">│       ├── EA427A42-6D21-3FF4-919F-5E50BF8A5D7B.bcsymbolmap</span><br><span class="line">│       ├── SwiftyJSON.framework</span><br><span class="line">│       └── SwiftyJSON.framework.dSYM</span><br><span class="line">└── Checkouts</span><br><span class="line">    └── SwiftyJSON</span><br><span class="line">        ├── CHANGELOG.md</span><br><span class="line">        ├── Example</span><br><span class="line">        ├── LICENSE</span><br><span class="line">        ├── Package.swift</span><br><span class="line">        ├── README.md</span><br><span class="line">        ├── Source</span><br><span class="line">        ├── SwiftyJSON.podspec</span><br><span class="line">        ├── SwiftyJSON.xcodeproj</span><br><span class="line">        ├── SwiftyJSON.xcworkspace</span><br><span class="line">        ├── Tests</span><br><span class="line">        └── scripts</span><br></pre></td></tr></table></figure></li><li><p>添加生成的文件： 项目 “General” -&gt; “Linked Frameworks and Libraries” -&gt; 将 <code>Carthage/Build/iOS</code> 中的 <code>.framework</code> 文件添加到项目中</p></li><li><p>“Build Phases” -&gt; “+” -&gt; “New Run Script Phase”</p><ul><li>/bin/sh</li><li>/usr/local/bin/carthage copy-frameworks</li><li>“Input Files”: $(SRCROOT)/Carthage/Build/iOS/SwiftyJSON.framework</li><li>“Output Files”: $(BUILT_PRODUCTS_DIR)/$(FRAMEWORKS_FOLDER_PATH)/SwiftyJSON.framework</li></ul><p>添加这个 Run Script 的作用是为了让运行时能够找到这个动态库。还可以将 Carthage 所集成的第三方库生成的符号文件添加到项目中，这样我们在调试的时候，就可以步入第三方库内部的代码：<code>Build Phrases</code> -&gt; <code>New Copy Files Phrase</code>，将 Carthage/Build/iOS 目录中的 <code>SwiftyJSON.framework.dSYM</code> 符号文件拖动进来</p></li></ol><h2>参考</h2><ul><li><a href="https://www.jianshu.com/p/f024ca2267e3" target="_blank" rel="noopener">解决Cocoapods贼慢问题</a></li><li><a href="http://swiftcafe.io/2015/10/25/swift-daily-carthage-package" target="_blank" rel="noopener">Carthage 包管理工具，另一种敏捷轻快的 iOS &amp; MAC 开发体验</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2&gt;Carthage 和 CoaoaPods 的区别&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;CoaoaPods&lt;/code&gt; 是一套整体解决方案，我们在 &lt;code&gt;Podfile&lt;/code&gt; 中指定好我们需要的第三方库。然后 &lt;code&gt;CocoaPods&lt;/code&gt; 就会进行下载，集成，然后修改或者创建我们项目的 &lt;code&gt;workspace&lt;/code&gt; 文件，这一系列整体操作。&lt;/p&gt;
&lt;p&gt;相比之下，&lt;code&gt;Carthage&lt;/code&gt; 就要轻量很多，它也会一个叫做 &lt;code&gt;Cartfile&lt;/code&gt; 描述文件，但 &lt;code&gt;Carthage&lt;/code&gt; 不会对我们的项目结构进行任何修改，更不多创建 &lt;code&gt;workspace&lt;/code&gt;。它只是根据我们描述文件中配置的第三方库，将他们下载到本地，然后使用 &lt;code&gt;xcodebuild&lt;/code&gt; 构建成 &lt;code&gt;framework&lt;/code&gt; 文件。然后由我们自己将这些库集成到项目中。&lt;code&gt;Carthage&lt;/code&gt; 使用的是一种&lt;strong&gt;非侵入性&lt;/strong&gt;的哲学。&lt;/p&gt;
&lt;p&gt;另外 &lt;code&gt;Carthage&lt;/code&gt; 除了非侵入性，它还是去中心化的，它的包管理不像 &lt;code&gt;CocoaPods&lt;/code&gt; 那样，有一个中心服务器(&lt;a href=&quot;http://cocoapods.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;cocoapods.org&lt;/a&gt;)，来管理各个包的元信息，而是依赖于每个第三方库自己的源地址，比如 Github。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="iOS" scheme="https://qiwihui.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>年度总结 - 2018年全年复盘</title>
    <link href="https://qiwihui.com/qiwihui-blog-43/"/>
    <id>https://qiwihui.com/qiwihui-blog-43/</id>
    <published>2018-12-02T09:51:13.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>2019年一月已经过半，本该在年底十二月完成的总结又到现在才开始着笔。2018年发生了很多事，从年初比特币大涨至最高到现在互联网寒冬已至，不断变化的是环境，不变的是每年一次的年终总结。（误）</p><a id="more"></a><h2>技术</h2><p>做为一个程序员，在保持自己技术水平同时，应当不断地学习，总结和思考新的技术，才能在这个行业不至于被淘汰。互联网寒冬来临之时，对于还不能掌握形式的我也只能先增强自身能力以期减少这个寒冬带来影响。</p><h3>机器学习和深度学习</h3><p>从2017年年底开始涉足机器学习深度学习，先是学习然后在工作项目中实践，至今一年有余。机器学习和深度学习从吴恩达的<a href="https://www.coursera.org/learn/machine-learning" target="_blank" rel="noopener">《机器学习》</a>和<a href="https://www.coursera.org/specializations/deep-learning" target="_blank" rel="noopener">《深度学习》</a>课程开始，吴恩达的课程简洁易懂，逻辑清楚，虽然都是英文，但也没有太大关系。不过这两个课程注重算法胡实现，缺少项目，因此可以需要 <a href="http://fast.ai" target="_blank" rel="noopener">fast.ai</a> 的<a href="https://course.fast.ai/ml.html" target="_blank" rel="noopener">机器学习</a>和<a href="https://course.fast.ai/start.html" target="_blank" rel="noopener">深度学习课程</a>来巩固掌握。主要使用的框架是 <code>Scikit-learn</code>，<code>Keras</code> 和 <code>Tensorflow</code>，这三个掌握不足。之后在公司安全项目中使用了一些分析和算法，对于机器学习和深度学习的理解和应用也只能说是皮毛。</p><h3>Python和Go</h3><ul><li>Python语法巩固；</li><li>Go语言熟悉了基本语法，能阅读代码，会简单编写；</li><li>入门Rust。</li></ul><h3>iOS 开发</h3><p>年初（2017年末）答应给朋友的电影推荐网站写一个 iOS App，结果朋友的站倒闭了也还没有开始。下定决心花了一个多月学习 《Beginning iOS 11 Programming With Swift 4.1》和练习，然后开始做一个基于机器学习的垃圾短信过滤App <a href="https://github.com/qiwihui/SMSFilters" target="_blank" rel="noopener">SMSFilters</a>，功能模仿熊猫吃短信。刚开始就是一行代码写一天，一个Bug改一周，软件开发这种事情就是要不断实践才能对所学的知识掌握。</p><p>SMSFilters 使用 Jieba 分词处理短信，然后用词袋模型提取特征，最后用 LinearSVC 训练，写 SMSFilters 遇到的第一个难题就是集成调用 CppJieba，没有经验，只能查文档，查StackOverflow，经过两周尝试，终于解决，过程可以参见 Demo 项目 <a href="https://github.com/qiwihui/SwiftJiebaDemo" target="_blank" rel="noopener">SwiftJiebaDemo</a> 和博文<a href="https://blog.qiwihui.com/qiwihui-blog-45/" target="_blank" rel="noopener">在iOS-Swift项目中集成CppJieba分词</a>。目前项目进展至使用模型进行垃圾短信判断。</p><h3>开源和社区</h3><p>9月底请假去上海参加了今年的 Google 中国开发者大会，Google 是一家伟大公司，也是一家令人向往的公司.。Google 对于技术的追求也是有目共睹的。虽然 Google 重返中国进程一直很艰难，但不妨碍其技术传播。此次参加开发者大会让我体会最深的是 Google 对于技术的追求，以及用技术改变世界的理想。Google 分享的技术涉及 AI，Tensorflow，Android，Firebase，Flutter 以及 AR/VR 等，在用技术改变世界。</p><h3>博客和资讯</h3><p>日常的咨询获取基本靠自订阅的 RSS，以及自己搭建的 RSSHub 和使用 <a href="http://feed43.com" target="_blank" rel="noopener">feed43.com</a> 做的 feed，但是对于微信公众号，自从微广场停止之后，一直没有很好的获取工具。去年的博客数量更新很少，而且质量也不高，都是一些 “How to” 文，以及只写了大纲的几篇文章。</p><h3>任务管理</h3><p>9月看到 limboys 用 Trello 管理和记录日常的 <a href="https://trello.com/b/0LQ3Dyjg/limboys-life" target="_blank" rel="noopener">Board</a>，很有条理，便开始使用 Trello 管理和记录包括看书，电影电视，以及项目，目前公开了两个 Board：<a href="https://trello.com/b/T4epspk2/qiwihuis-life" target="_blank" rel="noopener">Qiwihui’s Life</a> 和 <a href="https://trello.com/b/fZ2i0xjA/%E6%8A%80%E6%9C%AF%E5%92%8C%E6%80%9D%E8%80%83" target="_blank" rel="noopener">技术和思考</a>。Trello 的体验轻便，方便梳理，是迄今用过的最舒服的项目管理工具。</p><h3>其他</h3><ol><li>Chrome扩展：Octo Previewer</li></ol><p>Fork并修改了一个 Chrome 扩展：<a href="https://chrome.google.com/webstore/detail/octo-previewer/bcgmcibilpjbffkbloafpiekljnaacpo" target="_blank" rel="noopener">Octo Previewer</a>，用来实时预览 Github 上的 PRs，Issues，Gists 的 Markdown 评论。</p><ol start="2"><li>在macOS上基于docker构建透明代理</li></ol><p>Trello <a href="https://trello.com/c/Qw446FEY" target="_blank" rel="noopener">卡片</a> 上记录这个过程。理论上是可行的，只是在有些工具上卡住了前进的路线。</p><ol start="3"><li>hiwifi-ss 项目</li></ol><p>这个基于极路由的翻墙项目没有持续维护，一则自己对于 lua 和 前端不熟悉，开发起来困难，二则我自己的极路由在搬家之后就没有了，再者极路由似乎大势已去，所以这个项目基本也就三四个月更新一次。这个项目给我带来的最大感触就是维护开源项目真的不容易。前些天看到 kalasoo 的文章<a href="https://juejin.im/post/5c21a3ea5188254eaa5c4486" target="_blank" rel="noopener">《开源即责任》</a>也是有感触。</p><h2>读书</h2><p>2018年上半年忙与机器学习和项目，几乎没有读什么书，下半年（9月）开始入坑科幻小说。《三体》是一部好的科幻小说，但在国内《三体》造就的伪科幻迷群体以及随之而来的各种各种视为真理的概念着实令人难受，于是入坑科幻洗洗脑。科幻类基本都是名篇，看过之后，对于《三体》所带来的震撼减轻了不少，但是我更加佩服大刘了。</p><p><img src="https://user-images.githubusercontent.com/3297411/51372377-09ea9d80-1b38-11e9-921e-d59c4be63552.png" alt="books"></p><h3>技术类</h3><ul><li><strong>《Node入门》</strong>：一本入门 node 的不错的简单<a href="https://www.nodebeginner.org/index-zh-cn.html" target="_blank" rel="noopener">教程</a>。</li><li><strong>《Beginning iOS 11 Programming With Swift 4.1》</strong>：出自 Appcoda 的 iOS 开发入门教程，対初学者十分友好，详细介绍了开发一个 App 所需要的各个细节。</li><li><a href="https://legacy.gitbook.com/book/qiwihui/python-data-structure-cn/details" target="_blank" rel="noopener">《python-data-structure-cn》</a>：Python数据结构简单介绍和实践，主要边帮着校对边读了。</li><li><a href="https://legacy.gitbook.com/book/qiwihui/sketch-tutorial-for-ios-developers" target="_blank" rel="noopener">《给iOS开发者的Sketch入门教程》</a>：做图标。</li></ul><h3>科幻类</h3><ul><li><strong>《海伯利安》及《海伯利安的陨落》</strong>，丹·西蒙斯：太空歌剧，感叹于作者对七个朝圣者故事的精彩讲述，以及挖坑。</li><li><strong>《软件体的生命周期》</strong>，姜峯楠：一开始还以为是计算机的书，姜峯楠的中短篇非常有料，和之前看过的《你一生的故事》短篇集同样精彩。</li><li>《银河帝国》基地三部曲，包括 <strong>《基地》</strong>、<strong>《基地与帝国》</strong>、<strong>《第二基地》</strong>，艾萨克·阿西莫夫：经典中经典。</li><li>《银河帝国》机器人系列，包括 <strong>《我，机器人》</strong>、《钢穴》、《裸阳》、《曙光中的机器人》、《机器人与帝国》，艾萨克·阿西莫夫：对于机器人三大法则，作者一步步进行“推翻”补充的过程。</li><li>《平面国——及正方形的多维世界历险记》，埃德温·A·艾勃特：你如何看待二维世界，以及四维世界如何看你。</li><li>《童年的终结》，阿瑟·克拉克：“大规摸养猪场技术”，包括安抚，推荐。</li><li><strong>《与拉玛相会》</strong>，阿瑟·克拉克：小说对于 Rama 飞船的探索写的很详尽，以至于最后离开飞船后飞船的行动让我大气不敢出。</li></ul><h3>数学类</h3><ul><li>《从一到无穷大：科学中的事实和臆测》：科普，讲的东西很多，第一章是数论，第二章是相对论，第三章是微观世界，第四章是宏观世界，对于我无太多感想，必竟很多都知道了，感觉又看了一遍高中书。</li><li><strong>《素数之恋—黎曼和数学中最大的未解之迷》</strong>：理论和计算结合。</li><li><strong>《Riemann 猜想漫谈》</strong>：通俗易懂。</li></ul><p>关于素数的两本书，主要是因为菲尔兹奖与阿贝尔奖双料得主迈克尔·阿蒂亚爵士讲述他对黎曼猜想的证明，这次事件间引起了我详细了解黎曼猜想的兴趣，为此还专门购买了经典教材<a href="https://book.douban.com/subject/1707161/" target="_blank" rel="noopener">《复变函数论方法》</a>，期待进一步了解。这两本书适合一起看，互相补充。不幸的是，迈克尔·阿蒂亚爵士，于 2019 年 1 月 11 日上午逝世，享年八十九岁。他最后的尝试，令人佩服！</p><blockquote><p>「我一直在尝试理解事物运行的原因。我对不能理解背后原理的公式不感兴趣。我总是试图挖掘事物背后的原理，所以如果我有一个公式，我就会去理解它为什么是这样。理解是一个非常困难的概念。人们认为数学的开始是你写下一个定理并附带证明。这不是开始，这是结束。对我来说，数学的创造性在你动手在纸上写字之前，在你尝试写公式之前。你描绘不同的事物，在脑海中反复思考。你尝试的创造，就像音乐家试图创作音乐，或诗人写诗一样。这个过程没有可以遵循的规律，你必须找到自己的方法。但到了最后，就像作曲家必须写下乐谱一样，你必须把它写下来。但最重要的一步是理解。证明公式本身可能不能让你理解。你可能有一个很长的证明，但到最后却不知道它为何是这样。但为了理解，你必须找到类似于直觉的能力，你必须感受它。」</p><p>——迈克尔·阿蒂亚爵士</p></blockquote><h3>其他类</h3><ul><li>《黑客（计算机革命的英雄）》：家酿计算机俱乐部以及上古黑客的事迹，看完这个可以看看 <strong>《黑镜：潘达斯奈基》</strong>，可以看到许多影子。</li><li>《此间的少年》，江南：之前没看完补上的。</li></ul><p>今年看的非技术书基本都是在上下班坐着公交看的，积少成多，也就多了。今年的体会就是读书如抽丝。多读书涨见识。</p><h2>电影、电视剧</h2><p>平常看电影电视有时候喜欢写着代码，可能也不太记得太多，讲讲喜欢的吧。</p><p><img src="https://user-images.githubusercontent.com/3297411/51374373-c5620080-1b3d-11e9-8be9-45074f4f2954.png" alt="movies"></p><ul><li>《碟中碟6：全面瓦解》：阿汤哥不老开挂。</li><li>《dele ディーリー 人生删除事务所》：其实不喜欢，以删除人生的名义偷窥以至修改别人的人生。</li><li><strong>《知无涯者 The Man Who Knew Infinity》</strong>：印度小哥开启挂来连哈代都服。</li><li><strong>《超级科学伙伴》</strong>：和一群点了“超人”技能树的科学家一起拯救世界是一种怎样的体验。</li><li><strong>《我的三体》</strong>（第一季，第二季）：《我的世界》+《三体》简直不要太开心，可能是唯一的视频画面质量以可见的速度在变化的动画。</li><li>《神奇动物：格林德沃之罪》：挖坑之作，“英特纳雄耐尔，就一定要实现！”。</li><li><strong>《神秘博士》</strong>（第十一季）：换了编剧之后十三姨没有自己的特点，期待圣诞之后的几集能好转。</li><li>《邪不压正》：如果那个北京城是真的。</li><li>《世界奇妙物语 2018年春季特别篇》：意外好看一些。</li><li><strong>《辛普森一家》</strong>（第三十季）：小黄人一家的故事。</li><li><strong>《孤独的美食家》</strong>（第七季）：“凭谁问，廉颇老矣，尚能饭否？”</li><li><strong>《深夜食堂》</strong>（第三季）：看的不是菜，是人间百味。</li></ul><h2>游戏</h2><p>年初买了 Nitendo Switch，不过没有太多时间花在玩游戏上，以至于《塞尔达传说：荒野之息》和《超级马里奥：奥德赛》都没有通关，只是偶尔用来玩玩 AoV，不过 NS 的体验确实非常不错，不论是个人还是联机，值得推荐。个人觉得游戏在于娱乐放松，若影响正常工作和情绪则视为不可，曾记得大学玩游戏还冲别人发过脾气也是太年轻。</p><h3>《王者荣耀》 和 《Arena of Valor》</h3><p>我在王者荣耀S13赛季又重新玩了一段时间，每天三五局，升个一星两星就停止，掉个一星两星也停止，就这样达到了个人历史最好成绩，不过这个过程给我带来的影响也不少。一个是我发现在白天的队友比较坑，而到了夜晚会好很多，估计是小学生都去睡觉了，所以我每到十一二点就开始玩，有时会因为连胜而玩到很晚，以致停止一段时间之后仍不能好好早睡，严重影响精神状态；二是一局结束又开一局，犹如赌博，赢则更想赢，输则不服气，往往计较于一城得失，实在是影响心气。这个游戏不能投入太多时间。</p><h3>《塞尔达传说：荒野之息》 和 《超级马里奥：奥德赛》</h3><p><img src="https://user-images.githubusercontent.com/3297411/51376783-24c30f00-1b44-11e9-9991-97de85cf9fc2.jpeg" alt="zelda"></p><p>很不错的游戏，只是都还没有玩通关，需要补上。</p><h3>《旅行青蛙》</h3><p>就和养儿子一样（虽然作者说的是丈夫），总是担心种种，吃没吃好，有没有被雨淋，有没有被欺负，路上还有钱吗。这就是为人父母的体验吧。</p><h3>吃鸡</h3><p>接触不多，不过和《王者荣耀》这种是一样的感受。看过一些游戏主播的视频，佩服一个LOL职业玩家转吃鸡的主播，在战场上沉稳，有判断。</p><h3>Ingress</h3><p>已经弃坑了，一则是因为满级了，并没有刷成就的习惯，同时也因为没有太多时间出门，二则官方一直没有太多的积极活动，每次就是换一个地方刷牌子，再则在手机升级到 iOS 11 之后，官方推出了 Ingress Prime，游戏体验万分糟糕，之前的版本却不升级，遂弃。Ingress玩了四五年，也疯狂过，但是还是离开吧。</p><h2>生活</h2><ol><li>婚姻</li></ol><p>今年一大事就是和老婆领证了，还没有办酒席，两人都商量着简办，请亲戚吃个饭就感觉已经很隆重了。参加了几次同学的婚礼，无非接亲，闹新郎，宣个誓言，在众亲友面前挥泪感恩，对于这样重复的婚礼，也没有太大的兴趣。梦想人生的婚礼应当刺激，可以在远山，或者，招待一群好友，准备一堆食物，准备一段给大家的表演，大家也可以上台表演，发表自己的感想。</p><ol start="2"><li>旅行</li></ol><ul><li>7月在云台山，看大山，打水战，舒畅。</li><li>9月青龙峡，人生第一次蹦极，刺激。</li><li>10月湖南长沙，看橘子洲头，品长沙臭豆腐，一般。</li></ul><ol start="3"><li>养猫</li></ol><p><img src="https://user-images.githubusercontent.com/3297411/51398607-fdd5fe80-1b7e-11e9-901d-beeb45277005.jpg" alt="cat"></p><p>11月，迎来家庭另一个成员，一只英国短毛蓝猫，取名“狗狗”。虽然有时会觉得这和取狗蛋差不多，也不知道会不会让其他猫看不起。第一次养猫，总是担心这担心那，生怕他生病了，像极了父母。久了我也发现他还是很粘人的，不知道年后给他找了女朋友之后会不会还是这么粘人。</p><ol start="4"><li>关于亲戚和钱</li></ol><p>十月，堂弟找我借钱周转，并承诺四天还，鉴于有承诺而且是亲戚，也就爽快借了。第一次到期没任何动静，还钱还是再接着一句话也没说，我问了才换来一句“明天，明天一定换”，接着第二次就是“最迟不会超过后天下午”，然后是到期还了一半，我没收，要全款，就继续拖着，一星期没动静，问了几句就变成在外地学习没开手机，“明天下午三点之前”，然后“再给一个小时”，“我手机没电了”。最后钱是还了，但是我对他的信任一点都没有了，直接拉黑！这件事让伙我认识到一点：在钱面前，亲戚的嘴脸也是令人恶心的。我借钱是因为我信任，却不代表你可以践踏。想起一个村民中奖却被村里人借得倾家荡产，村里人却觉得他有钱为什么就不能借点，可怕。</p><h2>展望2019</h2><p>绝不是flag。</p><ol start="0"><li>做一份关于Python的知识小集，不求多，但求记录下一些易错，有深度的小知识点。同时过一遍Python的参考文档，阅读一些框架源码。</li><li>维护现有开源翻墙项目。</li><li>每两周至少一篇博客，记录的内容不能太基础，需要有思考。</li><li>深入了解计算机基础，包括系统原理、数据结构和算法、网络基础和编译原理，这四个方面每一个都阅读一本书籍，理解并掌握常用内容。</li><li>在leetcode上刷50题。</li><li>机器学习：学完fast.ai的机器学习课程。</li><li>深度学习：学习fast.ai的深度学习课程，对应同步阅读花书。</li><li>减少游戏时间，不在十一点以后玩游戏。</li><li>学会五笔打字，速度至少能达到60字/分钟。</li><li>在App store上至少上架一个App。</li><li>了解投资相关内容。</li></ol><h2>写在最后</h2><p>人生需要有目标，需要一个积极乐观的心态，和一群志同道合的同伴。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019年一月已经过半，本该在年底十二月完成的总结又到现在才开始着笔。2018年发生了很多事，从年初比特币大涨至最高到现在互联网寒冬已至，不断变化的是环境，不变的是每年一次的年终总结。（误）&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="https://qiwihui.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="总结" scheme="https://qiwihui.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Making kernels for jupyter</title>
    <link href="https://qiwihui.com/qiwihui-blog-40/"/>
    <id>https://qiwihui.com/qiwihui-blog-40/</id>
    <published>2018-10-25T00:18:06.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>一个内核是运行和解析用户代码的程序。IPython包含了一个运行和解析Python代码的内核，而且人们已经写了多种语言的内核。</p><p>当Jupyter开始一个内核的时候，它会传递它一个连接文件。它指定了如何与前端开始通信。</p><a id="more"></a><p>以下是实践：</p><h3>安装环境</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda create -n py365400 python=3.6.5 jupyter ipykernel</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conda activate py365</span></span><br></pre></td></tr></table></figure><h3>列出当前内核</h3><p>在Unix系统中，可用的内核列在如下文件夹中（<a href="https://jupyter-client.readthedocs.io/en/latest/kernels.html#kernel-specs" target="_blank" rel="noopener">Kernel specs</a>）:</p><p>System:</p><ul><li><code>/usr/share/jupyter/kernels</code></li><li><code>/usr/local/share/jupyter/kernels</code></li></ul><p>Env:</p><ul><li><code>{sys.prefix}/share/jupyter/kernels</code></li></ul><p>User:</p><ul><li><code>~/.local/share/jupyter/kernels (Linux)</code></li><li><code>~/Library/Jupyter/kernels (Mac)</code></li></ul><p>用户位置的优先级高于系统级别的，忽略名字的大小写。因此不论系统是否大小写敏感，都可以以同样的烦噶事来获取内核。因为内核名字会在URL出现，因此内核名字需要是一个简单的，只使用ASCII字母，数字和简单的分隔符<code>-</code>，<code>.</code>， <code>_</code>。如果设置了 <code>JUPYTER_PATH</code> 环境变量的话，也会搜索其他位置。</p><p>例如在我的Mac上，有两个个内核，一个是 python 3 的，另一个是 pyspark(python 2) 的。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">  jupyter kernelspec list</span></span><br><span class="line">Available kernels:</span><br><span class="line">  pyspark2    /Users/qiwihui/Library/Jupyter/kernels/pyspark2</span><br><span class="line">  python3     /usr/local/miniconda3/envs/py365/share/jupyter/kernels/python3</span><br></pre></td></tr></table></figure><p>在内核文件夹下，现在会使用三种类型的文件。<code>kernel.json</code>, <code>kernel.js</code>和log图片文件。目前，没有使用其他文件，但是将来可能会改变。</p><p>最重要的文件是 <code>kernel.json</code>，应该是一个json序列化的字典包含以下字段</p><ul><li><code>argv</code>: 用来启动内核的命令行参数列表。<code>{connection_file}</code> 将会被实际的连接文件的路径替换。</li><li><code>display_name</code>: 在UI上展示的内核名字。不像在API中使用的内核名字，这里的名字可以包含任意字符。</li><li><code>language</code>: 内核的语言名字。当载入notebook的时候，如果没有找到匹配的内核，那么匹配相应语言的内核将会被启动。这样允许一个写了任何Python或者julia内核的notebook可以与用户的Python或者julia内核合适的联系起来，即使它们没有在与用户内核同样的名字下。</li><li><code>interrupt_mode</code>：可能是signal或者message指定了客户端如何在这个内核中停止单元运行。是通过发送一个信号呢，还是发送一个<code>interrupt_request</code>消息在<code>control channel</code>。如果没有指定，将默认使用signal模式。</li><li><code>env</code>：为内核设置的环境变量。在内核启动前，会添加到当前的环境变量里。</li><li><code>metadata</code>：关于这个内核的其他相关属性。帮助客户端选择内核。</li></ul><p>比如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /usr/<span class="built_in">local</span>/miniconda3/envs/py365/share/jupyter/kernels/python3/kernel.json </span></span><br><span class="line">&#123;</span><br><span class="line"> "argv": [</span><br><span class="line">  "/usr/local/miniconda3/envs/py365/bin/python",</span><br><span class="line">  "-m",</span><br><span class="line">  "ipykernel_launcher",</span><br><span class="line">  "-f",</span><br><span class="line">  "&#123;connection_file&#125;"</span><br><span class="line"> ],</span><br><span class="line"> "display_name": "Python 3",</span><br><span class="line"> "language": "python"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当内核开始的时候将会传入一个连接文件的路径，这个文件只对当前用户可用，会包含类似下面的一个JSON字典。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"control_port"</span>: <span class="number">50160</span>,</span><br><span class="line">  <span class="attr">"shell_port"</span>: <span class="number">57503</span>,</span><br><span class="line">  <span class="attr">"transport"</span>: <span class="string">"tcp"</span>,</span><br><span class="line">  <span class="attr">"signature_scheme"</span>: <span class="string">"hmac-sha256"</span>,</span><br><span class="line">  <span class="attr">"stdin_port"</span>: <span class="number">52597</span>,</span><br><span class="line">  <span class="attr">"hb_port"</span>: <span class="number">42540</span>,</span><br><span class="line">  <span class="attr">"ip"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">  <span class="attr">"iopub_port"</span>: <span class="number">40885</span>,</span><br><span class="line">  <span class="attr">"key"</span>: <span class="string">"a0436f6c-1916-498b-8eb9-e81ab9368e84"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>transport</code>, <code>ip</code> 和设定了该使用 ZeroMQ 绑定的五个_port。比如 shell 套接字的地址应该是：<code>tcp://127.0.0.1:57503</code>。在每个内核开始的时候会指定随意的端口。<code>signature_scheme</code> 和 <code>key</code> 用来加密信息，因此系统的其他用户不能发送代码来运行内核。</p><p>现在我需要自己定义一个内核，这个内核可以执行我们定义的逻辑。</p><h3>添加新内核</h3><p>这是简单的重用 IPython  的内核机制来实现这个新的内核。</p><p>步骤：</p><p>子类化ipykernel.kernelbase.Kernel，然后实现下面的方法和属性</p><p>class MyKernel</p><pre><code>- implementation- implementation_version- banner    Kernel info会返回的信息。Implementation指的是内核而不是语言，比如IPython而不是Python。banner是在控制UI上显示第一个提示符之前的东西。这些都是字符串- language_info    Kernel info会返回的信息字典。应该包含mimetype键，值是目标语言的mimetype，比如text/x-python。name键是实现的语言比如python，file_extension比如.py，而且也可能根据不同语言包含codemirror_mode和pygments_lexer- do_execute(code, silent, store_history=True, user_expressions=None, allow_stdin=False)    执行用户代码        - code：要执行的代码        - silent：是否展示输出        - store_history: 是否在历史里记录代码，并且增加执行次数。        - user_expressions：在代码被执行后对这些表达式求值        - allow_stdin：前端是否提供输入请求    你的方法应该返回一个字典，包含在Execution results规定的字典。为了展现输出，它可以使用send_response() 来发送消息。</code></pre><p>为了启动你的内核，在模块后面加上：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">from</span> ipykernel.kernelapp <span class="keyword">import</span> IPKernelApp</span><br><span class="line">    IPKernelApp.launch_instance(kernel_class=MyKernel)</span><br></pre></td></tr></table></figure><p>现在创建一个JSON的内核说明文件，然后通过 <code>jupyter kernelspec install &lt;/path/to/kernel&gt;</code>。将你的内核模块放在Python可以导入的地方，一般是当前目录(做测试)。最后，你可以使用 <code>jupyter console --kernel &lt;mykernelname&gt;</code> 来运行你的内核。</p><p>例子：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls <span class="built_in">echo</span>/</span></span><br><span class="line">echokernel.py kernel.json</span><br></pre></td></tr></table></figure><p><code>echokernel.py</code>:</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ipykernel.kernelbase <span class="keyword">import</span> Kernel</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoKernel</span><span class="params">(Kernel)</span>:</span></span><br><span class="line">    implementation = <span class="string">'Echo'</span></span><br><span class="line">    implementation_version = <span class="string">'1.0'</span></span><br><span class="line">    language = <span class="string">'no-op'</span></span><br><span class="line">    language_version = <span class="string">'0.1'</span></span><br><span class="line">    language_info = &#123;</span><br><span class="line">        <span class="string">'name'</span>: <span class="string">'Any text'</span>,</span><br><span class="line">        <span class="string">'mimetype'</span>: <span class="string">'text/plain'</span>,</span><br><span class="line">        <span class="string">'file_extension'</span>: <span class="string">'.txt'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    banner = <span class="string">"Echo kernel - as useful as a parrot"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_execute</span><span class="params">(self, code, silent, store_history=True, user_expressions=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                   allow_stdin=False)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> silent:</span><br><span class="line">            stream_content = &#123;<span class="string">'name'</span>: <span class="string">'stdout'</span>, <span class="string">'text'</span>: code&#125;</span><br><span class="line">            self.send_response(self.iopub_socket, <span class="string">'stream'</span>, stream_content)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'status'</span>: <span class="string">'ok'</span>,</span><br><span class="line">                <span class="comment"># The base class increments the execution count</span></span><br><span class="line">                <span class="string">'execution_count'</span>: self.execution_count,</span><br><span class="line">                <span class="string">'payload'</span>: [],</span><br><span class="line">                <span class="string">'user_expressions'</span>: &#123;&#125;,</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">from</span> ipykernel.kernelapp <span class="keyword">import</span> IPKernelApp</span><br><span class="line">    IPKernelApp.launch_instance(kernel_class=EchoKernel)</span><br></pre></td></tr></table></figure><p><code>kernel.json</code>:</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"argv"</span>:[<span class="string">"python"</span>,<span class="string">"-m"</span>,<span class="string">"echokernel"</span>, <span class="string">"-f"</span>, <span class="string">"&#123;connection_file&#125;"</span>],</span><br><span class="line">    <span class="attr">"display_name"</span>:<span class="string">"Echo"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安装</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ jupyter kernelspec install echo --user</span><br></pre></td></tr></table></figure><p>这里，只为当前用户添加这个kernel。</p><h3>查看</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jupyter notebook</span></span><br></pre></td></tr></table></figure><p>选择新创建的内核创建 notebook，并运行代码。</p><p><img src="https://user-images.githubusercontent.com/3297411/47489844-1bdedc00-d87a-11e8-8294-3c412fbcdb52.png" alt="jupyter with new kernel echo"></p><p><img src="https://user-images.githubusercontent.com/3297411/47490179-bf2ff100-d87a-11e8-85b3-3469efa7edc2.png" alt="image"></p><h3>一些坑</h3><ol><li>运行 notebook 时无法找到 <code>echokernel</code> 模块：</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[I 15:48:27.754 NotebookApp] Kernel started: 77759cfa-db55-4b70-be23-c14d69f8d87d</span><br><span class="line">/usr/local/miniconda3/envs/py365/bin/python: No module named echokernel</span><br><span class="line">[I 15:48:30.750 NotebookApp] KernelRestarter: restarting kernel (1/5), new random ports</span><br><span class="line">/usr/local/miniconda3/envs/py365/bin/python: No module named echokernel</span><br><span class="line">[I 15:48:33.766 NotebookApp] KernelRestarter: restarting kernel (2/5), new random ports</span><br><span class="line">/usr/local/miniconda3/envs/py365/bin/python: No module named echokernel</span><br><span class="line">[I 15:48:36.789 NotebookApp] KernelRestarter: restarting kernel (3/5), new random ports</span><br><span class="line">/usr/local/miniconda3/envs/py365/bin/python: No module named echokernel</span><br><span class="line">[I 15:48:39.812 NotebookApp] KernelRestarter: restarting kernel (4/5), new random ports</span><br><span class="line">/usr/local/miniconda3/envs/py365/bin/python: No module named echokernel</span><br></pre></td></tr></table></figure><p>需要将 <code>echokernel.py</code> 放置在 python PATH 中 ，这样在执行命令时才能访问到。</p><h3>更多命令</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ jupyter kernelspec <span class="built_in">help</span></span><br><span class="line">Manage Jupyter kernel specifications.</span><br><span class="line"></span><br><span class="line">Subcommands</span><br><span class="line">-----------</span><br><span class="line"></span><br><span class="line">Subcommands are launched as `jupyter kernelspec cmd [args]`. For information on</span><br><span class="line">using subcommand <span class="string">'cmd'</span>, <span class="keyword">do</span>: `jupyter kernelspec cmd -h`.</span><br><span class="line"></span><br><span class="line">list</span><br><span class="line">    List installed kernel specifications.</span><br><span class="line">install</span><br><span class="line">    Install a kernel specification directory.</span><br><span class="line">uninstall</span><br><span class="line">    Alias <span class="keyword">for</span> remove</span><br><span class="line">remove</span><br><span class="line">    Remove one or more Jupyter kernelspecs by name.</span><br><span class="line">install-self</span><br><span class="line">    [DEPRECATED] Install the IPython kernel spec directory <span class="keyword">for</span> this Python.</span><br><span class="line"></span><br><span class="line">To see all available configurables, use `--<span class="built_in">help</span>-all`</span><br></pre></td></tr></table></figure><h3>删除内核</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jupyter kernelspec uninstall <span class="built_in">echo</span></span></span><br></pre></td></tr></table></figure><h3>参考</h3><ul><li><a href="https://jupyter-client.readthedocs.io/en/stable/wrapperkernels.html" target="_blank" rel="noopener">Making simple Python wrapper kernels</a></li><li><a href="http://landcareweb.com/questions/879/ru-he-jiang-python3nei-he-tian-jia-dao-jupyter-ipython" target="_blank" rel="noopener">题 如何将python3内核添加到jupyter（IPython）</a></li><li><a href="https://skyrover.me/2017/12/07/making_kernels_for_jupyter/" target="_blank" rel="noopener">翻译 - Making kernels for Jupyter</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个内核是运行和解析用户代码的程序。IPython包含了一个运行和解析Python代码的内核，而且人们已经写了多种语言的内核。&lt;/p&gt;
&lt;p&gt;当Jupyter开始一个内核的时候，它会传递它一个连接文件。它指定了如何与前端开始通信。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch cheat sheet</title>
    <link href="https://qiwihui.com/qiwihui-blog-39/"/>
    <id>https://qiwihui.com/qiwihui-blog-39/</id>
    <published>2018-10-14T18:25:20.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<h3>1</h3><p><code>curl -X&lt;REST Verb&gt; &lt;Node&gt;:&lt;Port&gt;/&lt;Index&gt;/&lt;Type&gt;/&lt;ID&gt;</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -XPOST &apos;localhost:9200/bank/_search?pretty&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;,</span><br><span class="line">  &quot;_source&quot;: [&quot;account_number&quot;, &quot;balance&quot;],</span><br><span class="line">  &quot;sort&quot;: &#123; &quot;balance&quot;: &#123; &quot;order&quot;: &quot;desc&quot; &#125; &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure><p><code>bool must</code>: 所有的查询都必须为真<code>bool should</code>: 只要有一个查询匹配<code>bool must_not</code>: 查询列表中的的所有查询都必须都不为真</p><h3>2. 执行过滤器</h3><p><code>_score</code>: 指定的搜索查询匹配程度的一个相对度量。得分越高，文档越相关，得分越低文档的相关度越低。Elasticsearch中的所有的查询都会触发相关度得分的计算。对于那些我们不需要相关度得分的场景下，Elasticsearch以过滤器的形式提供了另一种查询功能。</p><p>过滤器在概念上类似于查询，但是它们有非常快的执行速度，这种快的执行速度主要有以下两个原因：</p><ul><li>过滤器不会计算相关度的得分，所以它们在计算上更快一些</li><li>过滤器可以被缓存到内存中，这使得在重复的搜索查询上，其要比相应的查询快出许多。</li></ul><p>通常情况下，要决定是使用过滤器还是使用查询，你就需要问自己是否需要相关度得分。如果相关度是不重要的，使用过滤器，否则使用查询。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">'localhost:9200/bank/_search?pretty'</span> -d <span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  "query": &#123;</span></span><br><span class="line"><span class="string">    "filtered": &#123;</span></span><br><span class="line"><span class="string">      "query": &#123; "match_all": &#123;&#125; &#125;,</span></span><br><span class="line"><span class="string">      "filter": &#123;</span></span><br><span class="line"><span class="string">        "range": &#123;</span></span><br><span class="line"><span class="string">          "balance": &#123;</span></span><br><span class="line"><span class="string">            "gte": 20000,</span></span><br><span class="line"><span class="string">            "lte": 30000</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure><h3>3</h3><p>doc[‘my_field’].value和_source.my_field之间的不同:</p><ul><li>首先，使用doc关键字，会使相应的字段加载到内存，执行速度更快但是更耗费内存；</li><li>第二，doc[…]符号 仅允许简单的值字段，只在基于字段的非分析或者单个项上有意义；</li><li>_source加载、分析source，然后仅仅返回相关部分的json。</li></ul><h3>参考</h3><ul><li><a href="https://endymecy.gitbooks.io/elasticsearch-guide-chinese/" target="_blank" rel="noopener">elasticsearch guide chinese</a></li><li><a href="https://gist.github.com/ruanbekker/e8a09604b14f37e8d2f743a87b930f93" target="_blank" rel="noopener">https://gist.github.com/ruanbekker/e8a09604b14f37e8d2f743a87b930f93</a></li><li><a href="https://gist.github.com/stephen-puiszis/212b8a8b37f67c670422" target="_blank" rel="noopener">https://gist.github.com/stephen-puiszis/212b8a8b37f67c670422</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;1&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;curl -X&amp;lt;REST Verb&amp;gt; &amp;lt;Node&amp;gt;:&amp;lt;Port&amp;gt;/&amp;lt;Index&amp;gt;/&amp;lt;Type&amp;gt;/&amp;lt;ID&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highl
      
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>一个关于数学概率的问题</title>
    <link href="https://qiwihui.com/qiwihui-blog-32/"/>
    <id>https://qiwihui.com/qiwihui-blog-32/</id>
    <published>2018-09-09T21:48:11.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<h2>题目–百万英雄</h2><p>你参加一个游戏，在你面前有4张1000万支票，其中一张是真的。游戏开始，你选了一张，之后主持人在剩下的3张里，选择一个展示出来，验证后发现是假的。</p><p>问题：请分情况理性分析，此时，你的参赛权的价格</p><ul><li>情况一：不允许修改之前的选择</li><li>情况二：有重新选择的权利</li></ul><p>回答：请用下面两种方法分别作答</p><ul><li>方式1（理论推导）：请给出理论推导和计算过程，情况二需说明如何行使权力；</li><li>方式2（编程模拟）：使用程序准确客观地模拟上述两种情况下，选手平均获得的奖金，得到参赛权的价格。</li></ul><a id="more"></a><h2>解答</h2><p>方式1（理论推导）</p><p>情况1: 不能重新选择时获奖的概率是1/4情况2: 可以重新选择时是3/8理由：</p><ol><li>不能重新选择时，你的选择不受主持人选择的影响，故为 1/4；</li><li>可以重新选择时，会受主持人的影响，是后验概率；第一步选择时，有四种可选，有 <code>1/4</code> 选择真实的，<code>3/4</code> 选择错误的，主持人的选择在剩下的三个中排除了一个错误的，剩两个。选择真实后重选，再次选中的概率为0，故为 <code>1/4 * 0 = 0</code>；选择假的后重选，选中概率为1/2，故为 <code>3/4 * 1/2 = 3/8</code>；总的选中真的概率为 <code>0 + 3/8 = 3/8</code>。</li></ol><p>方式2（编程模拟）:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hero</span>:</span></span><br><span class="line">    <span class="string">"""英雄</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.num = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        self.num = random.choice(nums)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Host</span>:</span></span><br><span class="line">    <span class="string">"""主持人</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.num = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self, nums, bnum)</span>:</span></span><br><span class="line">        <span class="string">"""主持人</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.num = random.choice(nums)</span><br><span class="line">        <span class="keyword">while</span> bnum == self.num:</span><br><span class="line">            self.num = random.choice(nums)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MH</span>:</span></span><br><span class="line">    <span class="string">"""游戏过程</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.nums = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">        self.host = Host()</span><br><span class="line">        self.hero = Hero()</span><br><span class="line">        self.bnum = random.randint(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reward</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""奖励</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.hero.num == self.bnum:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play_without_regret</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""不允许修改之前的选择</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.hero.pick(self.nums)</span><br><span class="line">        self.nums.remove(self.hero.num)</span><br><span class="line">        self.host.pick(self.nums, self.bnum)</span><br><span class="line">        <span class="keyword">return</span> self.reward()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play_with_regret</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""有重新选择的权利</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.hero.pick(self.nums)</span><br><span class="line">        self.nums.remove(self.hero.num)</span><br><span class="line">        self.host.pick(self.nums, self.bnum)</span><br><span class="line">        self.nums.remove(self.host.num)</span><br><span class="line">        self.hero.pick(self.nums)</span><br><span class="line">        <span class="keyword">return</span> self.reward()</span><br><span class="line"></span><br><span class="line">sum1 = <span class="number">0</span></span><br><span class="line">sum2 = <span class="number">0</span></span><br><span class="line"><span class="comment"># 模拟10000次</span></span><br><span class="line">times = <span class="number">10000</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(times):</span><br><span class="line">    sum1 += MH().play_without_regret()</span><br><span class="line">    sum2 += MH().play_with_regret()</span><br><span class="line">avg1 = sum1/float(times)</span><br><span class="line">avg2 = sum2/float(times)</span><br><span class="line">print(avg1)</span><br><span class="line">print(avg2)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt; python bh.py</span><br><span class="line">24.81</span><br><span class="line">37.12</span><br></pre></td></tr></table></figure><p>与理论计算一致</p><h2>引申</h2><p>三门问题（Monty Hall Problem）电影《决胜21点》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2&gt;题目–百万英雄&lt;/h2&gt;
&lt;p&gt;你参加一个游戏，在你面前有4张1000万支票，其中一张是真的。游戏开始，你选了一张，之后主持人在剩下
的3张里，选择一个展示出来，验证后发现是假的。&lt;/p&gt;
&lt;p&gt;问题：请分情况理性分析，此时，你的参赛权的价格&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况一：不允许修改之前的选择&lt;/li&gt;
&lt;li&gt;情况二：有重新选择的权利&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;回答：请用下面两种方法分别作答&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方式1（理论推导）：请给出理论推导和计算过程，情况二需说明如何行使权力；&lt;/li&gt;
&lt;li&gt;方式2（编程模拟）：使用程序准确客观地模拟上述两种情况下，选手平均获得的奖金，得到参赛权的价格。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="数学" scheme="https://qiwihui.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>使用 Travis CI 自动更新博客</title>
    <link href="https://qiwihui.com/qiwihui-blog-29/"/>
    <id>https://qiwihui.com/qiwihui-blog-29/</id>
    <published>2018-09-09T21:46:36.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>Travis CI 自动检测代码变化，拉取，编译博客并部署到 GitHub Pages</p><p>写好博客之后，部署总会占去一段时间：编译、部署、推送和检查。手动部署多了也就烦了，一则容易出错，比如把 master 分支用 gh-pages 分支覆盖了，二则劳动是重复的，重复的劳动就应该自动化去解决。</p><a id="more"></a><h2>最早的想法</h2><p>使用 GitHub Webhooks 实现自动部署，这就需要有一台服务器，在服务器上启动服务接受 Github 的回调，然后拉取代码，编译，将编译后的代码要么部署在同一台服务器上，要么推送到代码 gh-pages 分支上。前者额外需要编写服务，配置博客 Nginx，可能还需要配置 HTTPS，以及对服务器进行加固，总归就是需要额外的更多东西来支持。所以还是觉得用已经存在的线上自动化服务方便一些（其实就是懒）。</p><h2>Travis CI</h2><p>持续集成（Continuous Integration，CI）的 SaaS 服务，好处不言而喻。</p><h2>配置 Travis</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gem install travis</span><br><span class="line">travis login</span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line"><span class="bullet">-</span> <span class="number">6.9</span><span class="number">.0</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">submodule</span> <span class="string">update</span> <span class="string">--init</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-cli</span> <span class="string">-g</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo</span> <span class="string">generate</span> <span class="string">--deploy</span> <span class="string">--quiet</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">directories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">node_modules</span></span><br><span class="line"><span class="attr">notifications:</span></span><br><span class="line">  <span class="attr">email:</span></span><br><span class="line">    <span class="attr">recipients:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">qwh005007@gmail.com</span></span><br><span class="line">    <span class="attr">on_success:</span> <span class="string">change</span></span><br><span class="line">    <span class="attr">on_failure:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure><h2>使用 Travis 自动部署</h2><p><code>ERROR Deployer not found: git</code></p><p><a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a></p><p><code>npm install hexo-deployer-git --save</code></p><h2>配置认证</h2><p>往 Github 仓库中提交代码是需要认证的，不管是用用户密码，Access Token还是SSH key。一种方法是直接将认证写在 <code>.config.yml</code> 中，不是说不行，是太年轻。好在 Travis CI 不仅支持<a href="https://docs.travis-ci.com/user/encrypting-files/" target="_blank" rel="noopener">加密文件</a>，也支持<a href="https://docs.travis-ci.com/user/encryption-keys/" target="_blank" rel="noopener">加密 Keys</a>，这就为认证这一块扫清了道路，我决定使用 OAuth 认证 Git 来提交代码到仓库中。</p><p>操作步骤：</p><ol><li><p>生成 Github Personal Access Token；</p></li><li><p>使用 Travis CI 命令行加密 Personal Access Token；</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">travis encrypt GH_TOKEN=&lt;token&gt; --add</span><br></pre></td></tr></table></figure></li><li><p>在 <code>.travis.yml</code> 中添加配置</p> <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">before_install:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">push.default</span> <span class="string">matching</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">"qiwihui via Travis CI"</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">"qwh005007@gmail.com"</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">sed</span> <span class="string">-i''</span> <span class="string">"/^ *repo/s~github\.com~$&#123;GH_TOKEN&#125;@github.com~"</span> <span class="string">_config.yml</span></span><br></pre></td></tr></table></figure> <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">secure:</span> <span class="string">IYXTVHItgbEn...</span></span><br></pre></td></tr></table></figure></li></ol><h2>在 Travsi CI 中配置项目</h2><ol><li>Publicizing or hiding organization membership</li></ol><h2>自定义域名</h2><ol><li><a href="http://qiwihui.github.io/qiwihui/" target="_blank" rel="noopener">qiwihui.github.io/qiwihui/</a> =&gt; <a href="http://blog.qiwihui.com" target="_blank" rel="noopener">blog.qiwihui.com</a></li><li>Enforce https</li></ol><p>胜利完成!</p><h2>参考</h2><ul><li><a href="https://notes.iissnan.com/2016/publishing-github-pages-with-travis-ci/" target="_blank" rel="noopener">使用 Travis CI 自动更新 GitHub Pages</a></li><li><a href="http://lotabout.me/2016/Hexo-Auto-Deploy-to-Github/" target="_blank" rel="noopener">Hexo 自动部署到 Github</a></li><li><a href="https://blog.github.com/2012-09-21-easier-builds-and-deployments-using-git-over-https-and-oauth/" target="_blank" rel="noopener">Easier builds and deployments using Git over HTTPS and OAuth</a></li><li><a href="https://help.github.com/articles/publicizing-or-hiding-organization-membership/" target="_blank" rel="noopener">Publicizing or hiding organization membership</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Travis CI 自动检测代码变化，拉取，编译博客并部署到 GitHub Pages&lt;/p&gt;
&lt;p&gt;写好博客之后，部署总会占去一段时间：编译、部署、推送和检查。手动部署多了也就烦了，一则容易出错，
比如把 master 分支用 gh-pages 分支覆盖了，二则劳动是重复的，重复的劳动就应该自动化去解决。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>用Homebrew 安装 v2ray 以及 Homebrew-cask 安装 V2RayX</title>
    <link href="https://qiwihui.com/qiwihui-blog-27/"/>
    <id>https://qiwihui.com/qiwihui-blog-27/</id>
    <published>2018-09-09T21:45:00.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>最近开始转向使用 v2ray 作为主要的翻墙工具，在 macOS 上安装和使用都需要下载编译好的软件包然后解包使用，不是很方便，联系到 macOS 下常用的包管理 Homebrew，何不自己提交一个？</p><a id="more"></a><h3>v2ray及V2RayX是啥？</h3><blockquote><p>V2Ray 是一个模块化的代理软件包，它的目标是提供常用的代理软件模块，简化网络代理软件的开发。</p></blockquote><p>简单说 <a href="https://github.com/v2ray/v2ray-core" target="_blank" rel="noopener">v2ray</a> 就是翻墙代理软件（但不止于软件，是一个平台）。<a href="https://github.com/Cenmrev/V2RayX" target="_blank" rel="noopener">V2RayX</a> 就是 macOS 下一个简单的 v2ray 的GUI程序。</p><h3>Homebrew呢？</h3><p>macOS上强大的包管理工具，类似于Ubuntu的apt。</p><p>安装：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/bin/ruby -e <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br></pre></td></tr></table></figure><p>使用，比如下载 <code>curl</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install curl</span><br></pre></td></tr></table></figure><h3>安装v2ray</h3><p>不知道为啥，官方的Homebrew Formula不接受 v2ray 源，所以只能自己写了，见 <a href="https://github.com/qiwihui/homebrew-v2ray" target="_blank" rel="noopener">qiwihui/homebrew-v2ray</a>。</p><p>安装：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew tap qiwihui/v2ray</span><br><span class="line">brew install v2ray-core</span><br></pre></td></tr></table></figure><p>使用：</p><p>首先，需要配置 <code>/usr/local/etc//v2ray.config.json</code>；其次，配置v2ray登录时自动开启：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew services start v2ray-core</span><br></pre></td></tr></table></figure><p>或者，可以手动运行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">v2ray -config=/usr/<span class="built_in">local</span>/etc//v2ray.config.json</span><br></pre></td></tr></table></figure><h3>安装V2RayX</h3><p>我向官方 <a href="https://caskroom.github.io/" target="_blank" rel="noopener">Homebrew-Cask</a> 提交了一个Formula，可以直接使用如下命令安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew cask install v2rayx</span><br></pre></td></tr></table></figure><p>不过GUI毕竟不能覆盖命令行的全部功能，所以能用命令行v2ray的话，就尽量不使用V2RayX吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近开始转向使用 v2ray 作为主要的翻墙工具，在 macOS 上安装和使用都需要下载编译好的软件包然后解包使用，不是很方便，联系到 macOS 下常用的包管理 Homebrew，何不自己提交一个？&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>使用免费的let’s encrypt证书为网站开启https（已过时）</title>
    <link href="https://qiwihui.com/qiwihui-blog-23/"/>
    <id>https://qiwihui.com/qiwihui-blog-23/</id>
    <published>2018-09-09T21:39:29.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客将介绍使用免费的let’s encrypt证书, 为网站开启https。</p><a id="more"></a><h2>HTTPS简介</h2><p>(https, http over ssl)</p><h2>为啥要用Let’s Encrypt</h2><p>(free, easy)</p><h2>Let’s Encrypt介绍</h2><p>(directory tree)</p><h2>安装实践</h2><p>我使用的是Debian 7，其他系统类似。</p><ol><li>使用官方推荐的<code>letsencrypt-auto</code>安装：</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/letsencrypt/letsencrypt</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> letsencrypt</span><br><span class="line"></span><br><span class="line">$ ./letsencrypt-auto --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><ol start="2"><li>获取证书</li></ol><p>实验前，我已将<code>www.qiwihui.com</code>站点移到了要安装的服务器上，nginx已经在运行，因此可以使用 webroot 模式来获取证书，先安装webroot插件，这是一个可以不用停止 Web 服务就能让 Let’s Encrypt 验证域名的插件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location ~ /.well-known &#123;</span><br><span class="line">    allow all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安装证书命令如下：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ./letsencrypt-auto certonly --webroot --webroot-path /var/www/blog/ -d qiwihui.com -d www.qiwihui.com --agree-tos --email qiwihui@qiwihui.com</span><br></pre></td></tr></table></figure><p>其中<code>/var/www/blog/</code>为网站根目录。证书申请成功后会提示一下信息，包括证书存放目录和证书过期时间：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">IMPORTANT NOTES:</span><br><span class="line"></span><br><span class="line">- Congratulations! Your certificate and chain have been saved at</span><br><span class="line">/etc/letsencrypt/live/qiwihui.com/fullchain.pem. Your cert will</span><br><span class="line">expire on 2016-07-08. To obtain a new version of the certificate <span class="keyword">in</span></span><br><span class="line">the future, simply run Let<span class="string">'s Encrypt again.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- If you like Let'</span>s Encrypt, please consider supporting our work by:</span><br><span class="line"></span><br><span class="line">Donating to ISRG / Let<span class="string">'s Encrypt:  https://letsencrypt.org/donate</span></span><br><span class="line"><span class="string">Donating to EFF:                    https://eff.org/donate-le</span></span><br></pre></td></tr></table></figure><p><em>重要提示</em>：需要将站点的DNS指向对用的服务器，否则会提示申请不过。</p><ol start="3"><li>配置Nginx</li></ol><p>首先生成2048位 DH parameters：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ mkdir -p /var/www/ssl/</span><br><span class="line">$ sudo openssl dhparam -out /var/www/ssl/dhparam.pem 2048</span><br></pre></td></tr></table></figure><p>Nginx的配置如下：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">server_name</span> qiwihui.com www.qiwihui.com;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">        <span class="attribute">ssl_certificate</span>     /etc/letsencrypt/live/qiwihui.com/fullchain.pem;</span><br><span class="line">        <span class="attribute">ssl_certificate_key</span> /etc/letsencrypt/live/qiwihui.com/privkey.pem;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">ssl_dhparam</span> /var/www/ssl/dhparam.pem;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">ssl_prefer_server_ciphers</span>  <span class="literal">on</span>;</span><br><span class="line">        <span class="attribute">ssl_ciphers</span> <span class="string">'ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#网站其他配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要开启全站 https 的话，需要将 http 转向到 https，再添加一个 server 就好了：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> qiwihui.com www.qiwihui.com;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$server_name</span><span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改完成后reload nginx 就可以了：<code>nginx -s reload</code></p><h3>验证检测</h3><ol><li>用浏览器打开目标网址<code>https://qiwihui.com</code>，可以查看到证书信息：</li></ol><img width="792" alt="10-https-on-qiwihui-com" src="https://user-images.githubusercontent.com/3297411/45278285-064a6880-b4ff-11e8-9ff2-24cce84cdec8.png"><ol start="2"><li>使用 <a href="https://www.ssllabs.com/ssltest/index.html" target="_blank" rel="noopener">Qualys ssllabs</a> 在线测试服务器证书强度以及配置正确性：</li></ol><img width="1374" alt="10-ssllabs-results" src="https://user-images.githubusercontent.com/3297411/45278293-0cd8e000-b4ff-11e8-80c6-a6cd4c8ce89e.png"><h3>后续更新</h3><p>Let’s Encrypt 的有效期只有90天，官方客户端不支持持续更新，所以要设置自动更新，让证书一直有效。</p><p>在crontab 中设置定时任务：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">30 2 * * 1 /root/letsencrypt/letsencrypt-auto renew &gt;&gt; /var/<span class="built_in">log</span>/le-renew.log</span><br><span class="line">35 2 * * 1 /etc/init.d/nginx reload</span><br></pre></td></tr></table></figure><p>上述配置会再每周一凌晨2:30执行<code>letsencrypt-auto renew</code>，在2点35分重新加载nginx配置，同时更新日志会在写在<code>/var/log/le-renewal.log</code>中。</p><h2>总结</h2><p>Let’s Encrypt TLS/SSL is free.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博客将介绍使用免费的let’s encrypt证书, 为网站开启https。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Nginx服务器设置HTTP/2</title>
    <link href="https://qiwihui.com/qiwihui-blog-22/"/>
    <id>https://qiwihui.com/qiwihui-blog-22/</id>
    <published>2018-09-09T21:38:41.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>我的博客已经支持了 HTTP/2, 在此将介绍如何在 Nginx 上设置 HTTP/2 及相关注意事项(坑)。</p><h2>前提</h2><p>HTTP/2 安装需要以下前提：</p><ul><li>Nginx 版本在1.9.5以上</li><li>OpenSSL 版本在 1.0.2g 以上（支持 ALPN）</li></ul><a id="more"></a><p>不同 Linux 系统对于 <code>ALPN</code> 和 <code>NPN</code> 的支持可以参见下表</p><table><thead><tr><th>Operating System</th><th>OpenSSL Version</th><th>ALPN and NPN Support</th></tr></thead><tbody><tr><td>CentOS/Oracle Linux/RHEL 5.10+</td><td>0.9.8e</td><td>Neither</td></tr><tr><td>CentOS/Oracle Linux/RHEL 6.5+, 7.0+</td><td>1.0.1e</td><td>NPN</td></tr><tr><td>Ubuntu 12.04 LTS</td><td>1.0.1</td><td>NPN</td></tr><tr><td>Ubuntu 14.04 LTS</td><td>1.0.1f</td><td>NPN</td></tr><tr><td>Ubuntu 16.04 LTS</td><td>1.0.2g</td><td>ALPN and NPN</td></tr><tr><td>Debian 7.0</td><td>1.0.1e</td><td>NPN</td></tr><tr><td>Debian 8.0</td><td>1.0.1k</td><td>NPN</td></tr></tbody></table><p>所以要么升级使用带有 OpenSSL 1.0.2 的 Ubuntu 16.04 LTS，要么从头编译 Nginx.</p><p>我的服务器系统是 Debian 7, OpenSSL 版本是1.0.1t, 所以需要重新编译 Nginx 和 OpenSSL.</p><h2>安装过程</h2><h3>安装 OpenSSL</h3><p>下载并安装 OpenSSL:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cd ~</span></span><br><span class="line"><span class="comment"># wget http://www.openssl.org/source/openssl-1.1.0e.tar.gz</span></span><br><span class="line"><span class="comment"># tar -zxf openssl-1.1.0e.tar.gz</span></span><br><span class="line"><span class="comment"># cd openssl-1.1.0e</span></span><br><span class="line"><span class="comment"># ./configure</span></span><br><span class="line"><span class="comment"># make</span></span><br><span class="line"><span class="comment"># sudo make install</span></span><br></pre></td></tr></table></figure><p>使用 <code>openssl version</code> 来查看安装好的 OpenSSL 的版本。</p><h3>其他 Nginx 编译需要的环境</h3><p>需要编译 <code>PCRE</code> 库和 <code>zlib</code> 库[]：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.40.tar.gz</span></span><br><span class="line"><span class="comment"># tar -zxf pcre-8.40.tar.gz</span></span><br><span class="line"><span class="comment"># cd pcre-8.40</span></span><br><span class="line"><span class="comment"># ./configure</span></span><br><span class="line"><span class="comment"># make</span></span><br><span class="line"><span class="comment"># sudo make install</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># wget http://zlib.net/zlib-1.2.11.tar.gz</span></span><br><span class="line"><span class="comment"># tar -zxf zlib-1.2.11.tar.gz</span></span><br><span class="line"><span class="comment"># cd zlib-1.2.11</span></span><br><span class="line"><span class="comment"># ./configure</span></span><br><span class="line"><span class="comment"># make</span></span><br><span class="line"><span class="comment"># sudo make install</span></span><br></pre></td></tr></table></figure><h3>编译 Nginx</h3><p>首先，下载最新的 nginx，我使用 1.10.3.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">wget -c http://nginx.org/download/nginx-1.10.3.tar.gz</span><br><span class="line">tar xzvf nginx-1.10.3.tar.gzcd nginx-1.10.3</span><br></pre></td></tr></table></figure><p>其实，获取 Nginx 配置参数，使新版 Nginx 和之前的配置一样</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nginx -V</span></span><br><span class="line"></span><br><span class="line">nginx version: nginx/1.9.6</span><br><span class="line">built by gcc 4.7.2 (Debian 4.7.2-5) </span><br><span class="line">built with OpenSSL 1.0.1t  3 May 2016</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --prefix=/etc/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib/nginx/modules --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/<span class="built_in">log</span>/nginx/error.log --http-log-path=/var/<span class="built_in">log</span>/nginx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --http-client-body-temp-path=/var/cache/nginx/client_temp --http-proxy-temp-path=/var/cache/nginx/proxy_temp --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp --http-scgi-temp-path=/var/cache/nginx/scgi_temp --user=nginx --group=nginx --with-file-aio --with-threads --with-ipv6 --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-mail --with-mail_ssl_module --with-stream --with-stream_ssl_module --with-cc-opt=<span class="string">'-g -O2 -fstack-protector --param=ssp-buffer-size=4 -Wformat -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2 -fPIC'</span> --with-ld-opt=<span class="string">'-Wl,-z,relro -Wl,-z,now -Wl,--as-needed -pie'</span></span><br></pre></td></tr></table></figure><p>上述配置用已经有 <code>--with-http_v2_module</code> 选项了，还需要在上述配置参数后面加上 <code>--with-openssl=/path/to/your/openssl-1.1.0e</code> 指向新版本的 OpenSSL 文件夹</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/etc/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib/nginx/modules --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/<span class="built_in">log</span>/nginx/error.log --http-log-path=/var/<span class="built_in">log</span>/nginx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --http-client-body-temp-path=/var/cache/nginx/client_temp --http-proxy-temp-path=/var/cache/nginx/proxy_temp --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp --http-scgi-temp-path=/var/cache/nginx/scgi_temp --user=nginx --group=nginx --with-file-aio --with-threads --with-ipv6 --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-mail --with-mail_ssl_module --with-stream --with-stream_ssl_module --with-cc-opt=<span class="string">'-g -O2 -fstack-protector --param=ssp-buffer-size=4 -Wformat -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2 -fPIC'</span> --with-ld-opt=<span class="string">'-Wl,-z,relro -Wl,-z,now -Wl,--as-needed -pie'</span> --with-openssl=/home/qiwihui/openssl-1.1.0e</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">可以看到大致输出为</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">Configuration summary</span><br><span class="line">  + using threads</span><br><span class="line">  + using system PCRE library</span><br><span class="line">  + using OpenSSL library: /home/qiwihui/openssl-1.1.0e</span><br><span class="line">  + md5: using OpenSSL library</span><br><span class="line">  + sha1: using OpenSSL library</span><br><span class="line">  + using system zlib library</span><br><span class="line"></span><br><span class="line">  nginx path prefix: <span class="string">"/etc/nginx"</span></span><br><span class="line">  nginx binary file: <span class="string">"/usr/sbin/nginx"</span></span><br><span class="line">  nginx modules path: <span class="string">"/usr/lib/nginx/modules"</span></span><br><span class="line">  nginx configuration prefix: <span class="string">"/etc/nginx"</span></span><br><span class="line">  nginx configuration file: <span class="string">"/etc/nginx/nginx.conf"</span></span><br><span class="line">  nginx pid file: <span class="string">"/var/run/nginx.pid"</span></span><br><span class="line">  nginx error <span class="built_in">log</span> file: <span class="string">"/var/log/nginx/error.log"</span></span><br><span class="line">  nginx http access <span class="built_in">log</span> file: <span class="string">"/var/log/nginx/access.log"</span></span><br><span class="line">  nginx http client request body temporary files: <span class="string">"/var/cache/nginx/client_temp"</span></span><br><span class="line">  nginx http proxy temporary files: <span class="string">"/var/cache/nginx/proxy_temp"</span></span><br><span class="line">  nginx http fastcgi temporary files: <span class="string">"/var/cache/nginx/fastcgi_temp"</span></span><br><span class="line">  nginx http uwsgi temporary files: <span class="string">"/var/cache/nginx/uwsgi_temp"</span></span><br><span class="line">  nginx http scgi temporary files: <span class="string">"/var/cache/nginx/scgi_temp"</span></span><br></pre></td></tr></table></figure><p>最后，编译并安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line"><span class="comment"># sudo make install</span></span><br></pre></td></tr></table></figure><p>之后就可以看到已经安装好了新版 Nginx了。</p><h3>配置</h3><h4>配置 HTTPS</h4><p>请参考之前博客 <a href="https://blog.qiwihui.com/2016/04/10/enable-https/" target="_blank" rel="noopener">使用免费的let’s encrypt证书为网站开启https</a></p><h4>开启 http/2</h4><p>第一步完成后就设置好了一个 HTTPS 的网站了，在此基础之上开始 HTTP/2。首先，开启 HTTP/2：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">listen 443 ssl http2 default_server;</span><br></pre></td></tr></table></figure><p>其次，去除HTTP/2不支持的旧的不安全的密码套件[5]:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssl_prefer_server_ciphers on;</span><br><span class="line">ssl_ciphers EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;</span><br></pre></td></tr></table></figure><p>最后，检查配置并重启 Nginx:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nginx -t</span></span><br><span class="line"></span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf <span class="built_in">test</span> is successful</span><br><span class="line"></span><br><span class="line"><span class="comment"># sudo /etc/init.d/nginx restart</span></span><br></pre></td></tr></table></figure><h2>检查</h2><p>至此，不出问题的话你的服务器已经开始支持 HTTP/2 了，可以使用 <a href="https://tools.keycdn.com/http2-test" target="_blank" rel="noopener">HTTP/2 Test</a> 来检测是否支持了 HTTP/2</p><p><img src="/media/files/2017/02/19-qiwihui-com-http2.png" alt></p><p>其中，对 <code>ALPN</code> 的支持可以使用 OpenSSL 来检测：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> | openssl s_client -alpn h2 -connect qiwihui.com:443 | grep ALPN</span><br></pre></td></tr></table></figure><p>如果输出中包含 <code>ALPN protocol: h2</code>，说明服务端支持 <code>ALPN</code>，如果输出中包含 <code>No ALPN negotiated</code>，说明服务端不支持 <code>ALPN</code>。</p><p>同时，在 Chrome 的开发者工具中也可以看到协议的版本</p><p><img src="/media/files/2017/02/19-qiwihui-com-chrome-http2.png" alt></p><p>同时还可以对 HTTP/2 进行优化，请参见[6]，不赘述了。</p><h2>附录</h2><p>附录一份 Nginx 的 http/2 简单配置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 443 ssl http2 default_server;</span><br><span class="line">        listen [::]:443 ssl http2 default_server;</span><br><span class="line"></span><br><span class="line">        server_name example.com www.example.com; </span><br><span class="line"></span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_certificate     /etc/letsencrypt/live/example.com/fullchain.pem;</span><br><span class="line">        ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;</span><br><span class="line"></span><br><span class="line">        ssl_dhparam /path/to/your/dhparam.pem;</span><br><span class="line">        ssl_ciphers EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;</span><br><span class="line"></span><br><span class="line">        ssl_prefer_server_ciphers  on;</span><br><span class="line">        add_header Strict-Transport-Security <span class="string">"max-age=31536000; includeSubdomains;"</span>;</span><br><span class="line">        ssl_session_cache shared:SSL:5m;</span><br><span class="line">        ssl_session_timeout 1h;</span><br><span class="line">        </span><br><span class="line">        root /path/to/your/folder/;</span><br><span class="line">        index index.html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">    listen 80;</span><br><span class="line">    listen [::]:80;</span><br><span class="line">    server_name example.com www.example.com;</span><br><span class="line">    <span class="built_in">return</span> 301 https://<span class="variable">$server_name</span><span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>参考</h2><p>[1]. <a href="https://www.nginx.com/blog/supporting-http2-google-chrome-users/" target="_blank" rel="noopener">Supporting HTTP/2 for Google Chrome Users</a>[2]. <a href="https://imququ.com/post/enable-alpn-asap.html" target="_blank" rel="noopener">为什么我们应该尽快支持 ALPN？</a>[3]. <a href="https://www.nginx.com/resources/admin-guide/installing-nginx-open-source/" target="_blank" rel="noopener">Nginx官方教程 INSTALLING NGINX OPEN SOURCE</a>[4]. <a href="http://serverfault.com/a/733556/296724" target="_blank" rel="noopener">serverfault问题: Nginx configured with http2 doesn’t deliver HTTP/2</a>[5]. <a href="https://http2.github.io/http2-spec/#BadCipherSuites" target="_blank" rel="noopener">TLS 1.2 Cipher Suite Black List</a>[6]. <a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-nginx-with-http-2-support-on-ubuntu-16-04#step-10-%E2%80%94-optimizing-nginx-for-best-performance" target="_blank" rel="noopener">Optimizing Nginx for Best Performance</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我的博客已经支持了 HTTP/2, 在此将介绍如何在 Nginx 上设置 HTTP/2 及相关注意事项(坑)。&lt;/p&gt;
&lt;h2&gt;前提&lt;/h2&gt;
&lt;p&gt;HTTP/2 安装需要以下前提：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nginx 版本在1.9.5以上&lt;/li&gt;
&lt;li&gt;OpenSSL 版本在 1.0.2g 以上（支持 ALPN）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>极路由+shadowsocks翻墙</title>
    <link href="https://qiwihui.com/qiwihui-blog-21/"/>
    <id>https://qiwihui.com/qiwihui-blog-21/</id>
    <published>2018-09-09T21:37:57.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>翻墙折腾无止境.使用路由器翻墙的一个好处在于，对于一些翻墙配置很繁琐的设备，只需要简单地连上路由wifi就可以实现翻墙，来家里的朋友也可以不需要配置就可以一连翻墙.</p><a id="more"></a><h2>一些背景</h2><p>在旧版本的极路由已经有很不错的翻墙设置方式，感谢前人的大树：三流火的shadwosocks插件.在旧版本的极路由上设置shadowsocks翻墙可已参考<a href="https://luolei.org/hiwifi-shadowsocks/" target="_blank" rel="noopener">极路由Shadowsocks家庭无痛翻墙实践</a>.</p><p>最近极路由更新了新版本，管理界面风格大变导致之前的插件不能使用，在网上找了一段时间也没有看到有人对之前的插件进行更新，所以决定自己写一个(其实后来才知道stary.love也有可用的插件,比我修改的插件功能强大很多).所谓的自己写也只是在前人的基础上修改为适应新的极路由后台管理假面. 这过程要感谢stary.love的帮助，为我提供了早期插件的一些源代码，以及许多帮着测试使用的人.</p><h2>一些方法</h2><p>项目地址: <a href="https://github.com/qiwihui/hiwifi-ss" target="_blank" rel="noopener">qiwihui/hiwifi-ss</a>, 现在插件的状态：</p><ol><li>界面结构适应了新的hiwifi后台管理；</li></ol><img width="1006" alt="07-ss-settings" src="https://user-images.githubusercontent.com/3297411/45278213-a9e74900-b4fe-11e8-962b-8fd448edfbed.png"><ol start="3"><li>开启关闭翻墙功能和设置dns解析功能也都恢复；</li></ol><img width="1008" alt="07-ss-advance" src="https://user-images.githubusercontent.com/3297411/45278223-b5d30b00-b4fe-11e8-88c5-cdf2437bfe6f.png"><ol start="3"><li>新增加了最新的gfwlist列表(截止到2016年8月7日)的路由规则,解决了之前有部分网站无法访问的问题;</li></ol><h3>安装过程</h3><p>(1). 开启极路由开发者模式</p><p>需要开发者模式才能安装. 网上有很多教程,不赘述.</p><p>(2). 登录路由器, 一键安装脚本.</p><p>极路由默认开启1022端口作为ssh端口,故使用<code>ssh root@192.168.199.1 -p 1022</code>登录路由器,运行如下一键脚本:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp &amp;&amp; curl -k -o shadow.sh https://raw.githubusercontent.com/qiwihui/hiwifi-ss/master/shadow.sh &amp;&amp; sh shadow.sh &amp;&amp; rm shadow.sh</span><br></pre></td></tr></table></figure><p>然后登录后台管理界面,在<code>互联网</code>菜单下的<code>shadowsocks设置</code>配置ss账号就可以了.</p><h2>一些展望</h2><p>未来要做的一些工作:</p><ol><li>功能的改进: 包括但不限于ss版本的更新, 规则的更新, 流量混淆等;</li><li>可能支持更多种类的工具;</li><li>最重要的是: 开源. 包括底层的代码重写或者是找到之前的代码.</li></ol><h2>一些感想</h2><ul><li>&quot;免费&quot;是最贵的</li></ul><p>怎么说呢, 我在最开始的时候, 寻找免费的vpn是获得翻墙的唯一方式, 这种方式的不好之处在于: vpn不稳定, 经常换,而且花费在寻找上的精力和时间算下来不合算. 之后精力了<code>地下铁路vpn</code>的消失之后, 自己搭建翻墙才成为我的主要翻墙方式. 一个月花费的费用不到10美元, 带来的时稳定的流量和方式. VPS+shadowsocks/v2ray就可以提供稳定持久的方式.</p><ul><li>风险</li></ul><p>不怎么使用vpn(免费或者收费)以及一些其他的收费翻墙服务，一则担心不安全, 流量劫持或者流量分析都有可能，甚者蜜罐,二则是重点观察对象, 服务失效的可能性还是存在的. 因此, 加密翻墙流量和混淆翻墙行为时十分重要的过程.</p><ul><li>技术人员获取资讯和信息的广度和及时性</li></ul><p>因为GFW, 墙内封闭的环境使得获取技术知识的广度和及时性都受到了很严重的影响, 翻墙让搞技术的我们与世界更接近.</p><p>分享 <a href="https://twitter.com/lepture" target="_blank" rel="noopener">@lepture</a>的一个tweet:</p><blockquote><p>「我的互联网，上谷歌维基搜知识，上Reddit看看头条，上YouTube学习和开眼界，上Twitter关注一些正在改变世界的人和事，去Quora上看看好的问题和回答，去SlideShare上学习以及了解不同的想法和观点」</p></blockquote><h2>总结</h2><p>翻墙在于不断折腾.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻墙折腾无止境.
使用路由器翻墙的一个好处在于，对于一些翻墙配置很繁琐的设备，只需要简单地连上路由wifi就可以实现翻墙，
来家里的朋友也可以不需要配置就可以一连翻墙.&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>在VirtualBox安装Arch Liux初步指南</title>
    <link href="https://qiwihui.com/qiwihui-blog-20/"/>
    <id>https://qiwihui.com/qiwihui-blog-20/</id>
    <published>2018-09-09T21:36:09.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>简单地写一下在VirtualBox上安装Arch Linux的过程，以此为在PC上安装做准备。在PC上安装的过程和下面描述的基本一致。</p><a id="more"></a><p>##0x00 准备</p><ol><li><p>下载iso文件：在Arch官网上<a href="https://www.archlinux.org/download/" target="_blank" rel="noopener">下载</a>最新的镜像，这里我选用了<a href="http://mirrors.163.com/archlinux/iso/2015.01.01/" target="_blank" rel="noopener">163.com</a>节点的资源，下载archlinux-2015.01.01-dual.iso；</p></li><li><p>检查文件的完整性：在MAC中使用md5或者sha1检验文件的完整行，并和下载站点提供的值进行比较。</p> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ openssl sha1 archlinux-2014.12.01-dual.iso </span><br><span class="line">SHA1(archlinux-2014.12.01-dual.iso)= 86085153f97f0097fd0a02496e67cf85138c1ba5</span><br><span class="line"></span><br><span class="line">$ md5 archlinux-2014.12.01-dual.iso </span><br><span class="line">MD5 (archlinux-2014.12.01-dual.iso) = 667ed3c5e935666edfd54a2271e05b72</span><br></pre></td></tr></table></figure></li></ol><p>##0x01 创建虚拟机</p><ol><li><p>给虚拟机一个名字<img src="/media/files/2015/Jan/0-NameAndOperatingSystem.png"><img></p></li><li><p>内存：最小为256MB<img src="/media/files/2015/Jan/1-MemorySize.png"><img></p></li><li><p>创建新的虚拟磁盘<img src="/media/files/2015/Jan/2-HardDrive.png"><img></p></li><li><p>文件类型<img src="/media/files/2015/Jan/3-HardDriveFileType.png"><img></p></li><li><p>动态分配<img src="/media/files/2015/Jan/4-StorageOnPhysicalHardDrive.png"><img></p></li><li><p>文件位置和大小，最小10GB<img src="/media/files/2015/Jan/5-FileLocationAndSize.png"><img></p></li><li><p>如果要安装桌面环境的话就勾选<code>Enable 3D Acceleration</code><img src="/media/files/2015/Jan/6-Enable3DAcceleration.png"><img></p></li><li><p>第一次启动虚拟机时，选取之前下载的ISO文件<img src="/media/files/2015/Jan/7-SelectISOFile.png"><img></p></li></ol><p>##0x01 开始安装</p><ol><li><p>选择32位或者64位Arch<img src="/media/files/2015/Jan/8-BootArchLinux.png"><img></p><p>一旦看到如下提示，就可以开始进行配置了：<img src="/media/files/2015/Jan/9-Command.png"><img></p></li><li><p>更改键盘布局和设置语言：</p><p>默认键盘布局为<code>us</code>，非us布局可以用如下命令修改：</p> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># loadkeys layout</span></span><br></pre></td></tr></table></figure><p>layout可以是<code>uk</code>, <code>dvorak</code>等。设置语言：</p></li><li><p>磁盘分区</p><p>先看一下磁盘状态：</p> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ls /dev</span></span><br></pre></td></tr></table></figure><p>开始啦，一般创建四个分区：<code>/</code>, <code>/boot</code>, <code>/home</code>, <code>swap</code></p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># gdisk /dev/sda</span><br></pre></td></tr></table></figure><p>当出现下面命令时, 开始分区，一下以<code>/boot</code>分区为例：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Command (? for help):</span><br></pre></td></tr></table></figure><p>a. 创建新分区：'n’b. 分区号码：回车默认从0开始递增c. “first sector”: 回车默认从上一个分区结束处开始，初始为0d. “last sector”: '+250MB’e. “hex code”: 回车默认（8300 为&quot;Linux File System&quot;），<code>swap</code>分区输入8200, 见<a href="http://www.basicconfig.com/hex_codes_system_id" target="_blank" rel="noopener">这儿</a></p><p>依次给<code>swap</code>分配’+1G’（和分配的RAM一样大），<code>/boot</code>分配’+8G’，<code>/home</code>分配’+1G’，再次看一下磁盘的状态，可以看到已经分配好了，键入’w’并回车即可保存修改。</p></li><li><p>格式化分区</p><p>再次回到命令行：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@archiso ~ #</span><br></pre></td></tr></table></figure><p>格式化分区：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mkfs -t ext4 /dev/sda1</span><br><span class="line"># mkfs -t ext4 /dev/sda3</span><br><span class="line"># mkfs -t ext4 /dev/sda4</span><br><span class="line"></span><br><span class="line"># mkswap /dev/sda2</span><br></pre></td></tr></table></figure></li><li><p>挂载新分区</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># swapon /dev/sda2</span><br><span class="line"></span><br><span class="line"># mount /dev/sda3 /mnt</span><br><span class="line"># cd /mnt</span><br><span class="line"># mkdir boot home</span><br><span class="line"># mount /dev/sda1 boot</span><br><span class="line"># mount /dev/sda4 home</span><br></pre></td></tr></table></figure></li><li><p>安装Arch</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cd /</span><br><span class="line"># pacstrap /mnt base base-devel</span><br></pre></td></tr></table></figure></li><li><p>生成<code>fstab</code>文件</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># genfstab -p /mnt &gt;&gt; /mnt/etc/fstab</span><br></pre></td></tr></table></figure><p>可以看看fstab里面的内容：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># more /mnt/etc/fstab</span><br></pre></td></tr></table></figure></li><li><p>初始化安装Boot Loader</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># pacstrap /mnt syslinux</span><br></pre></td></tr></table></figure></li><li><p>配置安装</p><p>运行以下命令：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># arch-chroot /mnt</span><br></pre></td></tr></table></figure><p>得到：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh-4.2#</span><br></pre></td></tr></table></figure><p>这个shell很基础，用Bash也许更好些：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># bash</span><br></pre></td></tr></table></figure><p>得到：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@archiso /]#</span><br></pre></td></tr></table></figure><p>设置语言：</p> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nano /etc/locale.conf</span></span><br></pre></td></tr></table></figure><p>添加：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LANG=&quot;en_US.UTF-8&quot;</span><br></pre></td></tr></table></figure> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nano /etc/locale.gen</span></span><br></pre></td></tr></table></figure><p>将下面两行前面<code>#</code>去除：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">en_US.UTF-8 UTF-8</span><br><span class="line">de_DE.UTF-8 UTF-8</span><br></pre></td></tr></table></figure><p>完成语言设置：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># locale-gen</span><br></pre></td></tr></table></figure><p>设置时间：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ln -s /usr/share/zoneinfo/&lt;your_state&gt;/&lt;your_city&gt; /etc/localtime</span><br></pre></td></tr></table></figure><p>比如我设置的是：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ln -s /usr/share/zoneinfo/Asia/Chongqing /etc/localtime</span><br></pre></td></tr></table></figure><p>改hostname：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># nano /etc/hostname</span><br></pre></td></tr></table></figure></li><li><p>完成Bootloader安装</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cd /boot/syslinux/</span><br></pre></td></tr></table></figure><p>打开syslinux.cfg文件，找到&quot;comboot modules&quot;一段：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># more syslinux.cfg</span><br></pre></td></tr></table></figure><p>将其中列举的文件copy到本地，同时还要加上’libutil.c32’:</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cp /usr/lib/syslinux/bios/menu.c32 .</span><br><span class="line"># cp /usr/lib/syslinux/bios/vesamenu.c32 .</span><br><span class="line"># cp /usr/lib/syslinux/bios/chain.c32 .</span><br><span class="line"># cp /usr/lib/syslinux/bios/hdt.c32 .</span><br><span class="line"># cp /usr/lib/syslinux/bios/reboot.c32 .</span><br><span class="line"># cp /usr/lib/syslinux/bios/poweroff.c32 .</span><br><span class="line"># cp /usr/lib/syslinux/bios/libutil.c32 .</span><br></pre></td></tr></table></figure><p>一旦完成上述设置，</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># extlinux --install /boot/syslinux</span><br><span class="line"># dd conv=notrunc bs=440 count=1 if=/usr/lib/syslinux/bios/gptmbr.bin of=/dev/sda</span><br><span class="line"># mkinitcpio -p linux</span><br></pre></td></tr></table></figure></li><li><p>完成安装</p><p>最后，更改root密码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># passwd</span><br></pre></td></tr></table></figure><p>输入两次<code>exit</code>退回到：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@archiso /]#</span><br></pre></td></tr></table></figure><p>umount所有的分区：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># umount /mnt/boot</span><br><span class="line"># umount /mnt/home</span><br><span class="line"># swapoff /dev/sda2</span><br><span class="line"># umount /mnt</span><br></pre></td></tr></table></figure><p>在重启之前最后一步，设置<code>/boot</code>分区的<a href="http://en.wikipedia.org/wiki/BIOS" target="_blank" rel="noopener">BIOS</a>标识为’bootable’：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># sgdisk /dev/sda --attributes=1:set:2</span><br></pre></td></tr></table></figure></li><li><p>重启Arch</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># reboot</span><br></pre></td></tr></table></figure><p>重启之后会再次进入CD启动，这时，去除安装CD，再次重启：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Devices &gt; CD/DVD Devices &gt; Remove disk from virtual drive</span><br></pre></td></tr></table></figure><p>等待一小会：</p><p><img src="/media/files/2015/Jan/10-ArchLinux.png"><img></p><p>Congradulations!</p></li><li><p>后续工作</p><p>链接网络：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dhcpcd</span><br></pre></td></tr></table></figure><p>安装’sudo’：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># pacman -S sudo</span><br></pre></td></tr></table></figure><p>添加’sudoer’:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># nano /etc/sudoers</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##</span><br><span class="line">## User privilege specification</span><br><span class="line">##</span><br><span class="line">root ALL=(ALL) ALL</span><br><span class="line">qiwihui ALL=(ALL) ALL</span><br></pre></td></tr></table></figure><p>保存，并log out：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># exit</span><br></pre></td></tr></table></figure><p>以新的ID和密码重新登录。</p><p>最后，每次登录的时候自动获取ip：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># sudo systemctl enable dhcpcd@eth0.service</span><br></pre></td></tr></table></figure></li></ol><p>这样最基本的Arch Linux就好了，Desktop Environment就不装了。</p><h2>0x02 参考文档</h2><ul><li><a href="https://wiki.archlinux.org/index.php/Beginners%27_guide" target="_blank" rel="noopener">Arch Linux Beginners’ guide</a></li><li><a href="https://wiki.archlinux.org/index.php/Installation_guide" target="_blank" rel="noopener">Arch Linux Installation Guide</a></li><li><a href="http://wideaperture.net/blog/?p=3851" target="_blank" rel="noopener">A Guide to Installing Arch in VirtualBox</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单地写一下在VirtualBox上安装Arch Linux的过程，以此为在PC上安装做准备。在PC上安装的过程和下面描述的基本一致。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>9个值得知道的cURL的用法</title>
    <link href="https://qiwihui.com/qiwihui-blog-19/"/>
    <id>https://qiwihui.com/qiwihui-blog-19/</id>
    <published>2018-09-09T21:33:38.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>对于 HTTP 工程师和 API 设计师来说，使用命令行操作 HTTP 是非常有用的技能。<a href="http://curl.haxx.se/" target="_blank" rel="noopener">cURL</a>库和 <code>curl</code> 命令可以给你设计请求，放入管道并查看相应的能力。<code>curl</code> 能力的缺点在于它能覆盖多广的命令选项。使用 <code>curl --help</code> 会展示出150条不同的选项。这篇文章演示了9个基本的，现实程序用到的 <code>curl</code> 命令。</p><a id="more"></a><p>在这篇教程中我们会使用httpkit的 <a href="http://echo.httpkit.com/" target="_blank" rel="noopener">echo</a> 服务做为端点，回显服务的响应是它收到 HTTP 请求的 JSON 表示。</p><h2>创建请求</h2><p>我们从最简单的 <code>curl</code> 命令开始。</p><p><strong>请求</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl http://echo.httpkit.com</span><br></pre></td></tr></table></figure><p><strong>响应</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;method&quot;: &quot;GET&quot;,</span><br><span class="line">  &quot;uri&quot;: &quot;/&quot;,</span><br><span class="line">  &quot;path&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;/&quot;,</span><br><span class="line">    &quot;query&quot;: &quot;&quot;,</span><br><span class="line">    &quot;params&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;host&quot;: &quot;echo.httpkit.com&quot;,</span><br><span class="line">    &quot;user-agent&quot;: &quot;curl/7.24.0 ...&quot;,</span><br><span class="line">    &quot;accept&quot;: &quot;*/*&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;body&quot;: null,</span><br><span class="line">  &quot;ip&quot;: &quot;28.169.144.35&quot;,</span><br><span class="line">  &quot;powered-by&quot;: &quot;http://httpkit.com&quot;,</span><br><span class="line">  &quot;docs&quot;: &quot;http://httpkit.com/echo&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这样，我们用 <code>curl</code> 创建了一个请求，<code>curl</code> 使用的 HTTP 动词默认为 <code>GET</code>，请求的资源指向的是<a href="http://httpkit.com/" target="_blank" rel="noopener">httpkit</a> 的 <a href="http://httpkit.com/echo" target="_blank" rel="noopener">echo</a> 服务：<code>http://echo.httpkit.com</code>。</p><p>你可以添加路径和查询变量：</p><p><strong>请求</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl http://echo.httpkit.com//path?query=string</span><br></pre></td></tr></table></figure><p><strong>响应</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; ...</span><br><span class="line">  &quot;uri&quot;: &quot;/path?query=string&quot;,</span><br><span class="line">  &quot;path&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;/path&quot;,</span><br><span class="line">    &quot;query&quot;: &quot;?query=string&quot;,</span><br><span class="line">    &quot;params&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &quot;string&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>设置请求方法</h2><p><code>curl</code>默认的请求方法为 <code>GET</code> ，可以用 <code>-X</code> 参数设置成任何你想要的方法，通常为 <code>POST</code>，<code>PUT</code>，<code>DELETE</code>方法，甚至是自定义的方法。</p><p><strong>请求</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X POST echo.httpkit.com</span><br></pre></td></tr></table></figure><p><strong>响应</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;method&quot;: &quot;POST&quot;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你看到的，<code>http://</code> 协议前缀可以不使用，因为这是默认假定的。接着实施 <code>DELETE</code> 方法：</p><p><strong>请求</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X DELETE echo.httpkit.com</span><br></pre></td></tr></table></figure><p><strong>响应</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;method&quot;: &quot;DELETE&quot;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>设置请求头部</h2><p>请求头部允许客户端给服务器提供诸如授权，内容类型等信息。比如，OAuth2 使用 <code>Authorization</code> 头来传递访问令牌（access tokens）。<code>curl</code> 使用 <code>-H</code> 选项设置自定义头部。</p><p><strong>请求</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -H &quot;Authorization: OAuth 2c4419d1aabeec&quot; \</span><br><span class="line">     http://echo.httpkit.com</span><br></pre></td></tr></table></figure><p><strong>响应</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;...</span><br><span class="line">&quot;headers&quot;: &#123;</span><br><span class="line">    &quot;host&quot;: &quot;echo.httpkit.com&quot;,</span><br><span class="line">    &quot;authorization&quot;: &quot;OAuth 2c4419d1aabeec&quot;,</span><br><span class="line">  ...&#125;,</span><br><span class="line">...&#125;</span><br></pre></td></tr></table></figure><p>可以使用 <code>-H</code> 多次来设置多个头部。</p><p><strong>请求</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -H &quot;Accept: application/json&quot; \</span><br><span class="line">     -H &quot;Authorization: OAuth 2c3455d1aeffc&quot; \</span><br><span class="line">     http://echo.httpkit.com</span><br></pre></td></tr></table></figure><p><strong>响应</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; ...</span><br><span class="line">  &quot;headers&quot;: &#123; ...</span><br><span class="line">    &quot;host&quot;: &quot;echo.httpkit.com&quot;,</span><br><span class="line">    &quot;accept&quot;: &quot;application/json&quot;,</span><br><span class="line">    &quot;authorization&quot;: &quot;OAuth 2c3455d1aeffc&quot; </span><br><span class="line">   &#125;, ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>发送请求体</h2><p>现今许多有名的 HTTP API 使用 <code>application/json</code> 和 <code>application/xml</code> 来 <code>POST</code> 和 <code>PUT</code> 资源，而不是用HTML化的数据。我们试试 <code>PUT</code> 一些 JSON 数据到服务器上。</p><p><strong>请求</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X PUT \</span><br><span class="line">     -H &apos;Content-Type: application/json&apos; \</span><br><span class="line">     -d &apos;&#123;&quot;firstName&quot;:&quot;Kris&quot;, &quot;lastName&quot;:&quot;Jordan&quot;&#125;&apos;</span><br><span class="line">     echo.httpkit.com</span><br></pre></td></tr></table></figure><p><strong>响应</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;method&quot;: &quot;PUT&quot;, ...</span><br><span class="line">   &quot;headers&quot;: &#123; ...</span><br><span class="line">     &quot;content-type&quot;: &quot;application/json&quot;,</span><br><span class="line">     &quot;content-length&quot;: &quot;40&quot;</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;body&quot;: &quot;&#123;\&quot;firstName\&quot;:\&quot;Kris\&quot;,\&quot;lastName\&quot;:\&quot;Jordan\&quot;&#125;&quot;,</span><br><span class="line">   ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2>使用文件作为请求体</h2><p>将 JSON/XML 写到命令行中是令人头疼的，尤其有时这个文件很大时。幸运的是， <code>curl</code> 的 <code>@readfile</code>可以很容易地读取文件的文本。如果上面例子中的 JSON 保存为文件 <code>example.json</code>， 我们可以这么做：</p><p><strong>请求</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X PUT \</span><br><span class="line">     -H &apos;Content-Type: application/json&apos; \</span><br><span class="line">     -d @example.json</span><br><span class="line">     echo.httpkit.com</span><br></pre></td></tr></table></figure><h2>发送 HTML 表单数据</h2><p>如果不能发送带有数据的请求体，可以设置类似 <code>POST</code> 的方法真是没什么用。也许我们可以试试发送 HTML表单数据。使用 <code>-d</code> 选项，我们可以制定 URL 编码的名称和值。</p><p><strong>请求</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -d &quot;firstName=Kris&quot; \</span><br><span class="line">     -d &quot;lastName=Jordan&quot; \</span><br><span class="line">     echo.httpkit.com</span><br></pre></td></tr></table></figure><p><strong>响应</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;method&quot;: &quot;POST&quot;, ...</span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;content-length&quot;: &quot;30&quot;,</span><br><span class="line">    &quot;content-type&quot;:&quot;application/x-www-form-urlencoded&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;body&quot;: &quot;firstName=Kris&amp;lastName=Jordan&quot;, ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到 <code>POST</code> 这个方法，即使我们没有指明方法，当 <code>curl</code> 看到表单数据时它会指定 <code>POST</code> 方法。可以使用 <code>-X</code> 选项来覆盖这个方法。请求的 <code>Content-Type</code> 也被自动设置为 <code>application/x-www-form-urlencoded</code>，这样服务器就知道怎么解析数据了。最终，请求体由编码了每一个表单域的 URL 构成。</p><h2>发送 HTML Multipart/file 表单（上传文件）</h2><p>当涉及到文件上传的表单时，正如你从写上传文件表单时知道的那样，这些使用 <code>multipart/form-data</code> 文本类型，带有 <code>enctype</code> 属性。cURL 使用 <code>-F</code> 配合上面介绍的 <code>@readFile</code> 宏来处理。</p><p><strong>请求</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -F &quot;firstName=Kris&quot; \</span><br><span class="line">     -F &quot;publicKey=@idrsa.pub;type=text/plain&quot; \</span><br><span class="line">     echo.httpkit.com</span><br></pre></td></tr></table></figure><p><strong>响应</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;method&quot;: &quot;POST&quot;,</span><br><span class="line">  ...</span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;content-length&quot;: &quot;697&quot;,</span><br><span class="line">    &quot;content-type&quot;: &quot;multipart/form-data;</span><br><span class="line">    boundary=----------------------------488327019409&quot;,</span><br><span class="line">    ... &#125;,</span><br><span class="line">  &quot;body&quot;: &quot;------------------------------488327019409\r\n</span><br><span class="line">           Content-Disposition: form-data;</span><br><span class="line">           name=\&quot;firstName\&quot;\r\n\r\n</span><br><span class="line">           Kris\r\n</span><br><span class="line">           ------------------------------488327019409\r\n</span><br><span class="line">           Content-Disposition: form-data;</span><br><span class="line">           name=\&quot;publicKey\&quot;;</span><br><span class="line">           filename=\&quot;id_rsa.pub\&quot;\r\n</span><br><span class="line">           Content-Type: text/plain\r\n\r\n</span><br><span class="line">           ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAkq1lZYUOJH2</span><br><span class="line">           ... more [a-zA-Z0-9]* ...</span><br><span class="line">           naZXJw== krisjordan@gmail.com\n\r\n</span><br><span class="line">           ------------------------------488327019409</span><br><span class="line">           --\r\n&quot;,</span><br><span class="line">...&#125;</span><br></pre></td></tr></table></figure><p>像 <code>-d</code> 选项一样，当使用 <code>-d</code> 选项时 <code>curl</code> 会自动地默认使用 <code>POST</code> 方法，<code>multipart/form-data</code> 文件类型头部，计算长度并组成请求体。请注意 <code>@readFile</code>  宏是怎样读取一个文件的文本为任何字符的，这个不是一个单独的操作，<code>;text/plain</code> 指定了文件的 MIME 文本类型。在未指定的情况下，<code>curl</code> 会尝试嗅探文本类型。</p><h2>测试虚拟主机，不使用 DNS</h2><p>通常，在不修改 DNS 覆盖主机的情况下测试一个虚拟主机或者是缓存代理时很有用的。只需使用 cURL 将请求指向主机的 IP 地址 并覆写 <code>Host</code> 头。</p><p><strong>请求</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -H &quot;Host: google.com&quot; 50.112.251.120</span><br></pre></td></tr></table></figure><p><strong>响应</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;method&quot;: &quot;GET&quot;, ...</span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;host&quot;: &quot;google.com&quot;, ...</span><br><span class="line">  &#125;, ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>查看响应头部</h2><p>API 正越来越多的利用响应头部来提供授权，速率限制，缓存等方面的信息。cURL 使用 <code>-i</code> 选项来查看响应头部和响应体。</p><p><strong>请求</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -i echo.httpkit.com</span><br></pre></td></tr></table></figure><p><strong>响应</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.1.19</span><br><span class="line">Date: Wed, 29 Aug 2012 04:18:19 GMT</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Content-Length: 391</span><br><span class="line">Connection: keep-alive</span><br><span class="line">X-Powered-By: http://httpkit.com</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;method&quot;: &quot;GET&quot;,</span><br><span class="line">  &quot;uri&quot;: &quot;/&quot;, ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原文：<a href="http://httpkit.com/resources/HTTP-from-the-Command-Line/" target="_blank" rel="noopener">9 uses for cURL worth knowing</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于 HTTP 工程师和 API 设计师来说，使用命令行操作 HTTP 是非常有用的技能。&lt;a href=&quot;http://curl.haxx.se/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;cURL&lt;/a&gt;
库和 &lt;code&gt;curl&lt;/code&gt; 命令可以给你设计请求，放入管道并查看相应的能力。&lt;code&gt;curl&lt;/code&gt; 能力的缺点在于它能覆盖多广的
命令选项。使用 &lt;code&gt;curl --help&lt;/code&gt; 会展示出150条不同的选项。这篇文章演示了9个基本的，现实程序用到的 &lt;code&gt;curl&lt;/code&gt; 命令。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>使用 Git Hooks 实现项目自动部署</title>
    <link href="https://qiwihui.com/qiwihui-blog-18/"/>
    <id>https://qiwihui.com/qiwihui-blog-18/</id>
    <published>2018-09-09T21:32:54.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>自动化部署解放双手，发展生产力，更重要的是可以减少部署过程中的错误操作。</p><a id="more"></a><p>之前使用git做为我博客的版本控制，使用Github Pages托管我的博客，所以部署方面都交给了github，但是当我要部署另一个web应用时，显然要部署在自己的VPS上，把VPS做为git服务器的同时，每次push代码到服务器上都要手动运行一次脚本更新服务，这样做简直劳神伤力。</p><p>幸运的是Git提供了Hook机制用来帮助我们实现自动部署。Hooks分为客户端和服务端，可以用来处理不同的工作，这些hooks都被存储在 Git 目录下的hooks子目录中，即大部分项目中的<code>.git/hooks</code>。 Git 默认会放置一些脚本样本在这个目录中，除了可以作为hooks使用，这些样本本身是可以独立使用的，这些样本名都是以.sample结尾，必须重新命名。</p><p>这次主要用到服务端的hooks: <code>post-receive</code>。当用户在本地仓库执行<code>git push</code>命令时，服务器上运端仓库就会对应执行<code>git receive pack</code>命令；在所有远程仓库的引用(ref)都更新后，这个钩子就会被调用。与之对应的是<code>pre-receive</code>，这个会在更新之前被调用。</p><p>环境要求：</p><ol><li>要求客户端和服务端都有git环境，而且服务端最好已经部署好了；</li><li>能连上服务器</li></ol><h2>0x01 实践</h2><p>我们的实践过程会按照下边的过程实施：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+------------------------+          +------------------------+</span><br><span class="line">|                        |          |                        |</span><br><span class="line">|  +-----------------+   |   push   |  +-------------------+ |</span><br><span class="line">|  |local repository |---+----------+-&gt;| remote repository | |</span><br><span class="line">|  +-----------------+   |          |  +-------------------+ |</span><br><span class="line">|                        |          |             |          |</span><br><span class="line">+------------------------+          |             |pull      |</span><br><span class="line">                                    |             V          |</span><br><span class="line">     local machine                  |  +-------------------+ |</span><br><span class="line">                                    |  |     deployment    | |</span><br><span class="line">                                    |  +-------------------+ |</span><br><span class="line">                                    |                        |</span><br><span class="line">                                    +------------------------+</span><br><span class="line"></span><br><span class="line">                                             server</span><br></pre></td></tr></table></figure><h4>在server上初始化一个远程裸仓库：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~</span><br><span class="line">$ mkdir remoteRepo</span><br><span class="line">$ <span class="built_in">cd</span> remoteRepo</span><br><span class="line">$ git init --bare webapp.git</span><br></pre></td></tr></table></figure><h4>在server上初始化一个本地仓库，做为web app的代码：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~</span><br><span class="line">$ mkdir deployment</span><br><span class="line">$ <span class="built_in">cd</span> deployment</span><br><span class="line">$ git <span class="built_in">clone</span> ~/remoteRepo/webapp.git webapp</span><br></pre></td></tr></table></figure><h4>为远程仓库添加hook：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/remoteRepo/webapp.git/hooks</span><br><span class="line">$ vim post-receive</span><br><span class="line">$ cat post-receive</span><br></pre></td></tr></table></figure><p><code>post-receive</code>中的命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"># Check the remote git repository whether it is bare</span><br><span class="line">IS_BARE=$(git rev-parse --is-bare-repository)</span><br><span class="line">if [ -z &quot;$IS_BARE&quot; ]; then</span><br><span class="line">    echo &gt;&amp;2 &quot;fatal: post-receive: IS_NOT_BARE&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">unset GIT_DIR</span><br><span class="line"># current user is git</span><br><span class="line">DeployPath=/home/git/deployment/webapp</span><br><span class="line">if [ ! -d $DeployPath ] ; then</span><br><span class="line">    echo &gt;&amp;2 &quot;fatal: post-receive: DEPLOY_DIR_NOT_EXIST: \&quot;$DeployPath\&quot;&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">cd $DeployPath</span><br><span class="line">git add . -A &amp;&amp; git stash</span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><p>为<code>post-receive</code>添加可执行权限</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +x post-receive</span><br></pre></td></tr></table></figure><h4>为local machined的本地仓库添加远程仓库源：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;your-local-repository-folder&gt;</span><br><span class="line">$ git remote add deploy git@&lt;server.ip&gt;:/home/git/remoteRepo/webapp.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># then you need to merge conflict between local changes and deploy/master before you push it.</span></span><br><span class="line"><span class="comment"># 'git merge remotes/deploy/master' or some other git commands.</span></span><br><span class="line"></span><br><span class="line">$ git push deploy master</span><br></pre></td></tr></table></figure><p>或者从头开始创建一个项目：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>这样，当我们在本地完成更新并push到server上时，这些代码就会被自动更新。</p><h2>0x02 后来</h2><h4>改进1</h4><p>可以在最初在server上创建裸仓库时使用local machine上的现有项目，即将local machine上的项目仓库导出为裸仓库 — 即一个不包含当前工作目录的仓库：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> --bare my_project my_project.git</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cp -Rf my_project/.git my_project.git</span><br></pre></td></tr></table></figure><p>然后将这个裸仓库移到server上</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ scp -r my_project.git git@&lt;server.ip&gt;:/home/git/remoteRepo</span><br></pre></td></tr></table></figure><p>之后，其他人要进行更新时就可以clone这个项目了：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@&lt;server.ip&gt;:/home/git/remoteRepo/my_project.git</span><br></pre></td></tr></table></figure><h4>改进2</h4><p>有一种情况是当本地更新了webapp，结果push到远程仓库后这个更新被reset了（虽然我觉得这个问题应该避免，但是还是有可能发生），这是，简单地在hook中使用<code>git push deploy master</code>是无法完成这个过程的，因为远端的代码版本低于deploy端的代码版本，再使用pull的时候就不能实现同步，这时就应该使用另一种方式更新代码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch --all</span><br><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure><p>即<code>git reset</code>把HEAD 指向了新下载的未合并的节点，也就是在local machine上reset之后的。</p><p>参考：<a href="http://blog.csdn.net/a06062125/article/details/11727273" target="_blank" rel="noopener">git 放弃本地修改 强制更新</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自动化部署解放双手，发展生产力，更重要的是可以减少部署过程中的错误操作。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>使用Nginx，supervisor在DigitalOcean中部署tornado项目</title>
    <link href="https://qiwihui.com/qiwihui-blog-17/"/>
    <id>https://qiwihui.com/qiwihui-blog-17/</id>
    <published>2018-09-09T21:32:13.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>一直在想把微信的公众号的文章导出为RSS阅读，方便阅读和减少对微信的依赖，后来看到<a href="https://github.com/zhu327/rss" target="_blank" rel="noopener">zhu327/rss</a> 这个项目，这是一个用来生成微博，微信公众号，知乎日报 RSS 的Web APP。但是这个项目的demo部署在Red Hat的openshift上，囿于对这个cloud的操作不是很熟，所以想着把这个项目重新部署到自己在DigitalOcean的机器上，就fork了这个项目开始啦！</p><a id="more"></a><p>以下涉及到的内容有：</p><ul><li>Linux创建用户和修改用户组</li><li>git hooks实现自动部署</li><li>tornado项目的基本框架结构</li><li>supervisor管理进程</li><li>Nginx配置HTTP服务代理</li><li>DNS的记录添加</li></ul><h2>基本服务器设置</h2><p>因为之前并没有在我的服务器上创建过其他用户，如果直接用root用户的话不好，所以需要专门的一个账户来负责部署。</p><ol start="0"><li><p>登陆服务器：<code>ssh root@&lt;server-ip&gt;</code></p></li><li><p>创建一个用户<code>deploy</code>: <code>sudo adduser deploy</code></p></li><li><p>将用户加入sudoers中: <code>sudo usermod -a -G sudo deploy</code></p></li><li><p>添加远程连接的权限，这样就省去了输入密码了：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo su - deploy</span><br><span class="line">mkdir .ssh</span><br><span class="line">chmod 700 .ssh</span><br><span class="line">touch .ssh/authorized_keys</span><br><span class="line">chmod 600 .ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>其中，<code>700</code>表示只有文件拥有者才能读，写以及打开文件，<code>600</code>表示只能读和写。</p></li><li><p>接着将自己的公钥加入<code>authorized_keys</code>文件中，这个公钥在自己本机<code>~.ssh/id_rsa.pub</code>中。没有的话可以用<code>ssh-keygen -t rsa -C &quot;qwh005007@gmail.com&quot;</code>来生成。</p></li></ol><h2>创建使用git hooks的自动部署</h2><p>自动部署的好处就是省去了每次都要上服务器。可以参见之前的一篇博客<a href="http://daozhang.info/deploy-projects-with-git-hooks/" target="_blank" rel="noopener">使用 Git Hooks 实现项目自动部署</a> 来创建这个远程的git server。</p><p>这里，我们要先fork <a href="https://github.com/zhu327/rss" target="_blank" rel="noopener">zhu327/rss</a> 这个项目，然后用<code>git clone --bare rss rss.git</code>生成原来项目的裸仓库，然后将其复制到服务器上。我使用的是<code>~/remoteRepo/rss.git</code>做为git server，<code>~/deployment/rss</code>做为真正生产的代码文件目录。</p><p>其中，git hooks中的<code>post-receive</code>文件的内容为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"># Check the remote git repository whether it is bare</span><br><span class="line">IS_BARE=$(git rev-parse --is-bare-repository)</span><br><span class="line">if [ -z &quot;$IS_BARE&quot; ]; then</span><br><span class="line">echo &gt;&amp;2 &quot;fatal: post-receive: IS_NOT_BARE&quot;</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">unset GIT_DIR</span><br><span class="line"># current user is git</span><br><span class="line">DeployPath=/home/deploy/deployment/rss</span><br><span class="line">if [ ! -d $DeployPath ] ; then</span><br><span class="line">echo &gt;&amp;2 &quot;fatal: post-receive: DEPLOY_DIR_NOT_EXIST: \&quot;$DeployPath\&quot;&quot;</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">cd $DeployPath</span><br><span class="line">git add . -A &amp;&amp; git stash</span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><h2>修改源代码</h2><p><a href="https://github.com/zhu327/rss" target="_blank" rel="noopener">zhu327/rss</a> 项目的部署在openshift，为了将其部署在自己服务器上，修改是必须的。</p><ul><li><p>删除了项目中的openshift hooks部分</p></li><li><p>将其中用到openshift环境变量<code>OPENSHIFT_DIY_IP</code>和<code>OPENSHIFT_DIY_PORT</code>修改为对应的<code>localhost</code>和<code>8000</code>端口</p></li><li><p>将<code>diy/templates/</code>中的<code>https://diy-devz.rhcloud.com</code>修改为之后要用到的地址 <code>http://rss.daozhang.info</code></p></li><li><p>然后将修改好的代码在本地的virtualenv环境中测试，并生成需要的python的模块文件<code>requirement.txt</code>。如下：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Jinja2==2.7.3</span><br><span class="line">MarkupSafe==0.23</span><br><span class="line">backports.ssl-match-hostname==3.4.0.2</span><br><span class="line">certifi==2015.04.28</span><br><span class="line">lxml==3.4.4</span><br><span class="line">python-dateutil==2.4.2</span><br><span class="line">python-memcached==1.54</span><br><span class="line">six==1.9.0</span><br><span class="line">tornado==4.2</span><br><span class="line">wsgiref==0.1.2</span><br></pre></td></tr></table></figure></li></ul><p>这些都好了之后就可以将本地的文件第一次push到服务器上了。因为之前已经设置好了git hook，所以可以在服务器上的<code>deployment/rss</code>看到项目的代码更新了。</p><h2>使用supervisor管理进程</h2><p><code>supervisor</code>是Linux中非常好用的进程管理工具，我们将使用它和Nginx一起来组成我们的服务的部署。</p><ol><li><p>安装supervisor：<code>pip install supervisor</code> 或者 <code>sudo apt-get install supervisor</code></p></li><li><p>创建一个目录来装supervisor的配置文件：<code>mkdir -p ~/local/etc/supervisord</code></p></li><li><p>创建superviosr的出要的配置文件：<code>touch ~/local/etc/supervisord.conf</code>，并加入如下内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[unix_http_server]</span><br><span class="line">file=/home/deploy/tmp/supervisor.sock</span><br><span class="line"> </span><br><span class="line">[supervisord]</span><br><span class="line">user=deploy</span><br><span class="line">logfile=/home/deploy/logs/user/supervisord.log</span><br><span class="line">logfile_maxbytes=50MB</span><br><span class="line">logfile_backups=10 </span><br><span class="line">loglevel=info</span><br><span class="line">pidfile=/home/deploy/local/run/supervisord.pid supervisord.pid)</span><br><span class="line"> </span><br><span class="line">[rpcinterface:supervisor]</span><br><span class="line">supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface</span><br><span class="line"> </span><br><span class="line">[supervisorctl]</span><br><span class="line">serverurl=unix:///home/deploy/tmp/supervisor.sock</span><br><span class="line"> </span><br><span class="line">[include]</span><br><span class="line">files = /home/deploy/local/etc/supervisord/*.ini</span><br></pre></td></tr></table></figure><p>其中我们都适用用户目录下创建的<code>local</code>，<code>logs</code>和<code>tmp</code>文件夹来装这些文件。</p></li><li><p>创建一个rss.ini的文件用来作为rss服务：<code>touch ~/local/etc/supervisord/rss.ini</code>，放入如下内容：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[program:rss]</span><br><span class="line">command=python2.7 /home/deploy/deployment/rss/diy/start.py</span><br></pre></td></tr></table></figure><p>其中，<code>start.py</code>是这个tornado项目的入口。</p></li><li><p>启动服务：<code>supervisord -c /home/deploy/local/etc/supervisord.conf</code>，因为用的是非默认的配置文件，这里指定相应的配置文件位置。</p></li><li><p>一旦我们在之后修改了项目push了之后，我们需要重新启动rss：<code>supervisorctl restart rss</code>，因此，为了方便，可以将这条命令加入项目git hooks中的<code>post-receive</code>文件末尾。</p></li></ol><h2>配置Nginx</h2><p>Nginx很好很强大，我们用它来做为我们的HTTP服务器。</p><ol><li><p>安装Nginx，这里，我们适用从源代码安装Nginx，并配置一些log，pid等的目录到deploy的用户目录下，这里，写一个安装的脚本<code>install.sh</code>：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/src</span><br><span class="line">mkdir -p ~/tmp/nginx/fcgi ~/tmp/nginx/proxy ~/tmp/nginx/client</span><br><span class="line"></span><br><span class="line">cd ~/src</span><br><span class="line">curl -O  http://nginx.org/download/nginx-1.2.1.tar.gz</span><br><span class="line">tar -xzvf nginx-1.2.1.tar.gz</span><br><span class="line">cd nginx-1.2.1</span><br><span class="line"></span><br><span class="line">./configure   --prefix=$HOME/local/nginx  \</span><br><span class="line">--sbin-path=$HOME/local/sbin/nginx \</span><br><span class="line">--conf-path=$HOME/local/etc/nginx.conf  \</span><br><span class="line">--error-log-path=$HOME/logs/user/nginx/error.log \</span><br><span class="line">--http-log-path=$HOME/logs/user/nginx/access.log \</span><br><span class="line">--pid-path=$HOME/local/run/nginx/nginx.pid \</span><br><span class="line">--lock-path=$HOME/local/lock/nginx.lock \</span><br><span class="line">--http-client-body-temp-path=$HOME/tmp/nginx/client/ \</span><br><span class="line">--http-proxy-temp-path=$HOME/tmp/nginx/proxy/  \</span><br><span class="line">--http-fastcgi-temp-path=$HOME/tmp/nginx/fcgi/ \</span><br><span class="line">--with-http_flv_module \</span><br><span class="line">--with-http_ssl_module \</span><br><span class="line">--with-http_gzip_static_module</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>在Nginx的安装过程中会列出这些配置信息：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Configuration summary</span><br><span class="line">  + using system PCRE library</span><br><span class="line">  + using system OpenSSL library</span><br><span class="line">  + md5: using OpenSSL library</span><br><span class="line">  + sha1: using OpenSSL library</span><br><span class="line">  + using system zlib library</span><br><span class="line"></span><br><span class="line">  nginx path prefix: &quot;/home/deploy/local/nginx&quot;</span><br><span class="line">  nginx binary file: &quot;/home/deploy/local/sbin/nginx&quot;</span><br><span class="line">  nginx configuration prefix: &quot;/home/deploy/local/etc&quot;</span><br><span class="line">  nginx configuration file: &quot;/home/deploy/local/etc/nginx.conf&quot;</span><br><span class="line">  nginx pid file: &quot;/home/deploy/local/run/nginx/nginx.pid&quot;</span><br><span class="line">  nginx error log file: &quot;/home/deploy/logs/user/nginx/error.log&quot;</span><br><span class="line">  nginx http access log file: &quot;/home/deploy/logs/user/nginx/access.log&quot;</span><br><span class="line">  nginx http client request body temporary files: &quot;/home/deploy/tmp/nginx/client/&quot;</span><br><span class="line">  nginx http proxy temporary files: &quot;/home/deploy/tmp/nginx/proxy/&quot;</span><br><span class="line">  nginx http fastcgi temporary files: &quot;/home/deploy/tmp/nginx/fcgi/&quot;</span><br><span class="line">  nginx http uwsgi temporary files: &quot;uwsgi_temp&quot;</span><br><span class="line">  nginx http scgi temporary files: &quot;scgi_temp&quot;</span><br></pre></td></tr></table></figure></li><li><p>添加路径到PATH中：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH=/home/you/local/sbin:$PATH</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure></li><li><p>创建配置文件：<code>~/local/etc/nginx.conf</code>，在其中添加我们服务的配置：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#user  deploy;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">error_log /home/deploy/logs/user/nginx/error.log;</span><br><span class="line">pid /home/deploy/local/run/nginx/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    upstream rsstornado &#123;</span><br><span class="line">        server 127.0.0.1:8000;</span><br><span class="line">    &#125;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    access_log /home/deploy/logs/user/nginx/access.log;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout 65;</span><br><span class="line">    proxy_read_timeout 200;</span><br><span class="line">    sendfile on;</span><br><span class="line">    tcp_nopush on;</span><br><span class="line">    tcp_nodelay on;</span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_min_length 1000;</span><br><span class="line">    gzip_proxied any;</span><br><span class="line">    # Relevant docs: http://wiki.nginx.org/HttpGzipModule#gzip_types</span><br><span class="line">    # Enables compression for additional MIME-types besides &quot;text/html&quot;.</span><br><span class="line">    # &quot;text/html&quot; is always compressed.</span><br><span class="line">    gzip_types text/plain text/css text/xml</span><br><span class="line">               application/x-javascript application/xml</span><br><span class="line">               application/atom+xml text/javascript;</span><br><span class="line"></span><br><span class="line">    # Only retry if there was a communication error, not a timeout</span><br><span class="line">    # on the Tornado server (to avoid propagating &quot;queries of death&quot;</span><br><span class="line">    # to all frontends)</span><br><span class="line">    proxy_next_upstream error;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        # server_name  localhost;</span><br><span class="line">        # Allow file uploads</span><br><span class="line">        client_max_body_size 50M;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass_header Server;</span><br><span class="line">            proxy_set_header Host $http_host;</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Scheme $scheme;</span><br><span class="line">            proxy_pass http://rsstornado;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>upstream rsstornado</code>指向了我们的rss的端口。</p></li><li><p>之后使用<code>/home/deploy/local/sbin/nginx -t</code>来检查这些配置，期望的输出为：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx: the configuration file /home/deploy/local/etc/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /home/deploy/local/etc/nginx.conf test is successful</span><br></pre></td></tr></table></figure></li><li><p>运行服务：<code>/home/deploy/local/sbin/nginx</code></p></li></ol><p>如果一切顺利，这时，我们在浏览器中输入服务器对应的ip时就可以看到这个web app了。</p><h2>添加<code>A</code>纪录</h2><p>最后的话需要在自己的dns服务商中添加一条指向服务器ip的<code>A</code>距离，例如在 <a href="http://dns.he.net" target="_blank" rel="noopener">he.net</a> 中添加一条<code>A</code>记录即可。很快，就可以直接使用 <a href="http://rss.daozhang.info" target="_blank" rel="noopener">http://rss.daozhang.info</a> 访问这个app了。</p><h2>最后</h2><p>这样，我们就完成了这个server的配置。在我部署这个server的过程中，微信对应的RSS生成的解析实效了，我觉得是因为sogou在其url中添加了一个序列，这个序列是有AES算法得出来的，并且一段时间会换一个key来生成这个序列，所以我暂时也不知道怎么处理这个，有待进一步研究。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直在想把微信的公众号的文章导出为RSS阅读，方便阅读和减少对微信的依赖，后来看到
&lt;a href=&quot;https://github.com/zhu327/rss&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;zhu327/rss&lt;/a&gt; 这个项目，这是一个用来生成微博，微信公众号，知乎日报 RSS 的Web APP。
但是这个项目的demo部署在Red Hat的openshift上，
囿于对这个cloud的操作不是很熟，所以想着把这个项目重新部署到自己在DigitalOcean的机器上，就fork了这个项目开始啦！&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>树莓派启动时自动连接wifi</title>
    <link href="https://qiwihui.com/qiwihui-blog-16/"/>
    <id>https://qiwihui.com/qiwihui-blog-16/</id>
    <published>2018-09-09T21:31:11.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章的目的是为了配置树莓派，使其在启动时自动获取静态IP.</p><a id="more"></a><h2>启动并连接树莓派</h2><h4>1. 启动树莓派并找到其IP地址</h4><p>把树莓派用网线连接到路由器上，插上SD卡，打开树莓派电源，等大约90秒.<br>在Mac上打开命令行终端，输入<code>arp -a</code>命令，可以看到树莓派的ip地址为 <code>192.168.199.199</code>.当然也可以从路由器后台看到这个IP地址.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ arp -a</span><br><span class="line">? (169.254.99.51) at (incomplete) on en0 [ethernet]</span><br><span class="line">hiwifi.lan (192.168.199.1) at d4:ee:7:20:18:6e on en0 ifscope [ethernet]</span><br><span class="line">raspberrypi.lan (192.168.199.199) at f0:f6:1c:af:7a:28 on en0 ifscope [ethernet]</span><br></pre></td></tr></table></figure><h4>2. 使用SSH连接树莓派</h4><p>输入&quot;ssh <a href="mailto:pi@192.168.199.199" target="_blank" rel="noopener">pi@192.168.199.199</a>&quot;, 根据要求输入密码，默认为<code>raspberry</code>.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh pi@192.168.199.199</span><br><span class="line">pi@192.168.199.199s password: </span><br><span class="line">Linux qiwihuisrpi 3.18.7+ <span class="comment">#755 PREEMPT Thu Feb 12 17:14:31 GMT 2015 armv6l</span></span><br><span class="line"></span><br><span class="line">The programs included with the Debian GNU/Linux system are free software;</span><br><span class="line">the exact distribution terms <span class="keyword">for</span> each program are described <span class="keyword">in</span> the</span><br><span class="line">individual files <span class="keyword">in</span> /usr/share/doc/*/copyright.</span><br><span class="line"></span><br><span class="line">Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent</span><br><span class="line">permitted by applicable law.</span><br><span class="line">Last login: Fri Apr 17 14:45:28 2015 from 192.168.199.186</span><br></pre></td></tr></table></figure><h2>配置网络连接</h2><h4>1. 设置网络接口文件<code>/etc/network/interfaces</code></h4><p>编辑这个文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo nano /etc/network/interfaces</span><br></pre></td></tr></table></figure><p>添加如下内容：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line">auto eth0</span><br><span class="line">allow-hotplug eth0</span><br><span class="line">iface eth0 inet dhcp</span><br><span class="line"></span><br><span class="line">auto wlan0</span><br><span class="line">allow-hotplug wlan0</span><br><span class="line">iface wlan0 inet manual</span><br><span class="line"><span class="comment"># iface wlan0 inet dhcp # 如果想自动获取ip</span></span><br><span class="line">wpa-conf /etc/wpa_supplicant/wpa_supplicant.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置静态ip</span></span><br><span class="line">iface wlan0 inet static</span><br><span class="line">address 192.168.199.199</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 192.168.199.1</span><br><span class="line"></span><br><span class="line">iface default inet dhcp</span><br></pre></td></tr></table></figure><h4>2. 设置<code>wpa_supplicant.conf</code>配置文件</h4><p>编辑文件<code>wpa_supplicant.conf</code>设置连接的网络热点.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo nano /etc/wpa_supplicant/wpa_supplicant.conf</span><br></pre></td></tr></table></figure><p>为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev</span><br><span class="line">update_config=1</span><br><span class="line"></span><br><span class="line">network=&#123;</span><br><span class="line">    ssid=<span class="string">"YOUR_NETWORK_NAME"</span></span><br><span class="line">    psk=<span class="string">"YOU_NETWORK_PASSWORD"</span></span><br><span class="line">    proto=RSN</span><br><span class="line">    key_mgmt=WPA-PSK</span><br><span class="line">    pairwise=CCMP</span><br><span class="line">    auth_alg=OPEN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中:</p><ul><li><code>proto</code> 可以是 <code>RSN</code> (WPA2) 或者 <code>WPA</code> (WPA1).</li><li><code>key_mgmt</code> 可以是 <code>WPA-PSK</code> (大部分) 或者 <code>WPA-EAP</code> (企业网络)</li><li><code>pairwise</code> 可以是 <code>CCMP</code> (WPA2) 或者 <code>TKIP</code> (WPA1)</li><li><code>auth_alg</code> 常为 <code>OPEN</code>, 其他可选为 <code>LEAP</code> 和 <code>SHARED</code></li></ul><p>重启树莓派，之后就会自动连上wifi了.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章的目的是为了配置树莓派，使其在启动时自动获取静态IP.&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>理解python索引和切片</title>
    <link href="https://qiwihui.com/qiwihui-blog-15/"/>
    <id>https://qiwihui.com/qiwihui-blog-15/</id>
    <published>2018-09-09T21:30:14.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>许多初次接触Python的人对于索引都会有同样的反应：这太奇怪了。在Python的列表，字符串和条件语句中都充斥着索引，但在我们习惯他们之前，这些都会是我们程序的错误来源。因此，让我们硬着头皮上吧！</p><a id="more"></a><p>这片文章会写得很慢，为了解释一些基础和默认的东西。</p><p>我们会使用字符串切片举例，因为这事我们首先接触的，不过这对于列表切片和设定范围是一样的。我们有：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">'0123456789'</span></span><br></pre></td></tr></table></figure><p>其中第k个位置的字符为k。</p><p>我们使用如下方式对a进行切片：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = a[start:stop:step]</span><br></pre></td></tr></table></figure><p>或者直接地：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'0123456789'</span>[start:stop:step]</span><br></pre></td></tr></table></figure><p>在Python中，字符串和指向字符串的变量都是对象，所以都可以进行切片（事实上，Python中所有东西都是对象：数字，变量，字符串，函数，文件）。</p><p>有三件事情需要记住：</p><ol><li><code>start</code> 是我们想要的第一项（当然）</li><li><code>stop</code> 是我们第一个不想要的项</li><li><code>step</code> 可以是正整数，也可以是负数，定义了向前（从第一个位置到向末尾）还是向后（从最后一个位置向开始位置）索引。</li></ol><p>一个小提醒：但我们学习python之外其他语言的时候，stop的定义是Python索引和切片在熟悉其语言的程序员看来如此奇怪的原因之一。在大部分计算机语言中，stop应该是“我们需要的最后一项”。不管这个定义是否比其他语言更好或者更坏，Python的确是不寻常的一种语言。</p><p>在索引中使用负数是python另一个奇怪的特性。在大部分C衍生的语言（C/C++/C#，Java,，Javascript等）中，负数索引是不合法的，因为索引表示从字符串初始内存地址的偏移，所以负数索引会指向字符串开始位置之前的位置（更详细的请参见这篇博客：<a href="http://blog.daozhang.info/Why-does-indexing-begin-at-0/" target="_blank" rel="noopener">为什么python中索引从0开始</a>）。然而，Python并不是唯一使用负数索引的语言，比如，<a href="http://www.tutorialspoint.com/perl/perl_arrays.htm" target="_blank" rel="noopener">Perl</a>像python一样使用负数索引来表示从字符串末尾开始的位置；<a href="http://www.r-tutor.com/r-introduction/vector/vector-index" target="_blank" rel="noopener">R</a>语言面向统计，A[-i]表示所有除第i位置的值。不过，只有很少的语言在任意情况下使用负数索引。</p><p>现在让我们回到Python索引上。</p><p>** 使用正数和负数索引 **</p><p>我们可以使用正整数表示字符串中的位置，由字符串开头从0开始计数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = <span class="string">"my mistress' eyes are nothing like the sun"</span></span><br><span class="line">     ^         ^                              ^</span><br><span class="line">    b[<span class="number">0</span>]      b[<span class="number">10</span>]                          b[<span class="number">41</span>]</span><br></pre></td></tr></table></figure><p>我们用len()函数来获取一个字符串的长度。因此，b有42个字符，故len(b)=42。因为b最后一个字符是<code>b[41]</code>，所以<code>len(b)</code>比b字符串最后位置索引多1。</p><p>有些时候这对从字符串末尾开始找字符是很有帮助的。所以我们用负数，从字符串末尾开始计数，即从-1（不是0）：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = <span class="string">"my mistress' eyes are nothing like the sun"</span></span><br><span class="line">     ^         ^                              ^</span><br><span class="line">   b[<span class="number">-42</span>]   b[<span class="number">-32</span>]                          b[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>从末尾看的最后一个字符串是b[-42]，那么它前面的位置会是-len(b)-1 = -43。</p><p>所以，在这个例子中<code>len(b) = 42</code>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b[<span class="number">0</span>]        = b[-len(b)] = b[<span class="number">-42</span>] = <span class="string">'m'</span></span><br><span class="line">b[len(b)<span class="number">-1</span>] = b[<span class="number">-1</span>]      = b[<span class="number">41</span>]  = <span class="string">'n'</span></span><br><span class="line">b[<span class="number">10</span>]       = b[<span class="number">-32</span>]              = <span class="string">'s'</span></span><br></pre></td></tr></table></figure><p>并且一般地，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b[k]        = b[-len(b)+k]</span><br></pre></td></tr></table></figure><p>hmm, 这很令人疑惑。我们需要了解索引的一般机制，但是，我们不需要记住这些边界值，这些是python中默认的。</p><p>默认值是引用一个变量的时候，我们没有指定明确的值。这就和我们“默认地”称呼一位女性为女士(<a href="http://en.wikipedia.org/wiki/Ms." target="_blank" rel="noopener">Ms.</a>)一样。如果我们没有被告知需要称呼她为太太（Mrs.）或者小姐(Miss），或者如果我们忽略了实际的尊称，我们降退回到“默认”值。Python对于很常用的<code>start</code>, <code>stop</code> and <code>step</code>都有默认值。</p><p>** 如果<code>step</code>是正数，我们向前移动（如果<code>step</code>值为空，则默认为+1）**</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[<span class="number">2</span>:<span class="number">6</span>] = <span class="string">'0123456789'</span>[<span class="number">2</span>:<span class="number">6</span>:<span class="number">1</span>] = <span class="string">'2345'</span></span><br></pre></td></tr></table></figure><p>如上例，我们想要的第一个值在第二个位置，第一个不想要的在第6个位置。</p><p>更进一步，我们从字符串末尾开始看：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[<span class="number">-8</span>:<span class="number">-4</span>] = <span class="string">'0123456789'</span>[<span class="number">-8</span>:<span class="number">-4</span>:<span class="number">1</span>] = <span class="string">'2345'</span></span><br></pre></td></tr></table></figure><p>我们想要的第一个值是从后数第8个（2），第一个不想要的是从后数第4个（6）。</p><p>所以，对于任意正数<code>step</code>，我们有如下的默认值：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">     |-&gt; -&gt; -&gt;|</span><br><span class="line">a = <span class="string">'0123456789'</span></span><br><span class="line">     ^         ^</span><br><span class="line">  start:<span class="number">0</span>   stop: len(a), i.e, 超出了字符串的末尾的位置</span><br></pre></td></tr></table></figure><p>所以：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[:]    = a[<span class="number">0</span>:len(a):<span class="number">1</span>] = <span class="string">'0123456789'</span> <span class="comment"># a +1 step 默认</span></span><br><span class="line">a[::<span class="number">2</span>]  = a[<span class="number">0</span>:len(a):<span class="number">2</span>] = <span class="string">'02468'</span>      <span class="comment"># 所有偶数位置</span></span><br><span class="line">a[<span class="number">1</span>::<span class="number">2</span>] = <span class="string">'13579'</span>                      <span class="comment"># 所有奇数位置</span></span><br><span class="line">a[::<span class="number">3</span>]  = <span class="string">'0369'</span>                       <span class="comment"># 所有3的倍数位置</span></span><br></pre></td></tr></table></figure><p>所以，只要我们从字符串头部或者尾部使用切片，Python都会使用默认值。</p><p>** 如果<code>step</code>是负数，而我们从后往前数**</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[<span class="number">6</span>:<span class="number">2</span>:<span class="number">-1</span>] = <span class="string">'0123456789'</span>[<span class="number">6</span>:<span class="number">2</span>:<span class="number">-1</span>] = <span class="string">'6543'</span></span><br></pre></td></tr></table></figure><p>我们需要的第一个值在第六个位置，不需要的第一个值在第二个位置。</p><p>或者进一步，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[<span class="number">-4</span>:<span class="number">-8</span>:<span class="number">-1</span>] = <span class="string">'0123456789'</span>[<span class="number">-4</span>:<span class="number">-8</span>:<span class="number">-1</span>] = <span class="string">'6543'</span></span><br></pre></td></tr></table></figure><p>我们想要的第一个值是从后数第4个（6），第一个不想要的是从后数第8个（2）。</p><p>注意到我们可以在索引中使用正数或者负数，以及从前或者从后搜寻字符串，所以我们甚至可以将它们混合起来使用：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[<span class="number">6</span>:<span class="number">-8</span>:<span class="number">-1</span>] = <span class="string">'6543'</span></span><br><span class="line">a[<span class="number">-4</span>:<span class="number">2</span>:<span class="number">-1</span>] = <span class="string">'6543'</span></span><br></pre></td></tr></table></figure><p>有时候这样的混合式非常方便的：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url = <span class="string">'&lt;a href="http://udacity.com"&gt;'</span>[<span class="number">9</span>:<span class="number">-2</span>]</span><br><span class="line">    = <span class="string">'http://udacity.com'</span></span><br></pre></td></tr></table></figure><p>我们需要记住的是使用负数索引不意味着我们就是向后移动，只是我们从字符串末尾开始索引。向前还是向后是仅由step变量的符号决定的。</p><p>为了向后移动，我们需要在我们的意识中反转这个字符串：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">     |&lt;- &lt;- &lt;-|</span><br><span class="line">a = <span class="string">'0123456789'</span></span><br><span class="line">    ^         ^</span><br><span class="line">    ^      start:<span class="number">-1</span></span><br><span class="line">stop:在字符串开始位置之前的位置</span><br></pre></td></tr></table></figure><p>所以：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[::<span class="number">-1</span>] = a[<span class="number">-1</span>::<span class="number">-1</span>] = <span class="string">'9876543210'</span> <span class="comment"># 我们只是学习如何反转字符串</span></span><br><span class="line">a[::<span class="number">-2</span>] = a[<span class="number">-1</span>:-len(a)<span class="number">-1</span>:<span class="number">-2</span>] = <span class="string">'97531'</span></span><br><span class="line">a[::<span class="number">-3</span>] = a[<span class="number">-1</span>:-len(a)<span class="number">-1</span>:<span class="number">-3</span>] = <span class="string">'9630'</span></span><br></pre></td></tr></table></figure><p>再一次，只要我们从字符串的头部或者尾部对字符串切片，我们可以使用空的start和stop变量，Python会使用默认值。</p><p>只用6个字符就反转了一个字符串，厉害吧！可惜的是这个只在Python中有用，许多其他的语言并不支持这种方式。这类问题只是用来是我们熟悉这种结构，不只是在Python中，也包括其他语言在内。因此，考虑需要反转字符串的这类问题（比如回文问题）可以让我们学习如何使用循环，索引，并且尝试不同切片来解决这些问题。这样，你就有两手准备了。</p><hr><p>所以现在，我们已经掌握了Python的索引，应该能明白底下这些了：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'0123456789'</span>[<span class="number">8</span>:<span class="number">2</span>:<span class="number">-2</span>]   = <span class="string">'864'</span></span><br><span class="line"><span class="string">'0123456789'</span>[<span class="number">8</span>:<span class="number">-8</span>:<span class="number">-2</span>]  = <span class="string">'864'</span></span><br><span class="line"><span class="string">'0123456789'</span>[<span class="number">-2</span>:<span class="number">2</span>:<span class="number">-2</span>]  = <span class="string">'864'</span></span><br><span class="line"><span class="string">'0123456789'</span>[<span class="number">-2</span>:<span class="number">-8</span>:<span class="number">-2</span>] = <span class="string">'864'</span></span><br></pre></td></tr></table></figure><p>Good luck!</p><p>原文在<a href="http://forums.udacity.com/questions/2017002/python-101-unit-1-understanding-indices-and-slicing" target="_blank" rel="noopener">这儿</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;许多初次接触Python的人对于索引都会有同样的反应：这太奇怪了。在Python的列表，字符串和条件语句中都充斥着索引，但在我们习惯他们之前，
这些都会是我们程序的错误来源。因此，让我们硬着头皮上吧！&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>为什么python中索引从0开始</title>
    <link href="https://qiwihui.com/qiwihui-blog-14/"/>
    <id>https://qiwihui.com/qiwihui-blog-14/</id>
    <published>2018-09-09T21:29:28.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>在Python中字符串索引从0开始而不是从1开始是合乎逻辑的选择，因为python是用C语言写的，做为C的主要数据结构，数组是从0开始索引的。这在C中是很基础的，以至于如果改变索引从1开始将会需要大量的工作。</p><a id="more"></a><p>** 1) 那么下一个问题：为什么在C中索引从0开始？**</p><p>C语言中的主要数据结构是数组，数组时一些相同类型元素的集合。在C中，字符串时字符数组，如果你想存储字符串“HELLO”，C会在内存中寻找一块连续的地方存储这些字符。比如，从内存地址7000开始存储，那么这个字符串在内存中的地址就是：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="number">7000</span> <span class="string">'H'</span></span><br><span class="line"><span class="number">7001</span> <span class="string">'E'</span></span><br><span class="line"><span class="number">7002</span> <span class="string">'L'</span></span><br><span class="line"><span class="number">7003</span> <span class="string">'L'</span></span><br><span class="line"><span class="number">7004</span> <span class="string">'O'</span></span><br><span class="line">7005 '/0'</span><br></pre></td></tr></table></figure><p>你可能会问：最后一个’/0’是什么？这个不是字符串&quot;HELLO&quot;的一部分。这个称作空值终止字符串。我们知道字符串从7000开始，但是我们不知道在哪里结束，因此C在字符串的末尾加了一个空值使得我们遍历字符串时知道它在哪里结束。让我们再回到原来的问题。</p><p>让我们认真看一下这些字符的地址，如果我们想要这个字符串的第一个字符，我们要做的就是得到这个字符串的初始内存地址。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">'H'</span> 地址在 <span class="number">7000</span> 因为字符串从 <span class="number">7000</span> 开始</span><br></pre></td></tr></table></figure><p>如果我们要字符’E’，只需要地址偏移加1:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">'E'</span> is at <span class="number">7000</span>+<span class="number">1</span></span><br></pre></td></tr></table></figure><p>我们可以是用偏移来得到所以的字符：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">'H'</span> is at <span class="number">7000</span> + <span class="number">0</span></span><br><span class="line"><span class="string">'E'</span> is at <span class="number">7000</span> + <span class="number">1</span></span><br><span class="line"><span class="string">'L'</span> is at <span class="number">7000</span> + <span class="number">2</span></span><br><span class="line"><span class="string">'L'</span> is at <span class="number">7000</span> + <span class="number">3</span></span><br><span class="line"><span class="string">'O'</span> is at <span class="number">7000</span> + <span class="number">4</span></span><br></pre></td></tr></table></figure><p>啊哈！看到了吗？我们很自然地会使得索引等于便宜，这样我们就可以找到数组中的所有元素。如果我们赋值如下：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">greeting = 'HELLO'</span><br></pre></td></tr></table></figure><p>则</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">greeting[<span class="number">0</span>] = <span class="string">'H'</span></span><br><span class="line">greeting[<span class="number">1</span>] = <span class="string">'E'</span></span><br><span class="line">greeting[<span class="number">2</span>] = <span class="string">'L'</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>所以，这是我们问题的回答。字符从0开始索引因为这表示了相对于字符串开始位置的偏移。</p><p>** 2) 我还是认为数组的第一个元素应该从1开始，这样错了吗？**</p><p>不，一点也不。有很多语言都会设计成这样：字符串的第一个元素的位置必须为1。一个很常见的例子是Matlab，它的索引从1开始。在这个例子中，Matlab是基于Fotran的，Fotran的数组索引从1开始，所以，改变时没有意义的。</p><p>看到趋势了吗？语言往往从他们的父辈中继承许多基本的特性。由C衍生出来的语言倾向于从0开始索引，比如C++，objective C，Java，Python， Perl，Javascript和其它许多语言，<a href="http://en.wikipedia.org/wiki/List_of_C-based_programming_languages" target="_blank" rel="noopener">看这</a>。有Fortran衍生出来的语言则往往从1开始所以，就像Matalb和SimScript一样。</p><p>当然，这些继承不是必须的。比如，相对于其他许多C衍生的语言，Python使用缩进来表示结构，而不是花括号。恕我直言，这很不寻常，但也不失为一个好选择，因为为了清楚，结构里的语句也会缩进，从这点看，花括号或者其他分隔符都显得多余了。</p><p>** 3) 哪一个更好呢，从0开始还是从1开始？**</p><p>都不好。如果需要，使用另一个索引开始值也是相对简单的。然而，有一些算法自然是从0或者1开始的，没有其他的，所以对于这些情况下，在实现上略有不同。比如，二叉查找树从1开始，所以，在Python中，我们可以使用一个从0开始的数组活着列表，然后忽略第一个元素。在这篇<a href="http://forums.udacity.com/questions/2006322/where-python-is-illogical?page=1&amp;focusedAnswerId=2022504#2022504" target="_blank" rel="noopener">博客</a>中，其中描述了我们可以强制C中的数组从1开始索引，以及C开发者社区是怎样收到一本趋势读者也这样做的书。</p><p>原文在<a href="http://forums.udacity.com/questions/100086491/why-does-indexing-begin-at-0?page=1&amp;focusedAnswerId=100086607#100086607" target="_blank" rel="noopener">这儿</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Python中字符串索引从0开始而不是从1开始是合乎逻辑的选择，因为python是用C语言写的，做为C的主要数据结构，数组是从0开始索引的。这在C中
是很基础的，以至于如果改变索引从1开始将会需要大量的工作。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Git 小结</title>
    <link href="https://qiwihui.com/qiwihui-blog-13/"/>
    <id>https://qiwihui.com/qiwihui-blog-13/</id>
    <published>2018-09-09T21:28:43.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>整理自<a href="http://www.cnblogs.com/tugenhua0707/p/4050072.html" target="_blank" rel="noopener">手把手教你用git</a>.</p><a id="more"></a><ol><li><code>git reflog</code> 查看历史记录的版本号id</li><li>Discard:<ul><li><code>git reset --hard HEAD^</code></li><li><code>git reset --hard HEAD~100</code></li><li><code>git reset --hard &lt;one commit&gt;</code></li></ul></li><li><code>git checkout -- &lt;file&gt;</code><ul><li>修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。</li><li>另外一种是第一次修改已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。</li></ul></li><li>暂存区 -&gt; 工作区<ul><li><code>git reset HEAD &lt;file&gt;</code></li><li>HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</li></ul></li><li>push<ul><li><code>git remote add origin https://github.com/username/project_name.git</code> 关联一个远程库</li><li><code>git push –u origin master</code> (第一次要用-u, 以后不需要)</li></ul></li><li>分支管理策略:<ul><li>通常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息。可以使用带参数 –no-ff来禁用”Fast forward”模式。<code>git merge --no-ff -m &quot;comments&quot; &lt;branch_name&gt;</code></li><li>分支策略：首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</li></ul></li><li><code>git stash</code>: 可以把当前工作现场 ”隐藏起来”，等以后恢复现场后继续工作。<ul><li><code>git stash list</code>: 查看</li><li>恢复：<ol><li><code>git stash apply</code> 恢复，恢复后，stash内容并不删除，你需要使用命令<code>git stash drop</code>来删除。</li><li>另一种方式是使用<code>git stash pop</code>,恢复的同时把stash内容也删除了。</li></ol></li></ul></li><li>多人协作：<ul><li>推送分支：<ol><li>master分支是主分支，因此要时刻与远程同步。</li><li>一些修复bug分支不需要推送到远程去，可以先合并到主分支上，然后把主分支master推送到远程去。</li></ol></li><li>抓取分支：<ol><li>push非master分支(e.g. dev)：<code>git checkout –b dev origin/dev</code>, edit something, <code>git push origin dev</code></li><li>另一个同伴更新：<code>git branch --set-upstream dev origin/dev</code>, <code>git pull</code>, edit something, <code>git push origin dev</code></li></ol></li><li>协作模式：<ol><li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改.</li><li>如果推送失败，则因为远程分支比你的本地更新早，需要先用git pull试图合并。</li><li>如果合并有冲突，则需要解决冲突，并在本地提交。再用<code>git push origin &lt;branch-name&gt;</code>推送。</li></ol></li></ul></li><li>delete remote branch<ul><li><code>git push origin —delete &lt;branch_name&gt;</code></li></ul></li><li>get remote branch locally<ul><li><code>git branch --set-upstream dev origin/dev</code></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理自&lt;a href=&quot;http://www.cnblogs.com/tugenhua0707/p/4050072.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;手把手教你用git&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>没有智能手机的第一天</title>
    <link href="https://qiwihui.com/qiwihui-blog-12/"/>
    <id>https://qiwihui.com/qiwihui-blog-12/</id>
    <published>2018-09-09T21:27:54.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>在停止博客的一个多月时间里，我除了上班的五天白天，再加上周末出去爬山的两天，剩下的时间很多都花在了我那只智能手机上，微信，QQ，G+，以及一些有节操和没节操的应用和游戏，这一个多月的时间就这样荒芜的度过了。</p><a id="more"></a><p>直到我暂停出行的计划，更多地和朋友接触，我才觉得，智能手机在给我带来很大方便的同时，也使得我的生活变得狭窄，交际变得狭隘。于是我决定：离开智能手机一到两个月，就像去年手机坏掉一样。</p><h2><strong>第一天</strong></h2><p>我把手机交给了朋友保管，在微信上和QQ上留下了电话和邮箱，开始了我一个月的非智能生活。第一天是很艰难的，尤其是在突然离开手机之后，我获取信息的方式直接转移到了电脑，这就意味着我要很多时候开着电脑，背单词，阅读文章，收邮件等等都从手机向电脑迁移，无可选择。</p><p>第一天计划的实施还是有点水分的，总是不自觉地拿起那台很古老的手机，打开又关闭，才能继续回来学习工作，然后在iPad上上了一会微信，然后删了微信，整理了所有的不需要的会上瘾的软件，这才算是正式开始了。</p><p>理了头发表决心。</p><h2><strong>计划</strong></h2><p>在接下来的一两个月的时间里，计划是这样的：</p><ul><li>单词 &gt;100个/天，英文文章&gt;5个/天，有扇贝网站管理。</li><li>linux + python + mysql</li><li>《一个陌生女人的来信》+《Lovely bone》(English) + 《小王子》等</li><li>锻炼： 开始我的为其50周的马拉松训练计划。</li><li>健康管理： 爬，坐，走，跑…</li><li>华山之行（九月份）。</li></ul><h2><strong>目标</strong></h2><blockquote><p>尽最大的诚意，但不知道何时会消失，如果可以，就不要<strong>再试一次</strong>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在停止博客的一个多月时间里，我除了上班的五天白天，再加上周末出去爬山的两天，
剩下的时间很多都花在了我那只智能手机上，微信，QQ，G+，以及一些有节操和没节操
的应用和游戏，这一个多月的时间就这样荒芜的度过了。&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="https://qiwihui.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="https://qiwihui.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Seek, think then speak</title>
    <link href="https://qiwihui.com/qiwihui-blog-11/"/>
    <id>https://qiwihui.com/qiwihui-blog-11/</id>
    <published>2018-09-09T21:27:20.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>“Seek, think then speak”，这是我在我的<a href="https://twitter.com/Weihui_Q" target="_blank" rel="noopener">Twitter</a>上的签名，也是我在日常生活和工作中一个做事的基本准则。当自己得到一个消息，或者开始一个新的任务的时候，不是下意识地就相信这个消息，开始这个任务，而是要经过这三步过程之后，得出自己的结论，才开始行动。</p><a id="more"></a><h2><strong>Seek</strong></h2><p>探索，或者说是寻求，就是当你得到这个消息的时候，不是盲目地相信，而是先开始收集和甄别资料。在这个信息化一直信息爆炸的时代，越来越多的误导和虚假消息充斥在我们的身边，新闻电视，媒体资讯，社交网络，信息方便的同时也可能是误导和虚假消息滋生的温床。信息本无对错，只是当它们被少数人利用，曲解的时候，信息的对错才开始变得有利可图。</p><h2><strong>Think</strong></h2><p>思考，结合自己的知识背景和收集到的信息，思考信息的对错，以及其中个所包含的其他有价值的信息，这是一步非常重要的过程。善恶只在一念之间，这一念就是你的思考，你的想法。思考，可以是道理更深刻，事物更透彻，思考的好处不言而喻，古今之集大成者，莫不是善于思考的人。</p><h2><strong>Speak</strong></h2><p>发言，又或者可以是行动（Move），就是在思考之后表达自己的见解，采取一定的行动支持这个见解，以达到说服自己，说服别人，是别人达成对你的共识，就如同演讲家和行动派表现出来的一样。</p><p>我更喜欢诸如Twitter一类的自由开放社交工具，一个重要的原因是消息的对冲。QQ，微信之类的熟人社交，消息相对封闭，而且熟人会弱化我们对消息的思考，又如微博，却因别有用心的控制儿失去了本来的对冲能力。但这种情况发生的时候， “Seek，think then speak” 就变更加重要了。比如在MH370消失的三四后，微博上开始有人谣传MH370安全返航，微博上很快澄清，儿微信圈和QQ圈就无法及时跟上，seek在这个过程中让我没有轻易相信这这不实的信息。</p><p>Speak, 在这个容易因为言获罪的时期，发言和行动变得愈加重要。沉默是金，那是因为真理，对于非正义，speak才是真理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;“Seek, think then speak”，这是我在我的&lt;a href=&quot;https://twitter.com/Weihui_Q&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Twitter&lt;/a&gt;
上的签名，也是我在日常生活和工作中一个做事的基本准则。当自己得到一个消息，或者开始一个
新的任务的时候，不是下意识地就相信这个消息，开始这个任务，而是要经过这三步过程之后，
得出自己的结论，才开始行动。&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="https://qiwihui.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="观点" scheme="https://qiwihui.com/tags/%E8%A7%82%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>《平凡的世界》与平凡的世界</title>
    <link href="https://qiwihui.com/qiwihui-blog-10/"/>
    <id>https://qiwihui.com/qiwihui-blog-10/</id>
    <published>2018-09-09T21:26:49.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>我今天要去两个书店淘书，万圣园和蓝羊书坊，便就想起了去年八月读过的小说《平凡的世界》。小说是万学教育的老师推荐的，在刚开始工作的第二个月了就发奋四个星期读完了，时至今日已经过去快一年了，可书中的许多情节依旧历历在目。</p><a id="more"></a><h2><strong>书中的故事</strong></h2><p>《平凡的世界》讲述了以孙少安和孙少平为代表的普通人在大时代历史进程中走过的艰难曲折的道路。时间在上个实际70到80年代，从混乱到改革开放的时期，时代的变革深刻地影响这每一代人的命运。</p><p>哥哥少安一直在家劳动，与村支书田福堂的女儿田润叶青梅竹马，两人互有爱慕之心，却遭到田福堂的反对，经过痛苦的煎熬，少安与山西勤劳的姑娘秀莲结婚，润叶也只能含泪与倾慕她的李向前结婚，改革开放后，机灵的少安看到机会，先是带领生产对实施责任制，后又进城拉砖，用赚的钱办砖窑，成为冒尖户。</p><p>少平原来在县城高中读书，毕业后回乡做了一名老师，但他没有消沉，与县革委副主任田福军女儿田晓霞建立了友情，青春的梦想和追求也激励着他到外面去“闯荡世界”，他从漂泊的揽工汉成为正式的建筑工人，最后又获得了当煤矿工人的好机遇，而田晓霞毕业后也到省城成为了一名记者。在两人产生了强烈的感情时候，田晓霞却因在抗洪采访中为抢救灾民光荣牺牲，少平悲痛不已。后来少平在一次事故中毁容，他没有被不幸压跨，重新回到矿山迎接新的挑战。</p><h2><strong>平凡的世界里</strong></h2><p>《平凡的世界》是一部很长的小说，但是文字十分流畅，很快就可以带入我们进入这两个在黄土高原上闪亮的两个人的故事。在那个时代变革明显的时代，个人的命运也和时代的命运紧紧地联系在一起，与此同时，个人的追求和梦想也在一步一步地影响这他们的轨迹。少安看准了时代的先机，少平追求不一样的外面世界，这也深深地影响他们的命运和感情。</p><p>他们的感情都有着悲剧性的一面。少安与田润叶，少平与田晓霞，最终没能在一起，甚是惋惜。书中在许多细节上的描写令人感动，比如少平与少安相约两年之后再相见的那段，以及少平在得知田晓霞牺牲之后的感情变化，让人心中为之而动。</p><p>我喜欢书中提到的叶赛宁的一首诗：不惋惜，不呼唤，我也不啼哭……金黄的落叶堆满我心间，我已经不再是青春少年……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我今天要去两个书店淘书，万圣园和蓝羊书坊，便就想起了去年八月读过的小说《平凡的
世界》。小说是万学教育的老师推荐的，在刚开始工作的第二个月了就发奋四个星期读完
了，时至今日已经过去快一年了，可书中的许多情节依旧历历在目。&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="https://qiwihui.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="https://qiwihui.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>扇贝300天小记：坚持的力量</title>
    <link href="https://qiwihui.com/qiwihui-blog-9/"/>
    <id>https://qiwihui.com/qiwihui-blog-9/</id>
    <published>2018-09-09T21:25:12.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>到今天，我已经在<a href="http://www.shanbay.com" target="_blank" rel="noopener">扇贝</a>网上完成了300+天的背单词和阅读文章, 单词量虽然不算很多，但是在这过程中的感想还是值得分享的。</p><a id="more"></a><p>我喜欢道家之数“三”，道家曰：一生二，二生三，三生万物。天下之事情有三而生，即是刚刚开始，故而在300天左右的时候是很适合分享的。</p><h2><strong>起因和坚持的动力</strong></h2><p>背单词的最初起因里带有种愤，气愤，大体就是成为前女友眼中的“极品前任”。虽然这在最出的几天很激励，但是这种感觉很快就消失了，之间有一段迷茫期，不知到自己为什么背单词。直到有一天我找到了另一种坚持，一个自己一直想去的地方：Multnomah Falls，这是在美国Oregon这州的一个瀑布，我被她绚丽的落差所折服，有生之年不然是要前往的，虽然觉得去旅游和背单词不是很搭边，没什么联系。</p><p>就是这个，犹如在远方等待着我的少女，让我坚持到了现在：</p><p><img src="https://user-images.githubusercontent.com/3297411/45277890-077a9600-b4fd-11e8-936b-5e6e4d6f98a5.jpg" alt="06-multnomahfalls"></p><h2><strong>方法</strong></h2><p>扇贝网是我知道的为数不多的几个背单词的网站，除了单词，还有新闻文章，书籍，以及一起背单词的小组和论坛，这在一定程度上激励着你一直坚持背下去，小组的作用更加的明显，不打卡就踢人的制度很合适。对单词的单词的理解程度也完全靠自己的自觉。</p><h2><strong>感受</strong></h2><p>背单词最大的感受是你不能只背单词，只背单词如同嚼蜡，刚开始就会觉得很舒服，没有营养又损害身体，带来的效果也很小。单词背的同时结合着文章的阅读效果是很明显的，以前老师常说的在语境中理解单词的含义单体就是这个意思。其次是要让自己处在一种英语的氛围中，可以用英语阅读写文章，使用英文和朋友交流，使用英文的办公环境…如此种种，都是很有效果的。再者，别人和自己的经验告诉我：背单词应该是意见很快乐的事情，如果在这个过程过程中觉得很痛苦，那么是应该考虑一下自己的方法了。</p><p>李笑来在《把时间当作朋友中》中提到了背单词的方法：</p><blockquote><p>在背单词的时候，事实上，在做所有类似的必须记住大量信息的工作的时候，一定要想办法由衷地把这件事当成一件快乐的事情来做。</p><p>我的一个朋友曾跟我分享他的做法：当年他终于搞明白要拿到奖学金就得获得GRE高分的时候，背单词量要求吓了一跳。他说，他用两天才说服自己这应该是件快乐的事情。</p><p>一共要搞定20000个单词，而因此可能获得的奖学金是40000美元左右 且连续4年没有失业的可能，那么每个单词就值20元人民币，这还只不过是算了一年的收入而已。</p><p>所以，他终于明白背单词是很快乐的，他每天都强迫自己背下200个单词，每在确定记住了一个单词前面画上一个勾时，他就想象一下刚刚数过一张20元人民币的钞票。每天睡觉的时候总感觉心满意足，因为今天又赚了4000块！</p></blockquote><p>在这样的坚持了300+天以后，我觉得在更多的地方都体会到了一个坚持力量（很鸡汤的一句话），但是确实是，坚持锻炼，或者开始每天/每两天更新一千字博客。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;到今天，我已经在&lt;a href=&quot;http://www.shanbay.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;扇贝&lt;/a&gt;网上完成了300+天的背单词和阅读文章
, 单词量虽然不算很多，但是在这过程中的感想还是值得分享的。&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="https://qiwihui.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="https://qiwihui.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="总结" scheme="https://qiwihui.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>One small story by Fan Zhang at GMIC 2014</title>
    <link href="https://qiwihui.com/qiwihui-blog-8/"/>
    <id>https://qiwihui.com/qiwihui-blog-8/</id>
    <published>2018-09-09T21:23:57.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>I attended GMIC 2014 in Beijing at May 5<sup>th</sup> and May 6<sup>th</sup>.GMIC is short for Global Mobile Internet Conference, and it is a really huge conference.I just want to share a small story I heard in the conference.</p><a id="more"></a><h2><strong>0x00</strong></h2><p>In WeTalk Stage, one of the 8 stages, Fan Zhang, who is the brain behind<a href="http://en.wikipedia.org/wiki/Midi_Music_Festival" target="_blank" rel="noopener">Midi Modern Music Festival</a>, gave us a speech: Listen to the Original Where Music is Eternal.In the speech, he shared us a song named “The Brightest Star in the Sky” of 2013 Shanghai Midi Festival(watch it <a href="https://www.youtube.com/watch?v=Z7qgMJCmAHs" target="_blank" rel="noopener">here</a>), and told us a story about the boywho was singing with tears at 2:31 in the video.</p><iframe width="560" height="315" src="//www.youtube.com/embed/Z7qgMJCmAHs" frameborder="0" allowfullscreen></iframe><p>The boy met his girlfriend when they are student in college,but they got separated after graduation and went back to their own hometown. It was the first time they saw each otherafter 2 years. When catching this song, the boy couldn’t stop crying with mixed feeling.</p><p>This is what music means that something in your deep heart and express your real feeling, I think.</p><p>I would like to go to Midi festival the next time in Beijing, and listen to this song.</p><h2><strong>0x01</strong></h2><p><a href="http://smileboxx.blogspot.com/2013/08/escape-plan-brightest-star-in-night-sky.html" target="_blank" rel="noopener">Here</a> is the song&quot;The Brightest Star in the Sky&quot; in English. Hope you like it.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;I attended GMIC 2014 in Beijing at May 5&lt;sup&gt;th&lt;/sup&gt; and May 6&lt;sup&gt;th&lt;/sup&gt;.
GMIC is short for Global Mobile Internet Conference, and it is a really huge conference.
I just want to share a small story I heard in the conference.&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="https://qiwihui.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="https://qiwihui.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>年度总结 - 2017年</title>
    <link href="https://qiwihui.com/qiwihui-blog-7/"/>
    <id>https://qiwihui.com/qiwihui-blog-7/</id>
    <published>2018-09-09T21:21:40.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>工作:</p><ul><li><p>安全方向；</p></li><li><p>大数据；</p></li><li><p>机器学习初学：线性回归，神经网路，SVM；</p></li><li><p>深度学习入门</p></li><li><p>语言：Python, iOS, Go</p></li><li><p>阅读/读书：非技术的书阅读较少，五本左右</p></li><li><p>知识整理系统：RSS, PinBoard -&gt; Pocket -&gt; IFTTT -&gt; Evernote记录，github分析</p></li><li><p>开源项目，维护乏力，hiwifi-ss</p></li><li><p>我的专长：</p><ul><li>数学基础：机器学习和深度学习有天然的优势</li><li>我的弱点：对于做事情的热度不够持久=&gt; 利用这点，每种学一段，交替进行</li><li>情绪管理：无法控制自己的情绪对于自己工作的影响，一度不知道怎么控制自己</li></ul></li></ul><p>目标：</p><ul><li>网路自由化和安全化：RSS，翻墙，去中心化运动，网络中立</li></ul><p>产品和实现</p><ol><li>机器学习和深度学习</li><li>Python</li><li>iOS, macOS开发</li><li>架构</li><li>生活：自我认知，恋爱，惰性</li><li>情绪影响工作</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工作:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;安全方向；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;大数据；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;机器学习初学：线性回归，神经网路，SVM；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;深度学习入门&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;语言：P
      
    
    </summary>
    
      <category term="生活" scheme="https://qiwihui.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="https://qiwihui.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="总结" scheme="https://qiwihui.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>年度总结 - 2016年，是忙碌而无知的一年</title>
    <link href="https://qiwihui.com/qiwihui-blog-6/"/>
    <id>https://qiwihui.com/qiwihui-blog-6/</id>
    <published>2018-09-09T21:21:03.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>2016年是毕业后觉得过得最快的一年，也是至今觉得过得最快的一年。因为&quot;忙碌&quot;和没有思考，我在这一年过得没有目标，没有计划。</p><a id="more"></a><h2>Ingress 和 Minecraft</h2><p>2016年主要玩了两款游戏：Ingress 和 Minecraft（我的世界）。在Ingress上花费了很多的夜晚时间，在 Minecraft 上花费了一些周末时间。</p><h3>Ingress</h3><p>入坑 Ingress 已经四年，今年重新捡起，从7月到11月，我用了五个月的时间从原来的8级升到了16级（游戏等级上线），时间是2016年11月30日23点58分，总计4，0000，000AP。16级，我的第一个念头是：<strong>Never Again</strong>，我再也不能16级了，可能再也不会半夜两三点仍然在路上活动，可能再也不会冻手冻脚地在寒风中画图，可能再也奔波几十公里去连一条 link，可能再也不会月走路330km… 但依旧会和队友一起做刷任务，做多重。每一次升级，都是一次never again 事情，但是这一次真的就never again 了。Ingress 的游戏经历回想过来也是像电影一样：入坑，摸索，渐熟，AFK，归来，重拾，融入，疯狂，最后归于平静。也许之后回想起来这一段时间，也会感叹一句：也曾经疯狂过。</p><p>P.S. 同一个号可以转阵营重置而再次16级，但是，你愿意背弃自己的信仰么？</p><h3>Minecraft</h3><p>我的世界很自由，所有的东西都可以自己构建，因此世界只限制于想象力。自己维护了一个 Minecraft 的服务器，和朋友共同建设了一个世界。</p><h2>开源项目贡献</h2><h3>hiwifi-ss</h3><p>我在8月1号开始维护开源项目：<a href="https://github.com/qiwihui/hiwifi-ss" target="_blank" rel="noopener">hiwifi-ss</a>, 这是一个基于前人工作做的极路由翻墙插件，主要完成了在新版本极路由上的界面更新和功能修复。因为工作和 Ingress 的原因，这个项目在10月底就暂时没有继续维护了。</p><p>还想做一些其他的项目和实现一些其他的想法，比如一个RSS在线阅读器。</p><h2>学习</h2><h3>技能</h3><p>2016年缺乏系统地学习。之前获取和记录知识的过程（书，RSS, 博客等 -&gt; Pocket暂存 -&gt; Evernote记录和归纳 -&gt; 博文输出）并没有很好的实行和保持，使得代码虽然会写，但是没有系统地去理解为什么，没有去理解怎样更好。拿搬砖来讲，只是回垒墙，还没有上升到造房子或者造更好的房子的程度。</p><h3>读书</h3><p>今年没有读太多的书，准确说很少，以至于在最近的一段时间明显感觉到粗口增加，思考迷茫。看的文章很碎，而且没有及时思考，使得这一年没有太多的思想收入。</p><h3>英语、日语</h3><p>最近一段时间的英语学习质量也明显下降，多次任务没有认真及时完成，总体感觉能力没有提升。日语学习中断，停滞不前。</p><h2>生活</h2><p>生活依旧是生活。</p><h3>夜</h3><p>今年喜欢上了星星，很多时间在晚上活动，很多时候熬夜到很晚不肯睡。其实这也没有什么不对。只是如无必要，不要晚睡。</p><h3>游</h3><p>2016年想去很多地方，然而总是错过，广州，深圳，杭州，上海，以及一直以来的衡山，都成为了今年的遗憾。唯一的努力是完成了十月计划而耽搁的日本之行，第一次出国成就达成。但是计划不足和日语能力也使得这次出行有些仓促，没有达到自己的预期。</p><h3>感情</h3><blockquote><p>逃避问题和冷漠处理问题都是感情的敌人。(来自一个人的反思)</p></blockquote><p>逃避可耻且没有用。然而一个人却可以做很多事情而不需要进行顾虑太多。</p><h3>社交</h3><p>有很多的时间花在了刷 Twitter 上，没事了刷，吃完饭刷，中午刷，晚上刷，甚至有时走路都在刷。认识了一些新朋友，但是除了游戏和社交软件上的对话，没有更多深入的交流了。</p><h2>总结和计划</h2><h3>总结</h3><p><strong>计划有余而行动不足</strong>，是这一年的总结。很多事情有了开始，但是没有很好地坚持下去</p><h3>2017年的计划</h3><blockquote><p>日拱一卒，功不唐捐。</p></blockquote><p>这是以后的每一年计划的一个宗旨：至少要坚持干完一件事情！每年都想做很多事情，但可能没有时间，也可能没有精力，不期待速成，但求每天都有进步。</p><p>详：</p><ol><li><strong>早睡</strong> 如无必要，不许晚睡。如果没有非要第二天完成的事情，不要晚睡。睡前完成阅读任务即可。</li><li><strong>早起</strong> 早起是一种习惯，坚持。早起之后可以做如下事情：静坐，总结前一天和活动和列举当天的任务，或者早起简单的运动。</li><li><strong>戒咖啡</strong> 原因很简单，咖啡影响节律控制和胃。</li><li><strong>每天阅读半小时</strong> 阅读指阅读除了技术书籍以外的书籍，每看完一本书都需要思考和总结。</li><li><strong>每周写总结</strong> 包括工作总结和非工作总结。</li><li><strong>每周一篇博客</strong> 技术博客或者其他内容博客，但是每月技术博客数量应该要多余其他博客数量。总结也好，记录也好，要有输出，才能进步。</li><li><strong>每天拍一张照片</strong> 简单，但是坚持，发在 Instagram 上。</li></ol><p>简：</p><ol><li>技术成长。</li></ol><ul><li>网络基础知识和操作系统知识；</li><li>全栈（开发，运维，产品等）知识构建；</li><li>语言：动态语言，函数语言和强类型语言；</li><li>维护开源项目；</li></ul><ol><li>知识记录，归纳和总结：（书，RSS, 博客等 -&gt; Pocket暂存 -&gt; Evernote记录和归纳 -&gt; 博文输出）</li><li>坚持锻炼身体，合理饮食。</li><li>学好日语。<strong>这是今年要坚持完成的一件事</strong>。</li><li>英语不落下。</li><li>完成一次旅行，登山。</li><li>学会独处。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2016年是毕业后觉得过得最快的一年，也是至今觉得过得最快的一年。因为&amp;quot;忙碌&amp;quot;和没有思考，我在这一年过得没有目标，没有计划。&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="https://qiwihui.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="https://qiwihui.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="总结" scheme="https://qiwihui.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>年度总结 - 我的2015, 做了很多事, 欠了很多债</title>
    <link href="https://qiwihui.com/qiwihui-blog-5/"/>
    <id>https://qiwihui.com/qiwihui-blog-5/</id>
    <published>2018-09-09T21:19:34.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>一句话总结2015年: 做了很多事, 欠了很多债。</p><a id="more"></a><h2><strong>2015年</strong></h2><p>年初三月离开了毕业后的第一份正式工作, 七月底加入<a href="http://www.qssec.com" target="_blank" rel="noopener">青松</a>, 中间的四个月从迷茫焦虑, 到完成第一次知识整合和补充, 算是一次小的飞跃。 在新团队的这半年是自己能力和知识增长最快的半年。</p><p>感谢一路陪伴的岩, 许多事情不再纠结, 更有勇气去做一件事情。</p><p>整理和输出的东西太少, Evernote 和 Pocket 上记录的文章基本未有效整理, 博客自上次更新已是半年, 这点需要改进。</p><p>个人项目上, COMICS项目, 微信RSS项目和自己的公众号(我都忘了叫啥了)相继停止了维护/更新。 开源项目基本维持在阅读和 fork 别人项目的水平上, 对开源项目的贡献不够。自己开发和信息收集的方法工具没有整理。</p><p>2015年阅书寥寥, 《三体》和《量子物理史话》是为数不多的能记住的, 倒是知乎上迄今645万字的阅读量确实令我咋舌, 读书的质和量都有待提高。</p><p>语言能力上, 英语继续保持之前的学习量, 只是意语刚开始没多久就放弃了。</p><p>每年都会学一项不一样的技能或者挑战一件不一样的事情, 2015年一个人背包旅行了一个月, 见识了江南的风景, 新增的技能就算滑雪了。相较于之前, 2015年的技能成长比较缓慢。</p><p>2015年半壮半胖得长了十斤, 体重达到了历史最高点, 这是一段时间失衡与调整的结果。 2016年需要停止增长, 增加体能和力量训练。</p><h2><strong>2016年目标</strong></h2><h3>个人能力成长上:</h3><ul><li>编程能力上, Python/Django 编程能力加强, 深入理解代码运行的底层机制;</li><li>计算机基础知识的补足, 主要是网络知识和数据结构, 算法知识等;</li><li>前端能力以及产品化能力;</li><li>系统化知识的学习方法和框架, 增加整理和输出;</li><li>利用自己掌握的资源, 建立信息收集和整合项目, 打造自己的工具。</li></ul><h3>生活上</h3><ul><li>一两项新的技能, 一项自我挑战, 一张共同的愿望清单;</li><li>乐观一些, 简单一些。</li></ul><p>2015年是变革与变化, 机遇和挑战。新的一年, 新的成长, 新的奋斗, 不变的梦想!</p><h2><strong>附录一下逗比的过去</strong>:</h2><ul><li><a href="/posts/3">年度总结 - 2014年的点点滴滴</a></li><li><a href="/posts/4">年度总结 - 过去的2013年</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一句话总结2015年: 做了很多事, 欠了很多债。&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="https://qiwihui.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="https://qiwihui.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="总结" scheme="https://qiwihui.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>年度总结 - 2014年的点点滴滴</title>
    <link href="https://qiwihui.com/qiwihui-blog-4/"/>
    <id>https://qiwihui.com/qiwihui-blog-4/</id>
    <published>2018-09-09T21:17:15.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>在2014年还有15天就结束的时候，总结一下自己在2014年的工作生活和学习。2014年的故事比2013年少，但是琐碎的学习项目和整理多了很多。</p><a id="more"></a><p>** 学习环境 **</p><ul><li>feedly: rss聚合阅读</li><li>Evernote: 做笔记</li><li>Pocket: 稍后阅读</li><li>Trello: 项目管理</li><li>blog: 知识整理和创造</li><li>基本实现Windows, Ubuntu, Android, Mac, iOS平台之间数据同步</li></ul><p>** Linux **</p><ul><li>bash脚本初步</li><li>Arch Linux安装和基本配置</li><li>Raspberry Pi: LAMP</li><li>gunicorn使用</li><li>nginx入门</li></ul><p>** Vim + Git **</p><ul><li>使用YCM</li><li>dotfile(e.g. .vimrc, …)备份以及工作环境快速配置</li><li>git以及github常用基础功能</li></ul><p>** C **</p><ul><li>2048 in C (其实没完成)</li><li>PDT(a tiny card game demo) in C</li></ul><p>** Python **</p><ul><li>PDT in python</li><li>初学Django</li><li>Virtualenv虚拟python环境</li><li>pip</li></ul><p>** Web **</p><ul><li>使用Jekyll</li><li>github pages</li><li>博客采用Markdown</li><li>Html5 + CSS3基础</li><li>OAuth 2.0</li><li>全平台Cross the Great Firewall</li><li>Tor</li><li>网络基础</li></ul><p>** Mac/iOS **</p><ul><li>Swift语言入门</li><li>AFNetworking框架</li><li>ShanbayWords.app Demo</li><li>SwiftWeather.app Demo</li><li>iOS Frameworks概览</li><li>cocoapods管理类库</li><li>Html5 web离线app</li></ul><p>** 读书 **</p><ul><li>《开源世界旅行手册》</li><li><em>Dive into Python3</em></li><li><em>Getting started with OAuth 2.0</em></li><li><em>Getting Real</em></li><li>《黑客与画家》</li><li>《算法概论》（* Algorithms *，PDV）</li><li>《一个陌生女人的来信》</li><li>《饥饿游戏》（I, II,III）</li><li>…</li></ul><p>** 设备 **</p><ul><li>2014年新入4台设备：（略）。</li></ul><p>** 生活 **</p><ul><li>六月初去了北戴河，然后是泰山，七月嵩山，恒山和九月西安、华山。</li><li>Color Run</li><li>庆幸只发烧了两天，继续保持。</li></ul><p>以上就像列家常一样把2014年能记得的东西都写了个遍，那么问题来了，挖掘机…不：</p><ol><li>很多事情不能及时记录：所有的事情更像是五月份之后做的，五月之前的基本没记住。</li><li>时间花销记录不清楚：总感觉事情多，但是却不知道时间用到哪边去了。</li><li>看的书太少：没有2013年多，成系统的书少，非技术书类少，2014年主要倾向于开发文档和碎片化的文章，对知识和认识的系统化贡献少。</li></ol><p>因此2015年在这写方面确实要改善和加强。故制定2015年的主要目标如下（比较宽的目标，无先后，要细分）：</p><ol><li><p>规划：</p><ul><li>每周有小结，三月一次书面记录和总结</li><li>日常时间花销记录（e.g. RescueTime）</li><li>学会记账</li><li>静坐和冥想（谁用谁知道！）</li><li>读书以及读书笔记，锻炼 -&gt; 100日行动</li></ul></li><li><p>学习：</p><ul><li>Python: 常见标准库的了解和重点学习</li><li>Swift: GUI基本设计，Cocoa Touch layer基本</li><li>网络基础</li><li>算法和数据结构：基本算法和数据结构的理解和掌握</li><li>数学知识的回顾和加强</li><li>英语加强，托福</li></ul></li><li><p>杂项</p><ul><li>继续未完成的旅行：衡山，以及青海。</li></ul></li></ol><p>2015年想来事情也是比较多的，加油！</p><p>Wait, wait! 虽然2015年还有15天到来，但是可以做的事情还是很多，好好想想，and期待惊喜的发生！</p><p>P.S. 明年总结的时候这个也会是比较二的一篇，除非我没有进步！</p><p>2013年的总结：<a href="/posts/3">年度总结 - 过去的2013年</a>。突然觉得这个好矫情啊!!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在2014年还有15天就结束的时候，总结一下自己在2014年的工作生活和学习。2014年的故事比2013年少，但是琐碎的学习项目和整理多了很多。&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="https://qiwihui.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="https://qiwihui.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="总结" scheme="https://qiwihui.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>年度总结 - 过去的2013年</title>
    <link href="https://qiwihui.com/qiwihui-blog-3/"/>
    <id>https://qiwihui.com/qiwihui-blog-3/</id>
    <published>2018-09-09T21:15:15.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>写在2013年到2014年还有不到一个月的时候, 对我第一年工作的状态有一个简单的描述, 每年都要给自己写一个年终总结。</p><a id="more"></a><h3>得</h3><ul><li>选择了和有共同目标的团队一起调研，奋斗的感觉真好。</li><li>选择了请假写论文，这样我可以学霸一次。</li><li>选择了毕业向喜欢的女生表白，不想彼此错过，虽然很短暂。</li><li>选择了毕业工作，放弃保研，不去考公务员，我不后悔自己的选择，这会是一次milestone。</li><li>选择了在公司附近租房，虽然有些贵，但是不用挤三小时地铁。</li><li>选择了扇贝，收获了一种学习习惯。</li><li>选择了写博客，<a href="http://xn--Daozhang-sc0mo0ce80a4gy33j.info" target="_blank" rel="noopener">建个人博客Daozhang.info</a>，写BUCTML网站(inBuilding)，虽然还在构建中。</li><li>选择了贡献开源项目<a href="https://github.com/qiwihui" target="_blank" rel="noopener">@github</a>，因为我开始讨厌封闭的W系统。</li><li>现在每天都要看几页书，虽然少，但积累的力量很恐怖，不看不爽说。</li><li>我喜欢吃巧克力，而且是黑巧克力。</li><li>选择了学轮滑，耍蝴蝶刀，因为我喜欢。</li><li>选择了给自己一个KeepStudying梦，我会为之而努力！多谢老姐的泼热水支持。</li><li>感谢一路相伴的大学童鞋，四年的感觉真好，重逢必有时！</li><li>工作团队很喜欢，哈哈！</li></ul><h3>失</h3><ul><li>因为生病，错过了班级的毕业旅行，再也没有了。</li><li>今年没有去宁波，只能等到明年了，我不是拖延症。</li><li><a href="https://www.facebook.com/weihui.qiu" target="_blank" rel="noopener">Facebook</a>, <a href="https://twitter.com/QiuWeihui1" target="_blank" rel="noopener">Twitter</a>, <a href="https://plus.google.com/+WeihuiQiu/" target="_blank" rel="noopener">G+</a>, QQ, Wechat…分散了我的精力，有社交依赖了。</li><li>没能把Google Glass的购买码送出去，人品。</li><li>我不想扯到关于买房买车的问题。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写在2013年到2014年还有不到一个月的时候, 对我第一年工作的状态有一个简单的描述, 每年都要给自己写一个年终总结。&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="https://qiwihui.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="https://qiwihui.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="总结" scheme="https://qiwihui.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>One problem at Haidian Book City</title>
    <link href="https://qiwihui.com/qiwihui-blog-2/"/>
    <id>https://qiwihui.com/qiwihui-blog-2/</id>
    <published>2018-09-09T21:07:20.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>Today, I just came by Haidian Book City as usual at Haidian dist inBeijing. and I found the problem hung on the wall nearby. It is veryinteresting and I want to share it.</p><a id="more"></a><h2><strong>0x00 Problem</strong></h2><p>Here is one picture of it.</p><p><img src="https://user-images.githubusercontent.com/3297411/45277447-6ab6f900-b4fa-11e8-8201-8f9482f9e775.jpg" alt="27-problem_at_haidian_book_city"></p><p>A translation of that:</p><blockquote><p><em>Solve this problem, then it’s your domain:</em><em>{3, 13, 1113, 3113,…, the 8<sup>th</sup> number}.angelcrunch.com</em><br><em>(the QR code leads to the below link)</em><em><a href="http://www.angelcrunch.com/jiemi" target="_blank" rel="noopener">www.angelcrunch.com/jiemi</a></em></p></blockquote><p>Once you finish it, you will get the second as below:</p><blockquote><p><em>Guess a television series by the following numbers, and you will get an interview.</em><em>3113112211322112 / 311311</em></p></blockquote><h2><strong>0x01 Solution</strong></h2><p>Yes, as you may guess, it is one look-and-say sequence(sequence <a href="http://oeis.org/A006715" target="_blank" rel="noopener">A006715</a> in<a href="http://en.wikipedia.org/wiki/On-Line_Encyclopedia_of_Integer_Sequences" target="_blank" rel="noopener">OEIS</a>.</p><p>In the sewuence, each member is genrated from the previous menber by&quot;reading&quot; off the digits in it, counting rhe number of digits in groups ofthe same digit. For example:</p><ul><li>3 is reading off as “one 3” or 13.</li><li>13 is reading off as “one 1 one 3” or 1113.</li><li>1113 is reading off as “three 1s, then one 3” or 3113.</li><li>and so on.</li></ul><p>If we start with any digit <em>d</em> from 0 to 9 then <em>d</em> will remainindefinitely as the last digit of the sequence. For <em>d</em> different from 1, thesequence starts as follows:</p><p><em>d, 1d, 111d, 311d, 13211d, 111312211d, 31131122211d, …</em></p><p>As example in the following table.</p><p>    <table style="margin-right: auto; white-space: nowrap; width: auto;">      <tr style="Text">        <td align="left"><b><i>d</i></b></td>        <td align="left"><b>Sloane</b></td>        <td align="left"><b>sequence</b></td>      </tr>      <tr style="Text">        <td align="left">1</td>        <td align="left"><a href="http://oeis.org/A005150" target="_blank" rel="noopener">A005150</a></td>        <td align="left">1, 11, 21, 1211, 111221, 312211, 13112221, 1113213211, ...</td>      </tr>      <tr style="Text">        <td align="left">2</td>        <td align="left"><a href="http://oeis.org/A006751" target="_blank" rel="noopener">A006751</a></td>        <td align="left">2, 12, 1112, 3112, 132112, 1113122112, 311311222112, ...</td>      </tr>      <tr style="Text">        <td align="left">3</td>        <td align="left"><a href="http://oeis.org/A006715" target="_blank" rel="noopener">A006715</a></td>        <td align="left">3, 13, 1113, 3113, 132113, 1113122113, 311311222113, ...</td>      </tr>    </table></p><p>Here, <em>d</em> equals 3.</p><p>So the first answer is 13211321322113.</p><p>For the second one, you need to know more about the sequence.John Conway studied this sequence and found that the 8<sup>th</sup>member and every member after it in the sequence is made up of one or moreof 92 “basic” non-interacting subsequences. The 92 basic subsequence showsin the following table(from <a href="http://www.pdmi.ras.ru/~lowdimma/topics_nth/conway_blocks.pdf" target="_blank" rel="noopener">here</a>.</p><p>The fouth column in the table says what othersubsequences the given subsequence evolves into. He also show that thenumber of the digits in each member of the sequence grows a constant fromone member to the next. If L<ins>n</ins> is the number of the digits in then<sup>th</sup> member in the sequence, then L<ins>n+1</ins>/L<ins>n</ins> toa limitation when n to infinity. It is 1.303577269… , which we call itas <strong>Conway Constant</strong>.</p><p>  <table style="margin-right: auto; white-space: nowrap; width: auto;">      <tbody>        <tr>          <th>No.</th>          <th>Subsequence</th>          <th>Length</th>          <th>Evolves Into</th>        </tr>        <tr>          <td><strong>1</strong></td>          <td>1112</td>          <td>4</td>          <td>(63)</td>        </tr>        <tr>          <td><strong>2</strong></td>          <td>1112133</td>          <td>7</td>          <td>(64)(62)</td>        </tr>        <tr>          <td><strong>3</strong></td>          <td>111213322112</td>          <td>12</td>          <td>(65)</td>        </tr>        <tr>          <td><strong>4</strong></td>          <td>111213322113</td>          <td>12</td>          <td>(66)</td>        </tr>        <tr>          <td><strong>5</strong></td>          <td>1113</td>          <td>4</td>          <td>(68)</td>        </tr>        <tr>          <td><strong>6</strong></td>          <td>11131</td>          <td>5</td>          <td>(69)</td>        </tr>        <tr>          <td><strong>7</strong></td>          <td>111311222112</td>          <td>12</td>          <td>(84)(55)</td>        </tr>        <tr>          <td><strong>8</strong></td>          <td>111312</td>          <td>6</td>          <td>(70)</td>        </tr>        <tr>          <td><strong>9</strong></td>          <td>11131221</td>          <td>8</td>          <td>(71)</td>        </tr>        <tr>          <td><strong>10</strong></td>          <td>1113122112</td>          <td>10</td>          <td>(76)</td>        </tr>        <tr>          <td><strong>11</strong></td>          <td>1113122113</td>          <td>10</td>          <td>(77)</td>        </tr>        <tr>          <td><strong>12</strong></td>          <td>11131221131112</td>          <td>14</td>          <td>(82)</td>        </tr>        <tr>          <td><strong>13</strong></td>          <td>111312211312</td>          <td>12</td>          <td>(78)</td>        </tr>        <tr>          <td><strong>14</strong></td>          <td>11131221131211</td>          <td>14</td>          <td>(79)</td>        </tr>        <tr>          <td><strong>15</strong></td>          <td>111312211312113211</td>          <td>18</td>          <td>(80)</td>        </tr>        <tr>          <td><strong>16</strong></td>          <td>111312211312113221133211322112211213322112</td>          <td>42</td>          <td>(81)(29)(91)</td>        </tr>        <tr>          <td><strong>17</strong></td>          <td>111312211312113221133211322112211213322113</td>          <td>42</td>          <td>(81)(29)(90)</td>        </tr>        <tr>          <td><strong>18</strong></td>          <td>11131221131211322113322112</td>          <td>26</td>          <td>(81)(30)</td>        </tr>        <tr>          <td><strong>19</strong></td>          <td>11131221133112</td>          <td>14</td>          <td>(75)(29)(92)</td>        </tr>        <tr>          <td><strong>20</strong></td>          <td>1113122113322113111221131221</td>          <td>28</td>          <td>(75)(32)</td>        </tr>        <tr>          <td><strong>21</strong></td>          <td>11131221222112</td>          <td>14</td>          <td>(72)</td>        </tr>        <tr>          <td><strong>22</strong></td>          <td>111312212221121123222112</td>          <td>24</td>          <td>(73)</td>        </tr>        <tr>          <td><strong>23</strong></td>          <td>111312212221121123222113</td>          <td>24</td>          <td>(74)</td>        </tr>        <tr>          <td><strong>24</strong></td>          <td>11132</td>          <td>5</td>          <td>(83)</td>        </tr>        <tr>          <td><strong>25</strong></td>          <td>1113222</td>          <td>7</td>          <td>(86)</td>        </tr>        <tr>          <td><strong>26</strong></td>          <td>1113222112</td>          <td>10</td>          <td>(87)</td>        </tr>        <tr>          <td><strong>27</strong></td>          <td>1113222113</td>          <td>10</td>          <td>(88)</td>        </tr>        <tr>          <td><strong>28</strong></td>          <td>11133112</td>          <td>8</td>          <td>(89)(92)</td>        </tr>        <tr>          <td><strong>29</strong></td>          <td>12</td>          <td>2</td>          <td>(1)</td>        </tr>        <tr>          <td><strong>30</strong></td>          <td>123222112</td>          <td>9</td>          <td>(3)</td>        </tr>        <tr>          <td><strong>31</strong></td>          <td>123222113</td>          <td>9</td>          <td>(4)</td>        </tr>        <tr>          <td><strong>32</strong></td>          <td>12322211331222113112211</td>          <td>23</td>          <td>(2)(61)(29)(85)</td>        </tr>        <tr>          <td><strong>33</strong></td>          <td>13</td>          <td>2</td>          <td>(5)</td>        </tr>        <tr>          <td><strong>34</strong></td>          <td>131112</td>          <td>6</td>          <td>(28)</td>        </tr>        <tr>          <td><strong>35</strong></td>          <td>13112221133211322112211213322112</td>          <td>32</td>          <td>(24)(33)(61)(29)(91)</td>        </tr>        <tr>          <td><strong>36</strong></td>          <td>13112221133211322112211213322113</td>          <td>32</td>          <td>(24)(33)(61)(29)(90)</td>        </tr>        <tr>          <td><strong>37</strong></td>          <td>13122112</td>          <td>8</td>          <td>(7)</td>        </tr>        <tr>          <td><strong>38</strong></td>          <td>132</td>          <td>3</td>          <td>(8)</td>        </tr>        <tr>          <td><strong>39</strong></td>          <td>13211</td>          <td>5</td>          <td>(9)</td>        </tr>        <tr>          <td><strong>40</strong></td>          <td>132112</td>          <td>6</td>          <td>(10)</td>        </tr>        <tr>          <td><strong>41</strong></td>          <td>1321122112</td>          <td>10</td>          <td>(21)</td>        </tr>        <tr>          <td><strong>42</strong></td>          <td>132112211213322112</td>          <td>18</td>          <td>(22)</td>        </tr>        <tr>          <td><strong>43</strong></td>          <td>132112211213322113</td>          <td>18</td>          <td>(23)</td>        </tr>        <tr>          <td><strong>44</strong></td>          <td>132113</td>          <td>6</td>          <td>(11)</td>        </tr>        <tr>          <td><strong>45</strong></td>          <td>1321131112</td>          <td>10</td>          <td>(19)</td>        </tr>        <tr>          <td><strong>46</strong></td>          <td>13211312</td>          <td>8</td>          <td>(12)</td>        </tr>        <tr>          <td><strong>47</strong></td>          <td>1321132</td>          <td>7</td>          <td>(13)</td>        </tr>        <tr>          <td><strong>48</strong></td>          <td>13211321</td>          <td>8</td>          <td>(14)</td>        </tr>        <tr>          <td><strong>49</strong></td>          <td>132113212221</td>          <td>12</td>          <td>(15)</td>        </tr>        <tr>          <td><strong>50</strong></td>          <td>13211321222113222112</td>          <td>20</td>          <td>(18)</td>        </tr>        <tr>          <td><strong>51</strong></td>          <td>1321132122211322212221121123222112</td>          <td>34</td>          <td>(16)</td>        </tr>        <tr>          <td><strong>52</strong></td>          <td>1321132122211322212221121123222113</td>          <td>34</td>          <td>(17)</td>        </tr>        <tr>          <td><strong>53</strong></td>          <td>13211322211312113211</td>          <td>20</td>          <td>(20)</td>        </tr>        <tr>          <td><strong>54</strong></td>          <td>1321133112</td>          <td>10</td>          <td>(6)(61)(29)(92)</td>        </tr>        <tr>          <td><strong>55</strong></td>          <td>1322112</td>          <td>7</td>          <td>(26)</td>        </tr>        <tr>          <td><strong>56</strong></td>          <td>1322113</td>          <td>7</td>          <td>(27)</td>        </tr>        <tr>          <td><strong>57</strong></td>          <td>13221133112</td>          <td>11</td>          <td>(25)(29)(92)</td>        </tr>        <tr>          <td><strong>58</strong></td>          <td>1322113312211</td>          <td>13</td>          <td>(25)(29)(67)</td>        </tr>        <tr>          <td><strong>59</strong></td>          <td>132211331222113112211</td>          <td>21</td>          <td>(25)(29)(85)</td>        </tr>        <tr>          <td><strong>60</strong></td>          <td>13221133122211332</td>          <td>17</td>          <td>(25)(29)(68)(61)(29)(89)</td>        </tr>        <tr>          <td><strong>61</strong></td>          <td>22</td>          <td>2</td>          <td>(61)</td>        </tr>        <tr>          <td><strong>62</strong></td>          <td>3</td>          <td>1</td>          <td>(33)</td>        </tr>        <tr>          <td><strong>63</strong></td>          <td>3112</td>          <td>4</td>          <td>(40)</td>        </tr>        <tr>          <td><strong>64</strong></td>          <td>3112112</td>          <td>7</td>          <td>(41)</td>        </tr>        <tr>          <td><strong>65</strong></td>          <td>31121123222112</td>          <td>14</td>          <td>(42)</td>        </tr>        <tr>          <td><strong>66</strong></td>          <td>31121123222113</td>          <td>14</td>          <td>(43)</td>        </tr>        <tr>          <td><strong>67</strong></td>          <td>3112221</td>          <td>7</td>          <td>(38)(39)</td>        </tr>        <tr>          <td><strong>68</strong></td>          <td>3113</td>          <td>4</td>          <td>(44)</td>        </tr>        <tr>          <td><strong>69</strong></td>          <td>311311</td>          <td>6</td>          <td>(48)</td>        </tr>        <tr>          <td><strong>70</strong></td>          <td>31131112</td>          <td>8</td>          <td>(54)</td>        </tr>        <tr>          <td><strong>71</strong></td>          <td>3113112211</td>          <td>10</td>          <td>(49)</td>        </tr>        <tr>          <td><strong>72</strong></td>          <td>3113112211322112</td>          <td>16</td>          <td>(50)</td>        </tr>        <tr>          <td><strong>73</strong></td>          <td>3113112211322112211213322112</td>          <td>28</td>          <td>(51)</td>        </tr>        <tr>          <td><strong>74</strong></td>          <td>3113112211322112211213322113</td>          <td>28</td>          <td>(52)</td>        </tr>        <tr>          <td><strong>75</strong></td>          <td>311311222</td>          <td>9</td>          <td>(47)(38)</td>        </tr>        <tr>          <td><strong>76</strong></td>          <td>311311222112</td>          <td>12</td>          <td>(47)(55)</td>        </tr>        <tr>          <td><strong>77</strong></td>          <td>311311222113</td>          <td>12</td>          <td>(47)(56)</td>        </tr>        <tr>          <td><strong>78</strong></td>          <td>3113112221131112</td>          <td>16</td>          <td>(47)(57)</td>        </tr>        <tr>          <td><strong>79</strong></td>          <td>311311222113111221</td>          <td>18</td>          <td>(47)(58)</td>        </tr>        <tr>          <td><strong>80</strong></td>          <td>311311222113111221131221</td>          <td>24</td>          <td>(47)(59)</td>        </tr>        <tr>          <td><strong>81</strong></td>          <td>31131122211311122113222</td>          <td>23</td>          <td>(47)(60)</td>        </tr>        <tr>          <td><strong>82</strong></td>          <td>3113112221133112</td>          <td>16</td>          <td>(47)(33)(61)(29)(92)</td>        </tr>        <tr>          <td><strong>83</strong></td>          <td>311312</td>          <td>6</td>          <td>(45)</td>        </tr>        <tr>          <td><strong>84</strong></td>          <td>31132</td>          <td>5</td>          <td>(46)</td>        </tr>        <tr>          <td><strong>85</strong></td>          <td>311322113212221</td>          <td>15</td>          <td>(53)</td>        </tr>        <tr>          <td><strong>86</strong></td>          <td>311332</td>          <td>6</td>          <td>(38)(29)(89)</td>        </tr>        <tr>          <td><strong>87</strong></td>          <td>3113322112</td>          <td>10</td>          <td>(38)(30)</td>        </tr>        <tr>          <td><strong>88</strong></td>          <td>3113322113</td>          <td>10</td>          <td>(38)(31)</td>        </tr>        <tr>          <td><strong>89</strong></td>          <td>312</td>          <td>3</td>          <td>(34)</td>        </tr>        <tr>          <td><strong>90</strong></td>          <td>312211322212221121123222113</td>          <td>27</td>          <td>(36)</td>        </tr>        <tr>          <td><strong>91</strong></td>          <td>312211322212221121123222122</td>          <td>27</td>          <td>(35)</td>        </tr>        <tr>          <td><strong>92</strong></td>          <td>32112</td>          <td>5</td>          <td>(37)</td>        </tr>      </tbody>    </table></p><p>Those 92 subsequence is so basic that is constructs every member in the look-and-saysequence. Just like 92 elements. <a href="http://mathworld.wolfram.com/CosmologicalTheorem.html" target="_blank" rel="noopener">Here</a>gives the periodic table of atoms associated with the look-and-say sequenceas named by Conway(1987). As we can see, 3113112211322112 links to <strong>Br</strong>, and311311 links to <strong>Ba</strong>.</p><p><strong>Br</strong>eaking <strong>Ba</strong>d. That is the answer.</p><h2><strong>0x02 More</strong></h2><p>That is perfect from the begining to the end. Many thanks to the problemmaker, and the screenwriters, also everyexcellent actors in Breaking Bad.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Today, I just came by Haidian Book City as usual at Haidian dist in
Beijing. and I found the problem hung on the wall nearby. It is very
interesting and I want to share it.&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Hello World!</title>
    <link href="https://qiwihui.com/qiwihui-blog-1/"/>
    <id>https://qiwihui.com/qiwihui-blog-1/</id>
    <published>2018-09-09T20:44:19.000Z</published>
    <updated>2020-05-16T15:36:39.350Z</updated>
    
    <content type="html"><![CDATA[<p>Hello from qiwihui.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Hello from qiwihui.&lt;/p&gt;

      
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
</feed>
